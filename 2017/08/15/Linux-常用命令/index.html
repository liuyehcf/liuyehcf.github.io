<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="阅读更多">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux-常用命令">
<meta property="og:url" content="http://example.com/2017/08/15/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/index.html">
<meta property="og:site_name" content="Liuye Blog">
<meta property="og:description" content="阅读更多">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/arping-1.png">
<meta property="og:image" content="http://example.com/images/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/arping-2.png">
<meta property="og:image" content="http://example.com/images/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/arping-3.png">
<meta property="og:image" content="http://example.com/images/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/arping-4.png">
<meta property="og:image" content="http://example.com/images/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/audit_architecture.png">
<meta property="article:published_time" content="2017-08-15T12:17:57.000Z">
<meta property="article:modified_time" content="2021-10-30T06:39:19.257Z">
<meta property="article:author" content="Liuyehcf">
<meta property="article:tag" content="摘录">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/arping-1.png">

<link rel="canonical" href="http://example.com/2017/08/15/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux-常用命令 | Liuye Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Liuye Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-explore">

    <a href="/explore/" rel="section"><i class="fa fa-sitemap fa-fw"></i>发现</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/08/15/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Liuyehcf">
      <meta itemprop="description" content="大音希声，大象无形">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liuye Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux-常用命令
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-15 20:17:57" itemprop="dateCreated datePublished" datetime="2017-08-15T20:17:57+08:00">2017-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-30 14:39:19" itemprop="dateModified" datetime="2021-10-30T14:39:19+08:00">2021-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Operating-System/" itemprop="url" rel="index"><span itemprop="name">Operating System</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Operating-System/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          
            <span id="/2017/08/15/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-meta-item leancloud_visitors" data-flag-title="Linux-常用命令" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2017/08/15/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2017/08/15/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>阅读更多</strong></p>
<a id="more"></a>
<h1 id="1-系统信息"><a class="markdownIt-Anchor" href="#1-系统信息"></a> 1 系统信息</h1>
<h2 id="11-uname"><a class="markdownIt-Anchor" href="#11-uname"></a> 1.1 uname</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>uname [option]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-a, --all</code>：以如下次序输出所有信息。其中若<code>-p</code>和<code>-i</code>的探测结果不可知则被省略：</li>
<li><code>-s, --kernel-name</code>：输出内核名称</li>
<li><code>-n, --nodename</code>：输出网络节点上的主机名</li>
<li><code>-r, --kernel-release</code>：输出内核发行号</li>
<li><code>-v, --kernel-version</code>：输出内核版本</li>
<li><code>-m, --machine</code>：输出主机的硬件架构名称</li>
<li><code>-p, --processor</code>：输出处理器类型或&quot;unknown&quot;</li>
<li><code>-i, --hardware-platform</code>：输出硬件平台或&quot;unknown&quot;</li>
<li><code>-o, --operating-system</code>：输出操作系统名称</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>uname -a</code></li>
<li><code>uname -r</code></li>
<li><code>uname -s</code></li>
</ul>
<h2 id="12-chsh"><a class="markdownIt-Anchor" href="#12-chsh"></a> 1.2 chsh</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>chsh [-ls]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-l</code>：列出目前系统上可用的shell，其实就是<code>/etc/shells</code>的内容</li>
<li><code>-s</code>：设置修改自己的shell</li>
</ul>
<h2 id="13-man"><a class="markdownIt-Anchor" href="#13-man"></a> 1.3 man</h2>
<ul>
<li><code>man 1</code>：标准Linux命令</li>
<li><code>man 2</code>：系统调用</li>
<li><code>man 3</code>：库函数</li>
<li><code>man 4</code>：设备说明</li>
<li><code>man 5</code>：文件格式</li>
<li><code>man 6</code>：游戏娱乐</li>
<li><code>man 7</code>：杂项</li>
<li><code>man 8</code>：系统管理员命令</li>
<li><code>man 9</code>：常规内核文件</li>
</ul>
<h2 id="14-demsg"><a class="markdownIt-Anchor" href="#14-demsg"></a> 1.4 demsg</h2>
<p>kernel会将开机信息存储在<code>ring buffer</code>中。您若是开机时来不及查看信息，可利用<code>dmesg</code>来查看。开机信息亦保存在<code>/var/log</code>目录中，名称为dmesg的文件里</p>
<h2 id="15-last"><a class="markdownIt-Anchor" href="#15-last"></a> 1.5 last</h2>
<p><strong>示例：</strong></p>
<ul>
<li><code>last -x</code></li>
</ul>
<h2 id="16-w"><a class="markdownIt-Anchor" href="#16-w"></a> 1.6 w</h2>
<p>该命令用于查看当前谁登录了系统，并且正在做什么事情，比<code>who</code>更强大一点</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>w</code></li>
</ul>
<h2 id="17-useradd"><a class="markdownIt-Anchor" href="#17-useradd"></a> 1.7 useradd</h2>
<p>添加账号</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>useradd test -g wheel -G wheel -m -s /bin/bash</code></li>
</ul>
<h2 id="18-usermod"><a class="markdownIt-Anchor" href="#18-usermod"></a> 1.8 usermod</h2>
<p><strong>示例：</strong></p>
<ul>
<li><code>usermod -s /bin/zsh admin</code></li>
<li><code>usermod -d /opt/home/admin admin</code></li>
</ul>
<h2 id="19-passwd"><a class="markdownIt-Anchor" href="#19-passwd"></a> 1.9 passwd</h2>
<p><strong>示例：</strong></p>
<ul>
<li><code>echo '123456' | passwd --stdin root</code></li>
</ul>
<h2 id="110-readelf"><a class="markdownIt-Anchor" href="#110-readelf"></a> 1.10 readelf</h2>
<p>用于读取、解析可执行程序</p>
<h2 id="111-getconf"><a class="markdownIt-Anchor" href="#111-getconf"></a> 1.11 getconf</h2>
<p>查看系统相关的信息</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>getconf -a | grep CACHE</code>：查看CPU cache相关的配置项</li>
</ul>
<h1 id="2-常用处理工具"><a class="markdownIt-Anchor" href="#2-常用处理工具"></a> 2 常用处理工具</h1>
<h2 id="21-echo"><a class="markdownIt-Anchor" href="#21-echo"></a> 2.1 echo</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>echo [-ne] [字符串/变量]</code></li>
<li><code>''</code>中的变量不会被解析，<code>&quot;&quot;</code>中的变量会被解析</li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-n</code>：不要在最后自动换行</li>
<li><code>-e</code>：打开反斜杠ESC转义。若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出
<ul>
<li><code>\a</code>：发出警告声</li>
<li><code>\b</code>：删除前一个字符</li>
<li><code>\c</code>：最后不加上换行符号</li>
<li><code>\f</code>：换行但光标仍旧停留在原来的位置</li>
<li><code>\n</code>：换行且光标移至行首</li>
<li><code>\r</code>：光标移至行首，但不换行</li>
<li><code>\t</code>：插入tab</li>
<li><code>\v</code>：与\f相同</li>
<li><code>\\</code>：插入\字符</li>
<li><code>\nnn</code>：插入nnn（八进制）所代表的ASCII字符</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>echo $&#123;a&#125;</code></li>
<li><code>echo -e &quot;a\nb&quot;</code></li>
</ul>
<p><strong>颜色控制，控制选项说明：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[30m 黑色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[31m 红色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[32m 绿色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[33m 黄色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[34m 蓝色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[35m 紫色字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[36m 天蓝字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[37m 白色字 \033[0m&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[40;37m 黑底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[41;37m 红底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[42;37m 绿底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[43;37m 黄底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[44;37m 蓝底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[45;37m 紫底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[46;37m 天蓝底白字 \033[0m&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[47;30m 白底黑字 \033[0m&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="22-sed"><a class="markdownIt-Anchor" href="#22-sed"></a> 2.2 sed</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>sed [-nefr] [动作] [文件]</code></li>
<li><code>STD IN | sed [-nefr] [动作]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong><code>-n</code></strong>：使用安静(silent)模式，在一般sed中，所有来自STDIN的数据一般都会被列到屏幕上，加了参数-n后，只有经过sed特殊处理的那一行才会被列出来</li>
<li><strong><code>-e</code></strong>：直接在命令行模式上进行sed的动作编辑</li>
<li><strong><code>-f</code></strong>：直接将sed的动作写在一个文件内，<code>-f filenmae</code>则可以执行filename内的sed动作</li>
<li><strong><code>-r</code></strong>：sed的动作支持的是扩展正则表达式的语法
<ul>
<li><strong>不加<code>-r</code>参数，连<code>()</code>都需要转义，因此最好加上<code>-r</code>参数</strong></li>
<li><code>\0</code>：表示整个匹配串，<code>\1</code>表示group1，以此类推</li>
<li><code>&amp;</code>：表示整个匹配串</li>
</ul>
</li>
<li><strong><code>-i</code></strong>：直接修改读取的文件内容，而不是由屏幕输出</li>
</ul>
<p><strong>动作说明，格式为<code>[n1 [,n2]]function</code>，接的动作必须以两个单引号括住</strong></p>
<ul>
<li><strong>如果没有<code>[n1 [,n2]]</code>，表示对所有行均生效</strong></li>
<li><strong>如果仅有<code>[n1]</code>，表示仅对<code>n1</code>行生效</strong></li>
<li><strong><code>n1</code>与<code>n2</code>可以用<code>/string/</code>来表示<code>[ /string_n1/ ,[ /stirng_n2/ ]]</code></strong>。<strong>配合<code>-r</code>参数，还可以使用正则表达式</strong>
<ul>
<li><strong><code>/string_n1/</code></strong>：<strong>从第一行开始</strong>，<code>所有</code>匹配字符串<code>string_n1</code>的行号</li>
<li><strong><code>/string_n1/,/stirng_n2/</code></strong>：<strong>从第一行开始</strong>，<code>第一个</code>匹配字符串<code>string_n1</code>的行号，到，<strong>从第一行开始</strong>，<code>第一个</code>匹配字符串<code>stirng_n2</code>的行号</li>
<li><strong>当该行包含<code>string</code>时，就算匹配成功</strong></li>
<li><strong>如果要匹配整行，可以利用<code>-r</code>参数配合正则表达式通配符<code>^</code>与<code>$</code>来完成</strong></li>
<li><strong>由于<code>/</code>是特殊字符，因此在正则表达式中，表示一个普通的<code>/</code>需要转义</strong></li>
</ul>
</li>
<li><strong><code>a</code></strong>：新增，a的后面可接字符串，而这些字符串会在新的一行出现(目前行的下一行)</li>
<li><strong><code>c</code></strong>：替换，c的后面可接字符串，这些字符串可以替换n1,n2之间的行</li>
<li><strong><code>d</code></strong>：删除，后面通常不接任何参数</li>
<li><strong><code>i</code></strong>：插入，i的后面可接字符串，而这些字符串会在新的一行出现(目前行的上一行)</li>
<li><strong><code>p</code></strong>：打印，也就是将某个选择的数据打印出来，通常p会与参数sed -n一起运行</li>
<li><strong><code>s</code></strong>：替换，可以直接进行替换的工作，通常这个s可以搭配正则表达式，例如1,20s/lod/new/g  (跟vim里面的很像！！！)
<ul>
<li><strong>分隔符可以是<code>/</code>也可以是<code>|</code></strong></li>
<li><strong>分隔符若为<code>/</code>，那么普通的<code>|</code>不需要转义，<code>/</code>需要转义</strong></li>
<li><strong>分隔符若为<code>|</code>，那么普通的<code>/</code>不需要转义，<code>|</code>需要转义</strong></li>
<li><code>g</code>：表示每行全部替换，否则只替换每行第一个</li>
</ul>
</li>
<li><strong><code>r</code></strong>：插入另一个文本的所有内容</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><strong><code>a</code></strong>：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;a\nb\nc&quot;</span> | sed <span class="string">&#x27;1,2anewLine&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">a</span><br><span class="line">newLine</span><br><span class="line">b</span><br><span class="line">newLine</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>c</code></strong>：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /^a$/通过正则表达式匹配第一行，需要配合-r参数</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;a\nb\nc&quot;</span> | sed -r <span class="string">&#x27;/^a$/,2cnewLine&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">newLine</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>d</code></strong>：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除第2行，到第一个包含字符&#x27;c&#x27;的行</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;a\nb\nc&quot;</span> | sed <span class="string">&#x27;2,/c/d&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>i</code></strong>：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;a\nb\nc&quot;</span> | sed <span class="string">&#x27;1,2inewLine&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">newLine</span><br><span class="line">a</span><br><span class="line">newLine</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>p</code></strong>：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $表示最后一行</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;a\nb\nc&quot;</span> | sed -n <span class="string">&#x27;/b/,$p&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>s</code></strong>：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 作用于所有行，对于每一行，将第一个a替换为A</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;abcabc\nbcabca\ncabcab&quot;</span> | sed <span class="string">&#x27;s/a/A/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 作用于所有行，对于每一行，将所有a替换为A</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;abcabc\nbcabca\ncabcab&quot;</span> | sed <span class="string">&#x27;s/a/A/g&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 作用于所有行，对于每一行，将所有a替换为A，并打印出来</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;abcabc\nbcabca\ncabcab&quot;</span> | sed -n <span class="string">&#x27;s/a/A/gp&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 作用于第一行到第三行，对于所有第三个字符为a的串，删掉字符a，保留前两个字符</span></span><br><span class="line"><span class="comment"># /^abc/匹配第一个以abc开头的行，/cab$/匹配第一个以cab结尾的行</span></span><br><span class="line"><span class="comment"># 以下两个等价，分隔符可以用&#x27;/&#x27;，可以用&#x27;|&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;abcabc\nbcabca\ncabcab&quot;</span> | sed -nr <span class="string">&#x27;/^abc/,/cab$/s/(..)a/\1/gp&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;abcabc\nbcabca\ncabcab&quot;</span> | sed -nr <span class="string">&#x27;/^abc/,/cab$/s|(..)a|\1|gp&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 作用于最后一行，对于所有串loverable，替换成lovers</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;loverable&quot;</span> | sed -nr <span class="string">&#x27;$s/(love)rable/\1rs/gp&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将/root/替换为/，下面两个等价</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/root/document/file.txt&quot;</span> | sed -nr <span class="string">&#x27;s|/root/|/|p&#x27;</span>     <span class="comment"># 此时&#x27;/&#x27;不需要转义，因为分隔符是&#x27;|&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/root/document/file.txt&quot;</span> | sed -nr <span class="string">&#x27;s/\/root\//\//p&#x27;</span>  <span class="comment"># 此时&#x27;/&#x27;需要转义，因为分隔符也是&#x27;/&#x27;（看起来就不直观）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有a或b替换成A，下面两个等价</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;abc&quot;</span> | sed -nr <span class="string">&#x27;s/a|b/A/gp&#x27;</span>   <span class="comment"># 此时&#x27;|&#x27;不需要转义，因为分隔符是&#x27;/&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;abc&quot;</span> | sed -nr <span class="string">&#x27;s|a\|b|A|gp&#x27;</span>  <span class="comment"># 此时&#x27;|&#x27;需要转义，因为分隔符是&#x27;|&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>r</code>：</strong></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备文件1</span></span><br><span class="line">cat &gt; file1.txt &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;tag&gt;</span></span><br><span class="line"><span class="string">&lt;/tag&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备文件2</span></span><br><span class="line">cat &gt; file2.txt &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">Hello world!!</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sed <span class="string">&#x27;/&lt;tag&gt;/ r file2.txt&#x27;</span> file1.txt</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：在macOS中，<code>-i</code>参数后面要跟一个扩展符，用于备份源文件。如果扩展符长度是0，那么不进行备份</p>
<ul>
<li><code>sed -i &quot;.back&quot; &quot;s/a/b/g&quot; example</code>：备份文件为<code>example.back</code></li>
<li><code>sed -i &quot;&quot; &quot;s/a/b/g&quot; example</code>：不备份</li>
</ul>
<h2 id="23-awk"><a class="markdownIt-Anchor" href="#23-awk"></a> 2.3 awk</h2>
<p>相比于sed(管道命令)常常作用于一整行的处理，awk(管道命令)则比较倾向于将一行分成数个&quot;字段&quot;来处理，因此awk相当适合处理小型的数据处理</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>awk [-F] '[/regex/] 条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125;...' [filename]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-F</code>：后接分隔符。例如：<code>-F ':'</code>、<code>-F '[,.;]'</code></li>
</ul>
<p>注意awk后续的所有动作都是以单引号括住的，而且如果以print打印时，非变量的文字部分，包括格式等(例如制表<code>\t</code>、换行<code>\n</code>等)都需要以双引号的形式定义出来，因为单引号已经是awk的命令固定用法了。例如<code>last -n 5 | awk '&#123;print $1 &quot;\t&quot; $3&#125;'</code></p>
<p><strong>awk处理流程：</strong></p>
<ol>
<li>读入第一行
<ul>
<li><strong>如果包含正则匹配部分（<code>[/regex/]</code>），如果不匹配则跳过该行；如果匹配（任意子串），那么将第一行的数据填入<code>$0</code>,<code>$1</code>,…等变量中</strong></li>
<li>如果不包含正则匹配部分，那么将第一行的数据填入<code>$0</code>,<code>$1</code>,…等变量中</li>
</ul>
</li>
<li>依据条件类型的限制，判断是否需要进行后面的动作</li>
<li>做完所有的动作与条件类型</li>
<li>若还有后续的’行’，重复上面的步骤，直到所有数据都读取完为止</li>
</ol>
<p><strong>awk内置变量：</strong></p>
<ul>
<li><code>ARGC</code>：命令行参数个数</li>
<li><code>ARGV</code>：命令行参数排列</li>
<li><code>ENVIRON</code>：支持队列中系统环境变量的使用</li>
<li><code>FILENAME</code>：awk浏览的文件名</li>
<li><code>FNR</code>：浏览文件的记录数</li>
<li><strong><code>FS</code>：设置输入域分隔符，默认是空格键，等价于命令行 -F选项</strong></li>
<li><strong><code>NF</code>：每一行($0)拥有的字段总数</strong></li>
<li><strong><code>NR</code>：目前awk所处理的是第几行</strong></li>
<li><code>OFS</code>：输出域分隔符</li>
<li><code>ORS</code>：输出记录分隔符</li>
<li><code>RS</code>：控制记录分隔符</li>
<li>在动作内部引用这些变量不需要用<code>$</code>，例如<code>last -n 5 | awk '&#123;print $1 &quot;\t lines: &quot; NR &quot;\t columes: &quot; NF&#125;'</code></li>
<li>此外，<code>$0</code>变量是指整条记录。<code>$1</code>表示当前行的第一个域，<code>$2</code>表示当前行的第二个域，以此类推</li>
</ul>
<p><strong>awk内置函数</strong></p>
<ul>
<li><code>sub(r, s [, t])</code>：用<code>s</code>替换字符串<code>t</code>中的第一个正则表达式<code>r</code></li>
<li><code>gsub(r, s [, t])</code>：用<code>s</code>替换字符串<code>t</code>中的所有正则表达式<code>r</code></li>
<li><code>tolower(s)</code>：将字符串<code>s</code>的每个字母替换成小写字母</li>
<li><code>toupper(s)</code>：将字符串<code>s</code>的每个字母替换成大写字母</li>
<li><code>length(s)</code>：返回字符串长度</li>
</ul>
<p><strong>动作说明：</strong></p>
<ul>
<li>所有awk的动作，即在<code>&#123;&#125;</code>内的动作，如果有需要多个命令辅助时，可以用分号<code>;</code>间隔，或者直接以<code>Enter</code>按键来隔开每个命令</li>
</ul>
<p><strong>BEGIN与END：</strong></p>
<ul>
<li>在Unix awk中两个特别的表达式，BEGIN和END，这两者都可用于pattern中（参考前面的awk语法），<strong>提供BEGIN和END的作用是给程序赋予初始状态和在程序结束之后执行一些扫尾的工作。</strong></li>
<li><strong>任何在BEGIN之后列出的操作（在<code>&#123;&#125;</code>内）将在Unix awk开始扫描输入之前执行，而END之后列出的操作将在扫描完全部的输入之后执行</strong>。因此，通常使用BEGIN来显示变量和预置（初始化）变量，使用END来输出最终结果</li>
</ul>
<p><strong>print与printf：</strong></p>
<ul>
<li>print会打印换行符</li>
<li>printf不会打印换行符</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>cat /etc/passwd | awk '&#123;FS=&quot;:&quot;&#125; $3&lt;10 &#123;print $1 &quot;\t&quot; $3&#125;'</code>：<strong>注意<code>&#123;FS=&quot;:&quot;&#125;</code>是作为一个动作存在的，因此从第二行开始分隔符才变为&quot;:&quot;，第一行分隔符仍然是空格</strong></li>
<li><code>cat /etc/passwd | awk 'BEGIN &#123;FS=&quot;:&quot;&#125; $3&lt;10 &#123;print $1 &quot;\t&quot; $3&#125;'</code>：<strong>这样写<code>&#123;FS=&quot;:&quot;&#125;</code>在处理第一行时也会生效</strong></li>
<li><code>echo -e &quot;abcdefg\nhijklmn\nopqrst\nuvwxyz&quot; | awk '/[au]/ &#123;print $0&#125;'</code></li>
<li><code>lvdisplay|awk '/LV Name/&#123;n=$3&#125; /Block device/&#123;d=$3; sub(&quot;.*:&quot;,&quot;dm-&quot;,d); print d,n;&#125;'</code>
<ul>
<li>这里有两个动作，这两个动作分别有两个条件，一个包含<code>LV Name</code>，另一个包含<code>Block device</code>，哪个条件满足就执行哪个动作，如果两个条件都满足，那么两个都执行（在这个case下，不可能同时满足）</li>
<li>首先匹配第一个条件，<code>n</code>存储的是卷组名称，假设是<code>swap</code></li>
<li>然后匹配第二个条件，<code>d</code>存储的是磁盘名称，假设是<code>253:1</code>，经过<code>sub</code>函数，将<code>253:</code>替换成<code>dm-</code>，因此此时d为<code>dm-1</code>，打印<code>d</code>和<code>n</code></li>
<li>接着匹配第一个条件，<code>n</code>存储的是卷组名称，假设是<code>root</code>，此时<code>d</code>的内容还是<code>dm-1</code></li>
<li>最后匹配第二个条件，<code>d</code>存储的是磁盘名称，假设是<code>253:0</code>，经过<code>sub</code>函数，将<code>253:</code>替换成<code>dm-</code>，因此此时d为<code>dm-0</code>，打印<code>d</code>和<code>n</code></li>
</ul>
</li>
<li></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk </span><br><span class="line">&#x27;BEGIN &#123;FS=&quot;:&quot;;print &quot;统计销售金额&quot;;total=0&#125; </span><br><span class="line">&#123;print $3;total=total+$3;&#125; </span><br><span class="line">END &#123;print &quot;销售金额总计：&quot;,total&#125;&#x27; sx</span><br></pre></td></tr></table></figure>
<h3 id="231-在awk中引用变量"><a class="markdownIt-Anchor" href="#231-在awk中引用变量"></a> 2.3.1 在awk中引用变量</h3>
<p><strong>方式1：</strong></p>
<ul>
<li>以<code>'&quot;</code>和<code>&quot;'</code>（即，单引号+双引号+shell变量+双引号+单引号）将shell变量包围起来</li>
<li><strong>这种方式只能引用数值变量</strong></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=4</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print &#x27;</span><span class="string">&quot;<span class="variable">$var</span>&quot;</span><span class="string">&#x27;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>方式2：</strong></p>
<ul>
<li>以<code>&quot;'</code>和<code>'&quot;</code>（即，双引号+单引号+shell变量+单引号+双引号）将shell变量包围起来</li>
<li><strong>这种方式可以引用字符串型变量，但是字符串不允许包含空格</strong></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=4</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print &quot;&#x27;</span><span class="variable">$var</span><span class="string">&#x27;&quot;&#125;&#x27;</span></span><br><span class="line">var=<span class="string">&quot;abc&quot;</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print &quot;&#x27;</span><span class="variable">$var</span><span class="string">&#x27;&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>方式3：</strong></p>
<ul>
<li>用<code>&quot;'&quot;</code>（即，双引号+单引号+双引号+shell变量+双引号+单引号+双引号）将shell变量包裹起来</li>
<li><strong>这种方式允许引用任意类型的变量</strong></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var=4</span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print &quot;&#x27;</span><span class="string">&quot;<span class="variable">$var</span>&quot;</span><span class="string">&#x27;&quot;&#125;&#x27;</span></span><br><span class="line">var=<span class="string">&quot;abc&quot;</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print &quot;&#x27;</span><span class="string">&quot;<span class="variable">$var</span>&quot;</span><span class="string">&#x27;&quot;&#125;&#x27;</span></span><br><span class="line">var=<span class="string">&quot;this a test&quot;</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;print &quot;&#x27;</span><span class="string">&quot;<span class="variable">$var</span>&quot;</span><span class="string">&#x27;&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>方式4：</strong></p>
<ul>
<li>使用<code>-v</code>参数，变量不是很多的时候，这种方式也蛮简介清晰的</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=<span class="string">&quot;this a test&quot;</span></span><br><span class="line">awk -v awkVar=<span class="string">&quot;<span class="variable">$var</span>&quot;</span> <span class="string">&#x27;BEGIN&#123;print awkVar&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="232-在awk中写简单的控制流语句"><a class="markdownIt-Anchor" href="#232-在awk中写简单的控制流语句"></a> 2.3.2 在awk中写简单的控制流语句</h3>
<p><strong>以下的示例都在BEGIN中，只执行一次，不需要指定文件或者输入流</strong></p>
<p><strong>if语句：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123; </span></span><br><span class="line"><span class="string">test=100;</span></span><br><span class="line"><span class="string">if(test&gt;90)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    print &quot;very good&quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">else if(test&gt;60)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    print &quot;good&quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    print &quot;no pass&quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>while语句：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123; </span></span><br><span class="line"><span class="string">test=100;</span></span><br><span class="line"><span class="string">total=0;</span></span><br><span class="line"><span class="string">while(i&lt;=test)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    total+=i;</span></span><br><span class="line"><span class="string">    i++;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">print total;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>for语句：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123; </span></span><br><span class="line"><span class="string">for(k in ENVIRON)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    print k&quot;=&quot;ENVIRON[k];</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123; </span></span><br><span class="line"><span class="string">total=0;</span></span><br><span class="line"><span class="string">for(i=0;i&lt;=100;i++)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    total+=i;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">print total;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>do语句：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123; </span></span><br><span class="line"><span class="string">total=0;</span></span><br><span class="line"><span class="string">i=0;</span></span><br><span class="line"><span class="string">do</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    total+=i;</span></span><br><span class="line"><span class="string">    i++;</span></span><br><span class="line"><span class="string">&#125;while(i&lt;=100)</span></span><br><span class="line"><span class="string">print total;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="233-在awk中使用正则表达式"><a class="markdownIt-Anchor" href="#233-在awk中使用正则表达式"></a> 2.3.3 在awk中使用正则表达式</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;123&quot;</span> |awk <span class="string">&#x27;&#123;if($0 ~ /^[0-9]+$/) print $0;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="24-cut"><a class="markdownIt-Anchor" href="#24-cut"></a> 2.4 cut</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>cut -b list [-n] [file ...]</code></li>
<li><code>cut -c list [file ...]</code></li>
<li><code>cut -f list [-s] [-d delim] [file ...]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>list</code>：范围
<ul>
<li><code>N</code>：从第1个开始数的第N个字节、字符或域</li>
<li><code>N-</code>：从第N个开始到所在行结束的所有字符、字节或域</li>
<li><code>N-M</code>：从第N个开始到第M个之间(包括第M个)的所有字符、字节或域</li>
<li><code>-M</code>：从第1个开始到第M个之间(包括第M个)的所有字符、字节或域</li>
</ul>
</li>
<li><code>-b</code>：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了<code>-n</code>标志</li>
<li><code>-c</code>：以字符为单位进行分割</li>
<li><code>-d</code>：自定义分隔符，默认为制表符</li>
<li><code>-f</code>：与<code>-d</code>一起使用，指定显示哪个区域</li>
<li><code>-n</code>：取消分割多字节字符。仅和<code>-b</code>标志一起使用。如果字符的最后一个字节落在由<code>-b</code>标志的<code>List</code>参数指示的范围之内，该字符将被写出；否则，该字符将被排除</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>echo &quot;a:b:c:d:e&quot; | cut -d &quot;:&quot; -f3</code>：输出c</li>
<li><code>ll | cut -c 1-10</code>：显示查询结果的 1-10个字符</li>
</ul>
<h2 id="25-grep"><a class="markdownIt-Anchor" href="#25-grep"></a> 2.5 grep</h2>
<p>grep分析一行信息，若当前有我们所需要的信息，就将该行拿出来</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>grep [-acinvrAB] [--color=auto] '查找的字符串' filename</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-a</code>：将binary文件以text文件的方式查找数据</li>
<li><code>-c</code>：计算找到’查找字符串’的次数</li>
<li><code>-i</code>：忽略大小写的不同</li>
<li><code>-e</code>：用正则表达式来进行匹配操作</li>
<li><code>-E</code>：用扩展的正则表达式来进行匹配操作</li>
<li><code>-l</code>：输出匹配的文件名，而不是匹配的内容</li>
<li><code>-n</code>：顺便输出行号</li>
<li><code>-v</code>：反向选择，即输出没有’查找字符串’内容的哪一行</li>
<li><code>-r</code>：在指定目录中递归查找</li>
<li><code>--color=auto</code>：将匹配的关键字部分加上颜色</li>
<li><code>--color=never</code>：不给匹配关键字部分加上颜色</li>
<li><code>-A</code>：后面可加数字，为after的意思，除了列出该行外，后面的n行也列出来</li>
<li><code>-B</code>：后面可加数字，为before的意思，除了列出该行外，前面的n行也列出来</li>
<li><code>-C</code>：后面可加数字，除了列出该行外，前后的n行也列出来</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>grep -r [--color=auto] '查找的字符串' [目录名]</code></li>
</ul>
<h2 id="26-sort"><a class="markdownIt-Anchor" href="#26-sort"></a> 2.6 sort</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>sort [-fbMnrtuk] [file or stdin]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-f</code>：忽略大小写的差异</li>
<li><code>-b</code>：忽略最前面的空格符部分</li>
<li><code>-M</code>：以月份的名字来排序，例如JAN，DEC等排序方法</li>
<li><code>-n</code>：使用&quot;纯数字&quot;进行排序(默认是以文字类型来排序的)</li>
<li><code>-r</code>：反向排序</li>
<li><code>-u</code>：就是uniq，相同的数据中，仅出现一行代表</li>
<li><code>-t</code>：分隔符，默认使用<code>Tab</code>来分隔</li>
<li><code>-k</code>：以哪个区间(field)来进行排序的意思</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>cat /etc/passwd | sort</code></li>
<li><code>cat /etc/passwd | sort -t ':' -k 3</code></li>
</ul>
<h2 id="27-uniq"><a class="markdownIt-Anchor" href="#27-uniq"></a> 2.7 uniq</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>sort [options] [file or stdin]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-c</code>：统计出现的次数</li>
<li><code>-d</code>：仅统计重复出现的内容</li>
<li><code>-i</code>：忽略大小写</li>
<li><code>-u</code>：仅统计只出现一次的内容</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>echo -e 'a\na\nb' | uniq -c</code></li>
<li><code>echo -e 'a\na\nb' | uniq -d</code></li>
<li><code>echo -e 'a\na\nb' | uniq -u</code></li>
</ul>
<h2 id="28-tr"><a class="markdownIt-Anchor" href="#28-tr"></a> 2.8 tr</h2>
<p><code>tr</code>指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>tr [-cdst] SET1 [SET2]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-c, --complement</code>：反选设定字符。也就是符合<code>SET1</code>的部份不做处理，不符合的剩余部份才进行转换</li>
<li><code>-d, --delete</code>：删除指令字符</li>
<li><code>-s, --squeeze-repeats</code>：缩减连续重复的字符成指定的单个字符</li>
<li><code>-t, --truncate-set1</code>：削减<code>SET1</code>指定范围，使之与<code>SET2</code>设定长度相等</li>
</ul>
<p><strong>字符集合的范围：</strong></p>
<ul>
<li><code>\NNN</code>：八进制值的字符 NNN (1 to 3 为八进制值的字符)</li>
<li><code>\\</code>：反斜杠</li>
<li><code>\a</code>：Ctrl-G 铃声</li>
<li><code>\b</code>：Ctrl-H 退格符</li>
<li><code>\f</code>：Ctrl-L 走行换页</li>
<li><code>\n</code>：Ctrl-J 新行</li>
<li><code>\r</code>：Ctrl-M 回车</li>
<li><code>\t</code>：Ctrl-I tab键</li>
<li><code>\v</code>：Ctrl-X 水平制表符</li>
<li><code>CHAR1-CHAR2</code>：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。</li>
<li><code>[CHAR*]</code>：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止</li>
<li><code>[CHAR*REPEAT]</code>：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)</li>
<li><code>[:alnum:]</code>：所有字母字符与数字</li>
<li><code>[:alpha:]</code>：所有字母字符</li>
<li><code>[:blank:]</code>：所有水平空格</li>
<li><code>[:cntrl:]</code>：所有控制字符</li>
<li><code>[:digit:]</code>：所有数字</li>
<li><code>[:graph:]</code>：所有可打印的字符(不包含空格符)</li>
<li><code>[:lower:]</code>：所有小写字母</li>
<li><code>[:print:]</code>：所有可打印的字符(包含空格符)</li>
<li><code>[:punct:]</code>：所有标点字符</li>
<li><code>[:space:]</code>：所有水平与垂直空格符</li>
<li><code>[:upper:]</code>：所有大写字母</li>
<li><code>[:xdigit:]</code>：所有 16 进位制的数字</li>
<li><code>[=CHAR=]</code>：所有符合指定的字符(等号里的<code>CHAR</code>，代表你可自订的字符)</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>echo &quot;abcdefg&quot; | tr &quot;[:lower:]&quot; &quot;[:upper:]&quot;</code>：将小写替换为大写</li>
<li><code>echo -e &quot;a\nb\nc&quot; | tr &quot;\n&quot; &quot; &quot;</code>：将<code>\n</code>替换成空格</li>
<li><code>echo &quot;hello 123 world 456&quot; | tr -d '0-9'</code>：删除<code>0-9</code></li>
<li><code>echo -e &quot;aa.,a 1 b#$bb 2 c*/cc 3 \nddd 4&quot; | tr -d -c '0-9 \n'</code>：删除除了<code>0-9</code>、空格、换行符之外的内容</li>
<li><code>echo &quot;thissss is a text linnnnnnne.&quot; | tr -s ' sn'</code>：删除多余的空格、<code>s</code>和<code>n</code></li>
<li><code>head /dev/urandom | tr -dc A-Za-z0-9 | head -c 20</code>：生成随机串</li>
</ul>
<h2 id="29-xargs"><a class="markdownIt-Anchor" href="#29-xargs"></a> 2.9 xargs</h2>
<p><strong>示例：</strong></p>
<ul>
<li><code>docker ps -aq | xargs docker rm -f</code></li>
<li><code>echo &quot; a b c &quot; | xargs</code>：实现<code>trim</code></li>
</ul>
<h2 id="210-tee"><a class="markdownIt-Anchor" href="#210-tee"></a> 2.10 tee</h2>
<p><code>&gt;</code>、<code>&gt;&gt;</code>等会将数据流传送给文件或设备，因此除非去读取该文件或设备，否则就无法继续利用这个数据流，如果我们想要将这个数据流的处理过程中将某段信息存下来，可以利用<code>tee</code></p>
<p><code>tee</code>会将数据流送与文件与屏幕(screen)，输出到屏幕的就是<code>stdout</code>可以让下个命令继续处理(<strong><code>&gt;</code>,<code>&gt;&gt;</code>会截断<code>stdout</code>，从而无法以<code>stdin</code>传递给下一个命令</strong>)</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>tee [-a] file</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-a</code>：以累加(append)的方式，将数据加入到file当中</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>command | tee &lt;文件名&gt; | command</code></li>
</ul>
<h2 id="211-cat"><a class="markdownIt-Anchor" href="#211-cat"></a> 2.11 cat</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>cat &gt; [newfile] &lt;&lt;'结束字符'</code></li>
</ul>
<p><strong>示例：注意<code>EOF</code>与<code>'EOF'</code>的区别</strong></p>
<ul>
<li><code>man bash</code>搜索<code>Here Documents</code>查看这两者的区别</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&quot;test&quot;</span></span><br><span class="line">cat &gt; /tmp/<span class="built_in">test</span> &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">hello $&#123;name&#125;!</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;↓↓↓↓↓↓↓↓↓content↓↓↓↓↓↓↓↓↓&quot;</span></span><br><span class="line">cat /tmp/<span class="built_in">test</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;↑↑↑↑↑↑↑↑↑content↑↑↑↑↑↑↑↑↑&quot;</span></span><br><span class="line"></span><br><span class="line">cat &gt; /tmp/<span class="built_in">test</span> &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">hello <span class="variable">$&#123;name&#125;</span>!</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;↓↓↓↓↓↓↓↓↓content↓↓↓↓↓↓↓↓↓&quot;</span></span><br><span class="line">cat /tmp/<span class="built_in">test</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;↑↑↑↑↑↑↑↑↑content↑↑↑↑↑↑↑↑↑&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="212-find"><a class="markdownIt-Anchor" href="#212-find"></a> 2.12 find</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>find [文件路径] [option] [action]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-name</code>：后接文件名，支持通配符。<strong>注意匹配的是相对路径</strong></li>
<li><code>-regex</code>：后接正则表达式，<strong>注意匹配的是完整路径</strong></li>
<li><code>-maxdepth</code>：后接查找深度</li>
<li><code>-regextype</code>：正则表达式类型
<ul>
<li><code>emacs</code>：默认类型</li>
<li><code>posix-awk</code></li>
<li><code>posix-basic</code></li>
<li><code>posix-egrep</code></li>
<li><code>posix-extended</code></li>
</ul>
</li>
<li><code>-type</code>：后接类型
<ul>
<li><code>f</code>：普通文件，默认的类型</li>
<li><code>d</code>：目录</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>find . -name &quot;*.c&quot;</code></li>
<li><code>find . -maxdepth 1 -name &quot;*.c&quot;</code></li>
<li><code>find . -regex &quot;.*/.*\.c&quot;</code></li>
<li>查找后缀为cfg以及后缀为conf的文件
<ul>
<li><code>find ./ -name '*.cfg' -o -name '*.conf'</code></li>
<li><code>find ./ -regex '.*\.cfg\|.*\.conf'</code></li>
<li><code>find ./ -regextype posix-extended -regex '.*\.(cfg|conf)'</code></li>
</ul>
</li>
</ul>
<h2 id="213-locate"><a class="markdownIt-Anchor" href="#213-locate"></a> 2.13 locate</h2>
<p><strong><code>locate</code>是在已创建的数据库<code>/var/lib/mlocate</code>里面的数据所查找到的，所以不用直接在硬盘当中去访问，因此，相比于<code>find</code>，速度更快</strong></p>
<p><strong>如何安装：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mlocate</span><br></pre></td></tr></table></figure>
<p><strong>如何使用：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一次使用时，需要先更新db</span></span><br><span class="line">updatedb</span><br><span class="line"></span><br><span class="line">locate stl_vector.h</span><br></pre></td></tr></table></figure>
<h2 id="214-cp"><a class="markdownIt-Anchor" href="#214-cp"></a> 2.14 cp</h2>
<p><strong>示例：</strong></p>
<ul>
<li><code>cp -vrf /a /b</code>：递归拷贝目录<code>/a</code>到目录<code>/b</code>中，包含目录<code>/a</code>中所有的文件、目录、隐藏文件和隐藏目录</li>
<li><code>cp -vrf /a/* /b</code>：递归拷贝目录<code>/a</code>下的所有文件、目录，但不包括隐藏文件和隐藏目录</li>
<li><code>cp -vrf /a/. /b</code>：递归拷贝目录<code>/a</code>中所有的文件、目录、隐藏文件和隐藏目录到目录<code>/b</code>中</li>
</ul>
<h2 id="215-rm"><a class="markdownIt-Anchor" href="#215-rm"></a> 2.15 rm</h2>
<p><strong>示例：</strong></p>
<ul>
<li><code>rm -rf /a/*</code>：递归删除目录<code>/a</code>下的所有文件、目录，但不包括隐藏文件和隐藏目录</li>
<li><code>rm -rf /path/&#123;..?*,.[!.]*,*&#125;</code>：递归删除目录<code>/path</code>下的所有文件、目录、隐藏文件和隐藏目录</li>
<li><code>rm -rf /path/!(a.txt|b.txt)</code>：递归删除目录<code>path</code>下的除了<code>a.txt</code>以及<code>b.txt</code>之外的所有文件、目录，但不包括隐藏文件和隐藏目录
<ul>
<li>需要通过命令<code>shopt -s extglob</code>开启<code>extglob</code></li>
</ul>
</li>
</ul>
<h2 id="216-tar"><a class="markdownIt-Anchor" href="#216-tar"></a> 2.16 tar</h2>
<p><strong>格式：</strong></p>
<ul>
<li>压缩：
<ul>
<li><code>tar -jcv -f [压缩创建的文件(*.tar.bz2)] [-C 切换工作目录] [被压缩的文件或目录1] [被压缩的文件或目录2]...</code></li>
<li><code>tar -zcv -f [压缩创建的文件(*.tar.gz)] [-C 切换工作目录] [被压缩的文件或目录1] [被压缩的文件或目录2]...</code></li>
</ul>
</li>
<li>查询：
<ul>
<li><code>tar -jtv -f [压缩文件(*.tar.bz2)]</code></li>
<li><code>tar -ztv -f [压缩文件(*.tar.gz)]</code></li>
</ul>
</li>
<li>解压缩：
<ul>
<li><code>tar -jxv -f [压缩文件(*.tar.bz2)] [-C 切换工作目录]</code></li>
<li><code>tar -zxv -f [压缩文件(*.tar.gz)] [-C 切换工作目录]</code></li>
</ul>
</li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-c</code>：新建打包文件，可以搭配-v查看过程中被打包的文件名</li>
<li><code>-t</code>：查看打包文件的内容含有那些文件名，终点在查看文件</li>
<li><code>-x</code>：解打包或解压缩的功能，可搭配-C在特定目录解开</li>
<li><strong>注意，c t x是互斥的</strong></li>
<li><code>-j</code>：通过bzip2的支持进行压缩/解压，此时文件名最好为*.tar.bz2</li>
<li><code>-z</code>：通过gzip的支持进行压缩/解压，此时文件名最好是*.tar.gz</li>
<li><code>-v</code>：在压缩/解压缩过程中，将正在处理的文件名显示出来</li>
<li><code>-f</code> filename：-f后面接要被处理的文件名，建议-f单独写一个参数</li>
<li><code>-C</code>：用户切换工作目录，之后的文件名可以使用相对路径</li>
<li><code>-p</code>：保留备份数据原本权限与属性，常用语备份(-c)重要的配置文件</li>
<li><code>-P</code>：保留绝对路径，即允许备份数据中含有根目录存在之意</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>tar -czvf /test.tar.gz -C /home/liuye</code></li>
<li><code>tar -zxvf /test.tar.gz -C /home/liuye</code></li>
<li><code>tar cvf - /home/liuye | sha1sum</code>：<code>-</code>表示标准输入输出，这里表示标准出</li>
</ul>
<h2 id="217-wget"><a class="markdownIt-Anchor" href="#217-wget"></a> 2.17 wget</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>wget [OPTION]... [URL]...</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-O</code>：后接下载文件的文件名</li>
<li><code>-r</code>：递归下载（用于下载文件夹）</li>
<li><code>-nH</code>：下载文件夹时，不创建host目录</li>
<li><code>-np</code>：不访问上层目录</li>
<li><code>-P</code>：指定下载的目录</li>
<li><code>-R</code>：指定排除的列表</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>wget -O myfile 'https://www.baidu.com'</code></li>
<li><code>wget -r -np -nH -P /root/test -R &quot;index.html*&quot; 'http://192.168.66.1/stuff'</code></li>
<li><code>wget -r -np -nH -P /root/test 'ftp://192.168.66.1/stuff'</code></li>
</ul>
<h2 id="218-tree"><a class="markdownIt-Anchor" href="#218-tree"></a> 2.18 tree</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>tree [option]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-N</code>：显示非ASCII字符，可以显示中文</li>
</ul>
<h2 id="219-split"><a class="markdownIt-Anchor" href="#219-split"></a> 2.19 split</h2>
<p><strong>示例：</strong></p>
<ul>
<li><code>split -b 2048M bigfile bigfile-slice-</code>：按大小切分文件，切分后的文件最大为<code>2048M</code>，文件的前缀是<code>bigfile-slice-</code></li>
<li><code>split -l 10000 bigfile bigfile-slice-</code>：按行切分文件，切分后的文件最大行数为<code>10000</code>，文件的前缀是<code>bigfile-slice-</code></li>
</ul>
<h2 id="220-base64"><a class="markdownIt-Anchor" href="#220-base64"></a> 2.20 base64</h2>
<p>用于对输入进行<code>base64</code>编码以及解码</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>echo &quot;hello&quot; | base64</code></li>
<li><code>echo &quot;hello&quot; | base64 | base64 -d</code></li>
</ul>
<h2 id="221-md5sum"><a class="markdownIt-Anchor" href="#221-md5sum"></a> 2.21 md5sum</h2>
<p>计算输入或文件的MD5值</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>echo &quot;hello&quot; | md5sum</code></li>
</ul>
<h2 id="222-openssl"><a class="markdownIt-Anchor" href="#222-openssl"></a> 2.22 openssl</h2>
<p>openssl可以对文件，以指定算法进行加密或者解密</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>openssl -h</code>：查看所有支持的加解密算法</li>
<li><code>openssl aes-256-cbc -a -salt -in blob.txt -out cipher</code></li>
<li><code>openssl aes-256-cbc -a -d -in cipher -out blob-rebuild.txt</code></li>
</ul>
<h2 id="223-bc"><a class="markdownIt-Anchor" href="#223-bc"></a> 2.23 bc</h2>
<p>bc可以用于进制转换</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>echo &quot;obase=8;255&quot; | bc</code>：十进制转8进制</li>
<li><code>echo &quot;obase=16;255&quot; | bc</code>：十进制转16进制</li>
<li><code>((num=8#77)); echo $&#123;num&#125;</code>：8进制转十进制</li>
<li><code>((num=16#FF)); echo $&#123;num&#125;</code>：16进制转十进制</li>
</ul>
<h2 id="224-dirname"><a class="markdownIt-Anchor" href="#224-dirname"></a> 2.24 dirname</h2>
<p><code>dirname</code>用于返回文件路径的目录部分，该命令不会检查路径所对应的目录或文件是否真实存在</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>dirname /var/log/messages</code>：返回的是<code>/var/log</code></li>
<li><code>dirname dirname aaa/bbb/ccc</code>：返回的是<code>aaa/bbb</code></li>
<li><code>dirname .././../.././././a</code>：返回的是<code>.././../../././.</code></li>
</ul>
<p>通常在脚本中用于获取脚本所在的目录，示例如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中$0代表脚本的路径（相对或绝对路径）</span></span><br><span class="line">ROOT=`dirname <span class="string">&quot;<span class="variable">$0</span>&quot;</span>`</span><br><span class="line">ROOT=`<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$ROOT</span>&quot;</span>; <span class="built_in">pwd</span>`</span><br></pre></td></tr></table></figure>
<h2 id="225-addr2line"><a class="markdownIt-Anchor" href="#225-addr2line"></a> 2.25 addr2line</h2>
<p>该工具用于查看二进制的偏移量与源码的对应关系</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>addr2line 4005f5 -e test</code>：查看二进制<code>test</code>中位置为<code>4005f5</code>指令对应的源码</li>
</ul>
<h2 id="226-objdump"><a class="markdownIt-Anchor" href="#226-objdump"></a> 2.26 objdump</h2>
<p>该工具用于反汇编</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>objdump -drwCS main.o</code></li>
<li><code>objdump -drwCS -M intel main.o</code></li>
</ul>
<h1 id="3-设备管理"><a class="markdownIt-Anchor" href="#3-设备管理"></a> 3 设备管理</h1>
<h2 id="31-mount"><a class="markdownIt-Anchor" href="#31-mount"></a> 3.1 mount</h2>
<p>mount用于挂载一个文件系统</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>mount [-t vfstype] [-o options] device dir</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-t</code>：后接文件系统类型，不指定类型的话会自适应</li>
<li><code>-o</code>：后接挂载选项</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>mount -o loop /CentOS-7-x86_64-Minimal-1908.iso /mnt/iso</code></li>
</ul>
<h3 id="311-传播级别"><a class="markdownIt-Anchor" href="#311-传播级别"></a> 3.1.1 传播级别</h3>
<p>内核引入<code>mount namespace</code>之初，各个<code>namespace</code>之间的隔离性较差，例如在某个<code>namespace</code>下做了<code>mount</code>或者<code>umount</code>动作，那么这一事件会被传播到其他的<code>namespace</code>中，在某些场景下，是不适用的</p>
<p>因此，在<code>2.6.15</code>版本之后，内核允许将一个挂载点标记为<code>shared</code>、<code>private</code>、<code>slave</code>、<code>unbindable</code>，以此来提供细粒度的隔离性控制</p>
<ul>
<li><code>shared</code>：默认的传播级别，<code>mount</code>、<code>unmount</code>事件会在不同<code>namespace</code>之间相互传播</li>
<li><code>private</code>：禁止<code>mount</code>、<code>unmount</code>事件在不同<code>namespace</code>之间相互传播</li>
<li><code>slave</code>：仅允许单向传播，即只允许<code>master</code>产生的事件传播到<code>slave</code>中</li>
<li><code>unbindable</code>：不允许<code>bind</code>操作，在这种传播级别下，无法创建新的<code>namespace</code></li>
</ul>
<h2 id="32-umount"><a class="markdownIt-Anchor" href="#32-umount"></a> 3.2 umount</h2>
<p>umount用于卸载一个文件系统</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>umount /home</code></li>
</ul>
<h2 id="33-findmnt"><a class="markdownIt-Anchor" href="#33-findmnt"></a> 3.3 findmnt</h2>
<p>findmnt用于查看挂载点的信息</p>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-o [option]</code>：指定要显示的列</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>findmnt -o TARGET,PROPAGATION</code></li>
</ul>
<h2 id="34-free"><a class="markdownIt-Anchor" href="#34-free"></a> 3.4 free</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>free [-b|-k|-m|-g|-h] [-t]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-b</code>：bytes</li>
<li><code>-m</code>：MB</li>
<li><code>-k</code>：KB</li>
<li><code>-g</code>：GB</li>
<li><code>-h</code>：单位自适应</li>
</ul>
<p><strong>显示参数介绍</strong>：</p>
<ul>
<li><code>Men</code>：物理内存</li>
<li><code>Swap</code>：虚拟内存</li>
<li><code>total</code>：内存总大小，该信息可以从<code>/proc/meminfo</code>中获取（<code>MemTotal</code>、<code>SwapTotal</code>）</li>
<li><code>user</code>：已使用的内存大小，计算方式为<code>total - free - buffers - cache</code></li>
<li><code>free</code>：未被使用的内存大小，该信息可以从<code>/proc/meminfo</code>中获取（<code>MemFree</code>、<code>SwapFree</code>）</li>
<li><code>shared</code>：被<code>tmpfs</code>使用的内存大小，该信息可以从<code>/proc/meminfo</code>中获取（<code>Shmem</code>）</li>
<li><code>buffers</code>：内核<code>buffer</code>使用的内存大小，该信息可以从<code>/proc/meminfo</code>中获取（<code>Buffers</code>）</li>
<li><code>cached</code>：<code>slabs</code>以及<code>page cache</code>使用的内存大小，该信息可以从<code>/proc/meminfo</code>（<code>Cached</code>）</li>
<li><code>available</code>：仍然可以分配给应用程序的内存大小（非<code>swap</code>内存），该信息可以从<code>/proc/meminfo</code>（<code>MemAvailable</code>）</li>
<li><strong>一般来说系统会很有效地将所有内存用光，目的是为了让系统的访问性能加速，这一点与Windows很不同，因此对于Linux系统来说，内存越大越好</strong></li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>free -m</code></li>
</ul>
<h2 id="35-swap"><a class="markdownIt-Anchor" href="#35-swap"></a> 3.5 swap</h2>
<p><strong>制作swap：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/tmp/swap bs=1M count=128</span><br><span class="line">mkswap /tmp/swap</span><br><span class="line">swapon /tmp/swap</span><br><span class="line">free</span><br></pre></td></tr></table></figure>
<h2 id="36-df"><a class="markdownIt-Anchor" href="#36-df"></a> 3.6 df</h2>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-h</code>：以<code>K</code>，<code>M</code>，<code>G</code>为单位，提高信息的可读性</li>
<li><code>-i</code>：显示inode信息</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>df -h</code></li>
<li><code>df -ih</code></li>
</ul>
<h2 id="37-du"><a class="markdownIt-Anchor" href="#37-du"></a> 3.7 du</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>du</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-h</code>：以<code>K</code>，<code>M</code>，<code>G</code>为单位，提高信息的可读性</li>
<li><code>-s</code>：仅显示总计</li>
<li><code>-d &lt;depth&gt;</code>：指定显示的文件/文件夹的深度</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>du -sh</code>：当前文件夹的总大小</li>
<li><code>du -h -d 1</code>：列出深度为1的所有文件/文件夹大小</li>
</ul>
<h2 id="38-lsblk"><a class="markdownIt-Anchor" href="#38-lsblk"></a> 3.8 lsblk</h2>
<p><code>lsblk</code>命令用于列出所有可用块设备的信息</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>lsblk [option]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-a, --all</code>：打印所有设备</li>
<li><code>-b, --bytes</code>：以字节为单位而非易读的格式来打印 SIZE</li>
<li><code>-d, --nodeps</code>：不打印从属设备(slave)或占位设备(holder)</li>
<li><code>-D, --discard</code>：打印时丢弃能力</li>
<li><code>-e, --exclude &lt;列表&gt;</code>：根据主设备号排除设备(默认：内存盘)</li>
<li><code>-I, --include &lt;列表&gt;</code>：只显示有指定主设备号的设备</li>
<li><code>-f, --fs</code>：输出文件系统信息</li>
<li><code>-h, --help</code>：使用信息(此信息)</li>
<li><code>-i, --ascii</code>：只使用 ascii 字符</li>
<li><code>-m, --perms</code>：输出权限信息</li>
<li><code>-l, --list</code>：使用列表格式的输出</li>
<li><code>-n, --noheadings</code>：不打印标题</li>
<li><code>-o, --output &lt;列表&gt;</code>：输出列</li>
<li><code>-p, --paths</code>：打印完整设备路径</li>
<li><code>-P, --pairs</code>：使用 key=“value” 输出格式</li>
<li><code>-r, --raw</code>：使用原生输出格式</li>
<li><code>-s, --inverse</code>：反向依赖</li>
<li><code>-t, --topology</code>：输出拓扑信息</li>
<li><code>-S, --scsi</code>：输出有关 SCSI 设备的信息</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>lsblk -fp</code></li>
<li><code>lsblk -o name,mountpoint,label,size,uuid</code></li>
</ul>
<h2 id="39-lsusb"><a class="markdownIt-Anchor" href="#39-lsusb"></a> 3.9 lsusb</h2>
<p><code>lsusb</code>命令用于列出所有usb接口的设备</p>
<h2 id="310-lspci"><a class="markdownIt-Anchor" href="#310-lspci"></a> 3.10 lspci</h2>
<p><code>lspci</code>命令用于列出所有pci接口的设备</p>
<h2 id="311-sync"><a class="markdownIt-Anchor" href="#311-sync"></a> 3.11 sync</h2>
<p><code>sync</code>指令会将存于<code>buffer</code>中的资料强制写入硬盘中</p>
<h1 id="4-进程管理"><a class="markdownIt-Anchor" href="#4-进程管理"></a> 4 进程管理</h1>
<p><strong>后台进程（&amp;）：</strong></p>
<p>在命令最后加上<code>&amp;</code>代表将命令丢到后台执行</p>
<ul>
<li>此时bash会给予这个命令一个工作号码(job number)，后接该命令触发的PID</li>
<li>不能被[Ctrl]+C中断</li>
<li>在后台中执行的命令，如果有stdout以及stderr时，它的数据依旧是输出到屏幕上面，所以我们会无法看到提示符，命令结束后，必须按下[Enter]才能看到命令提示符，同时也无法用[Ctrl]+C中断。解决方法就是利用数据流重定向</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>tar -zpcv -f /tmp/etc.tar.gz /etc &gt; /tmp/log.txt 2&gt;&amp;1 &amp;</code></li>
</ul>
<p><strong><code>Ctrl+C</code></strong>：终止当前进程</p>
<p><strong><code>Ctrl+Z</code></strong>：暂停当前进程</p>
<h2 id="41-jobs"><a class="markdownIt-Anchor" href="#41-jobs"></a> 4.1 jobs</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>jobs [option]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-l</code>：除了列出job number与命令串之外，同时列出PID号码</li>
<li><code>-r</code>：仅列出正在后台run的工作</li>
<li><code>-s</code>：仅列出正在后台中暂停(stop)的工作</li>
<li>输出信息中的’+‘与’-'号的意义：
<ul>
<li>+：最近被放到后台的工作号码，代表默认的取用工作，即仅输入’fg’时，被拿到前台的工作</li>
<li>-：代表最近后第二个被放置到后台的工作号码</li>
<li>超过最后第三个以后，就不会有’+‘与’-'号存在了</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>jobs -lr</code></li>
<li><code>jobs -ls</code></li>
</ul>
<h2 id="42-fg"><a class="markdownIt-Anchor" href="#42-fg"></a> 4.2 fg</h2>
<p>将后台工作拿到前台来处理</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>fg %jobnumber</code>：取出编号为<code>jobnumber</code>的工作。jubnumber为工作号码(数字)，%是可有可无的</li>
<li><code>fg +</code>：取出标记为+的工作</li>
<li><code>fg -</code>：取出标记为-的工作`</li>
</ul>
<h2 id="43-bg"><a class="markdownIt-Anchor" href="#43-bg"></a> 4.3 bg</h2>
<p>让工作在后台下的状态变为运行中</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>bg %jobnumber</code>：取出编号为<code>jobnumber</code>的工作。jubnumber为工作号码(数字)，%是可有可无的</li>
<li><code>bg +</code>：取出标记为+的工作</li>
<li><code>bg -</code>：取出标记为-的工作</li>
<li>不能让类似vim的工作变为运行中，即便使用该命令会，该工作又立即变为暂停状态</li>
</ul>
<h2 id="44-kill"><a class="markdownIt-Anchor" href="#44-kill"></a> 4.4 kill</h2>
<p>管理后台当中的工作</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>kill [-signal] PID</code></li>
<li><code>kill [-signal] %jobnumber</code></li>
<li><code>kill -l</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-l</code>：列出目前kill能够使用的signal有哪些</li>
<li><code>-signal</code>：
<ul>
<li><code>-1</code>：重新读取一次参数的配置文件，类似reload</li>
<li><code>-2</code>：代表与由键盘输入[Ctrl]+C同样的操作</li>
<li><code>-9</code>：立刻强制删除一个工作，通常在强制删除一个不正常的工作时使用</li>
<li><code>-15</code>：以正常的程序方式终止一项工作，与-9是不同的，-15以正常步骤结束一项工作，这是默认值</li>
</ul>
</li>
<li>与bg、fg不同，若要管理工作，kill中的%不可省略，因为kill默认接PID</li>
</ul>
<h2 id="45-pkill"><a class="markdownIt-Anchor" href="#45-pkill"></a> 4.5 pkill</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>pkill [-signal] PID</code></li>
<li><code>pkill [-signal] [-Ptu] [arg]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-f</code>：匹配完整的<code>command line</code>，默认情况下只能匹配15个字符</li>
<li><code>-signal</code>：同<code>kill</code></li>
<li><code>-P ppid,...</code>：匹配指定<code>parent id</code></li>
<li><code>-s sid,...</code>：匹配指定<code>session id</code></li>
<li><code>-t term,...</code>：匹配指定<code>terminal</code></li>
<li><code>-u euid,...</code>：匹配指定<code>effective user id</code></li>
<li><code>-U uid,...</code>：匹配指定<code>real user id</code></li>
<li><strong>不指定匹配规则时，默认匹配进程名字</strong></li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>pkill -9 -t pts/0</code></li>
<li><code>pkill -9 -u user1</code></li>
</ul>
<h2 id="46-ps"><a class="markdownIt-Anchor" href="#46-ps"></a> 4.6 ps</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>ps aux</code>：查看系统所有进程数据</li>
<li><code>ps -lA</code>：查看所有系统的数据</li>
<li><code>ps axjf</code>：连同部分进程数状态</li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-A</code>：所有的进程均显示出来</li>
<li><code>-a</code>：不与terminal有关的所有进程</li>
<li><code>-u</code>：有效用户相关进程</li>
<li><code>x</code>：通常与a这个参数一起使用，可列出较完整的信息</li>
<li><code>l</code>：较长、较详细地将该PID的信息列出</li>
<li><code>j</code>：工作的格式(job format)</li>
<li><code>-f</code>：做一个更为完整的输出</li>
<li><code>ps -l</code>：查阅自己的bash中的程序</li>
<li><code>ps aux</code>：查阅系统所有运行的程序</li>
<li><code>ps aux -Z</code>：-Z参数可以让我们查阅进程的安全上下文</li>
</ul>
<p><strong><code>ps -l</code>打印参数说明：</strong></p>
<ul>
<li><code>F</code>：代表这个进程标志(process flags)
<ul>
<li>若为4：表示此进程的权限为root</li>
<li>若为1：表示此子进程尽可进行复制，而无法实际执行</li>
</ul>
</li>
<li><code>S</code>：代表这个进程的状态(STAT)
<ul>
<li>R(Running)：该进程正在运行中</li>
<li>S(Sleep)：该进程目前正在睡眠状态(idle)，但可以被唤醒(signal)</li>
<li>D：不可被唤醒的睡眠状态，通常这个进程可能在等待I/O的情况</li>
<li>T：停止状态(stop)</li>
<li>Z(Zombie)：僵尸状态，进程已经终止但无法被删除至内存外</li>
</ul>
</li>
<li><code>UIP/PID/PPID</code>：用户标识号/进程PID号码/父进程的PID号码</li>
<li><code>C</code>：CPU使用率，单位为百分比</li>
<li><code>PRI/NI</code>：Prority/Nice的缩写，代表此进程被CPU所执行的优先级，数值越小代表越快被CPU执行</li>
<li><code>ADDR/SZ/WCHAN</code>：都与内存有关
<ul>
<li>ADDR是kernel function，指出该进程在内存的哪个部分，如果是个running的进程，一般就会显示&quot;-&quot;</li>
<li>SZ表示此进程用掉多少内存</li>
<li>WCHAN表示目前进程是否运行中，’-'表示正在运行中，'wait’表示等待中</li>
</ul>
</li>
<li><code>TTY</code>：登陆者的终端机位置，若为远程登录则使用动态终端机接口(pts/n)</li>
<li><code>TIME</code>：使用掉的CPU时间，是此进程实际花费CPU运行的时间</li>
<li><code>CMD</code>：造成此程序的出发进程的命令为何</li>
</ul>
<p><strong><code>ps aux</code>打印参数说明：</strong></p>
<ul>
<li><code>USER</code>：该进程所属的用户名</li>
<li><code>PID</code>：该进程的PID</li>
<li><code>%CPU</code>：该进程使用掉的CPU资源百分比</li>
<li><code>%MEN</code>：该进程占用的物理内存百分比</li>
<li><code>VSZ</code>：该进程使用掉的虚拟内存量</li>
<li><code>RSS</code>：该进程占用的固定内存量</li>
<li><code>TTY</code>：该进程是所属终端机，tty1~tty6是本地，pts/0是网络连接主机的进程(GNOME上的bash)</li>
<li><code>STAT</code>：该进程目前的状态，状态显示与ps -l的S标志相同</li>
<li><code>START</code>：该进程被触发的启动时间</li>
<li><code>TIME</code>：该进程实际使用CPU的时间</li>
<li><code>COMMAND</code>：该进程的实际命令</li>
<li>一般来说ps aux会按照PID的顺序来排序显示</li>
</ul>
<h2 id="47-pgrep"><a class="markdownIt-Anchor" href="#47-pgrep"></a> 4.7 pgrep</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>pgrep [-lon] &lt;pattern&gt;</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-f</code>：匹配完整的<code>command line</code>，默认情况下只能匹配15个字符</li>
<li><code>-l</code>：列出pid以及进程名</li>
<li><code>-o</code>：列出oldest的进程</li>
<li><code>-n</code>：列出newest的进程</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>pgrep sshd</code></li>
<li><code>pgrep -l sshd</code></li>
<li><code>pgrep -lo sshd</code></li>
<li><code>pgrep -ln sshd</code></li>
<li><code>pgrep -l ssh*</code></li>
</ul>
<h2 id="48-pstree"><a class="markdownIt-Anchor" href="#48-pstree"></a> 4.8 pstree</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>pstree [-A|U] [-up]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-A</code>：各进程树之间的连接以ASCII字符来连接(连接符号是ASCII字符)</li>
<li><code>-U</code>：各进程树之间的连接以utf8码的字符来连接，在某些终端接口下可能会有错误(连接符号是utf8字符，比较圆滑好看)</li>
<li><code>-p</code>：同时列出每个进程的PID</li>
<li><code>-u</code>：同时列出每个进程所属账号名称</li>
</ul>
<h2 id="49-pstack"><a class="markdownIt-Anchor" href="#49-pstack"></a> 4.9 pstack</h2>
<p>查看指定进程的堆栈</p>
<p><strong>示例：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstack 12345</span><br></pre></td></tr></table></figure>
<h2 id="410-taskset"><a class="markdownIt-Anchor" href="#410-taskset"></a> 4.10 taskset</h2>
<p>查看或者设置进程的cpu亲和性</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>taskset [options] -p pid</code></li>
<li><code>taskset [options] -p [mask|list] pid</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-c</code>：以列表格式显示cpu亲和性</li>
<li><code>-p</code>：指定进程的pid</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>taskset -p 152694</code>：查看pid为<code>152694</code>的进程的cpu亲和性，显示方式为掩码</li>
<li><code>taskset -c -p 152694</code>：查看pid为<code>152694</code>的进程的cpu亲和性，显示方式为列表</li>
<li><code>taskset -p f 152694</code>：设置pid为<code>152694</code>的进程的cpu亲和性，设置方式为掩码</li>
<li><code>taskset -c -p 0,1,2,3,4,5 152694</code>：设置pid为<code>152694</code>的进程的cpu亲和性，设置方式为列表</li>
</ul>
<p><strong>什么是cpu亲和性掩码（16进制）</strong></p>
<ul>
<li><code>cpu0 = 1</code></li>
<li><code>cpu1 = cpu0 * 2 = 2</code></li>
<li><code>cpu2 = cpu1 * 2 = 4</code></li>
<li><code>cpu(n) = cpu(n-1) * 2</code></li>
<li><code>mask = cpu0 + cpu1 + ... + cpu(n)</code></li>
<li>举几个例子
<ul>
<li><code>0 ==&gt; 1 = 0x1</code></li>
<li><code>0,1,2,3 ==&gt; 1 + 2 + 4 + 8 = 15 = 0xf</code></li>
<li><code>0,1,2,3,4,5 ==&gt; 1 + 2 + 4 + 8 + 16 + 32 = 0x3f</code></li>
<li><code>2,3 ==&gt; 4 + 8 = 12 = 0xc</code></li>
</ul>
</li>
</ul>
<h2 id="411-su"><a class="markdownIt-Anchor" href="#411-su"></a> 4.11 su</h2>
<p>su命令用于切换用户</p>
<ul>
<li><code>su</code>：以<code>non-login-shell</code>的方式，切换到root用户</li>
<li><code>su -</code>：以<code>login-shell</code>的方式（更换目录，环境变量等等），切换到root用户</li>
<li><code>su test</code>：以<code>non-loign-shell</code>的方式，切换到test用户</li>
</ul>
<h2 id="412-sudo"><a class="markdownIt-Anchor" href="#412-sudo"></a> 4.12 sudo</h2>
<p><strong>注意，sudo本身是一个进程。比如用<code>sudo tail -f xxx</code>，在另一个会话中<code>ps aux | grep tail</code>会发现两个进程</strong></p>
<p><strong>配置文件：</strong></p>
<ul>
<li><code>/etc/sudoers</code></li>
</ul>
<h2 id="413-pkexec"><a class="markdownIt-Anchor" href="#413-pkexec"></a> 4.13 pkexec</h2>
<p>允许授权用户以其他身份执行程序</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>pkexec [command]</code></li>
</ul>
<h2 id="414-nohup"><a class="markdownIt-Anchor" href="#414-nohup"></a> 4.14 nohup</h2>
<p><strong><code>nohup</code>会忽略所有挂断（SIGHUP）信号</strong>。比如通过<code>ssh</code>登录到远程服务器上，然后启动一个程序，当<code>ssh</code>登出时，这个程序就会随即终止。如果用<code>nohup</code>方式启动，那么当<code>ssh</code>登出时，这个程序仍然会继续运行</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>nohup command [args] [&amp;]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>command</code>：要执行的命令</li>
<li><code>args</code>：命令所需的参数</li>
<li><code>&amp;</code>：在后台执行</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>nohup java -jar xxx.jar &amp;</code></li>
</ul>
<h2 id="415-screen"><a class="markdownIt-Anchor" href="#415-screen"></a> 4.15 screen</h2>
<p><strong>如果想在关闭<code>ssh</code>连接后继续运行启动的程序，可以使用<code>nohup</code>。如果要求下次<code>ssh</code>登录时，还能查看到上一次<code>ssh</code>登录时运行的程序的状态，那么就需要使用<code>screen</code></strong></p>
<p><strong>格式：</strong></p>
<ul>
<li><code>screen</code></li>
<li><code>screen cmd [ args ]</code></li>
<li><code>screen [–ls] [-r pid]</code></li>
<li><code>screen -X -S &lt;pid&gt; kill</code></li>
<li><code>screen -d -m cmd [ args ]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>cmd</code>：执行的命令</li>
<li><code>args</code>：执行的命令所需要的参数</li>
<li><code>-ls</code>：列出所有<code>screen</code>会话的详情</li>
<li><code>-r</code>：后接<code>pid</code>，进入指定进程号的<code>screen</code>会话</li>
<li><code>-d</code>：退出当前运行的session</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>screen</code></li>
<li><code>screen -ls</code></li>
<li><code>screen -r 123</code></li>
</ul>
<p><strong>会话管理：</strong></p>
<ol>
<li><code>Ctrl a + w</code>：显示所有窗口列表</li>
<li><code>Ctrl a + Ctrl a</code>：切换到之前显示的窗口</li>
<li><code>Ctrl a + c</code>：创建一个新的运行shell的窗口并切换到该窗口</li>
<li><code>Ctrl a + n</code>：切换到下一个窗口</li>
<li><code>Ctrl a + p</code>：切换到前一个窗口(与<code>Ctrl a + n</code>相对)</li>
<li><code>Ctrl a + 0-9</code>：切换到窗口0…9</li>
<li><code>Ctrl a + d</code>：暂时断开screen会话</li>
<li><code>Ctrl a + k</code>：杀掉当前窗口</li>
</ol>
<h1 id="5-网络管理"><a class="markdownIt-Anchor" href="#5-网络管理"></a> 5 网络管理</h1>
<h2 id="51-netstat"><a class="markdownIt-Anchor" href="#51-netstat"></a> 5.1 netstat</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>netstat -[rn]</code></li>
<li><code>netstat -[antulpc]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ol>
<li><strong>与路由有关的参数</strong>
<ul>
<li><code>-r</code>：列出路由表(route table)，功能如同route</li>
<li><code>-n</code>：不使用主机名与服务名称，使用IP与port number，如同route -n</li>
</ul>
</li>
<li><strong>与网络接口有关的参数</strong>
<ul>
<li><code>-a</code>：列出所有的连接状态，包括tcp/udp/unix socket等</li>
<li><code>-t</code>：仅列出TCP数据包的连接</li>
<li><code>-u</code>：仅列出UDP数据包的连接</li>
<li><code>-l</code>：仅列出已在Listen(监听)的服务的网络状态</li>
<li><code>-p</code>：列出PID与Program的文件名</li>
<li><code>-c</code>：可以设置几秒种后自动更新一次，例如-c 5为每5s更新一次网络状态的显示</li>
</ul>
</li>
</ol>
<p><strong>与路由有关的显示参数说明</strong></p>
<ul>
<li><code>Destination</code>：Network的意思</li>
<li><code>Gateway</code>：该接口的Gateway的IP，若为0.0.0.0，表示不需要额外的IP</li>
<li><code>Genmask</code>：就是Netmask，与Destination组合成为一台主机或网络</li>
<li><code>Flags</code>：共有多个标志来表示该网络或主机代表的意义
<ul>
<li><code>U</code>：代表该路由可用</li>
<li><code>G</code>：代表该网络需要经由Gateway来帮忙传递</li>
<li><code>H</code>：代表该行路由为一台主机，而非一整个网络</li>
<li><code>D</code>：代表该路由是由重定向报文创建的</li>
<li><code>M</code>：代表该路由已被重定向报文修改</li>
<li><code>Iface</code>：就是Interface(接口)的意思</li>
</ul>
</li>
</ul>
<p><strong>与网络接口有关的显示参数说明：</strong></p>
<ul>
<li><code>Proto</code>：该连接的数据包协议，主要为TCP/UDP等数据包</li>
<li><code>Recv-Q</code>：非用户程序连接所复制而来的总byte数</li>
<li><code>Send-Q</code>：由远程主机发送而来，但不具有ACK标志的总byte数，亦指主动连接SYN或其他标志的数据包所占的byte数</li>
<li><code>Local Address</code>：本地端的地址，可以使IP，也可以是完整的主机名，使用的格式是&quot;IP:port&quot;</li>
<li><code>Foreign Address</code>：远程主机IP与port number</li>
<li><code>stat</code>：状态栏
<ul>
<li><code>ESTABLISED</code>：已建立连接的状态</li>
<li><code>SYN_SENT</code>：发出主动连接(SYN标志)的连接数据包</li>
<li><code>SYN_RECV</code>：接收到一个要求连接的主动连接数据包</li>
<li><code>FIN_WAIT1</code>：该套接字服务已中断，该连接正在断线当中</li>
<li><code>FIN_WAIT2</code>：该连接已挂断，但正在等待对方主机响应断线确认的数据包中</li>
<li><code>TIME_WAIT</code>：该连接已挂断，但socket还在网络上等待结束</li>
<li><code>LISTEN</code>：通常在服务的监听port，可以使用-l参数查阅</li>
</ul>
</li>
</ul>
<p>netstat的功能就是查看网络的连接状态，而网络连接状态中，又以<strong>我目前开了多少port在等待客户端的连接</strong>以及<strong>目前我的网络连接状态中，有多少连接已建立或产生问题</strong>最常见</p>
<p><strong>示例：</strong></p>
<ol>
<li><strong><code>netstat -n | awk '/^tcp/ &#123;++y[$NF]&#125; END &#123;for(w in y) print w, y[w]&#125;'</code></strong></li>
</ol>
<h2 id="52-tc"><a class="markdownIt-Anchor" href="#52-tc"></a> 5.2 tc</h2>
<p>流量的处理由三种对象控制，它们是：<code>qdisc</code>（排队规则）、<code>class</code>（类别）和<code>filter</code>（过滤器）。</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>tc qdisc [ add | change | replace | link ] dev DEV [ parent qdisc-id | root ] [ handle qdisc-id ] qdisc [ qdisc specific parameters ]</code></li>
<li><code>tc class [ add | change | replace ] dev DEV parent qdisc-id [ classid class-id ] qdisc [ qdisc specific parameters ]</code></li>
<li><code>tc filter [ add | change | replace ] dev DEV [ parent qdisc-id | root ] protocol protocol prio priority filtertype [ filtertype specific parameters ] flowid flow-id</code></li>
<li><code>tc [-s | -d ] qdisc show [ dev DEV ]</code></li>
<li><code>tc [-s | -d ] class show dev DEV</code></li>
<li><code>tc filter show dev DEV</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<p><strong>示例：</strong></p>
<ul>
<li><code>tc qdisc add dev em1 root netem delay 300ms</code>：设置网络延迟300ms</li>
<li><code>tc qdisc add dev em1 root netem loss 8% 20%</code>：设置8%~20%的丢包率</li>
<li><code>tc qdisc del dev em1 root</code>：删除指定设置</li>
</ul>
<h2 id="53-lsof"><a class="markdownIt-Anchor" href="#53-lsof"></a> 5.3 lsof</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>lsof [-aU] [-u 用户名] [+d] [-i address]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-a</code>：多项数据需要“同时成立”才显示结果</li>
<li><code>-U</code>：仅列出Unix like系统的socket文件类型</li>
<li><code>-u</code>：后面接username，列出该用户相关进程所打开的文件</li>
<li><code>+d</code>：后面接目录，及找出某个目录下面已经被打开的文件</li>
<li><code>-i</code>：后面接网络地址，格式如下
<ul>
<li><code>[46][protocol][@hostname|hostaddr][:service|port]</code></li>
<li><code>46</code>：ipv4/ipv6</li>
<li><code>protocol</code>：tcp/udp</li>
<li><code>hostname</code>：主机名</li>
<li><code>hostaddr</code>：主机ip</li>
<li><code>service</code>：服务</li>
<li><code>port</code>端口号</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>lsof -n|awk '&#123;print $2&#125;' | sort | uniq -c | sort -nr -k 1</code>：查看进程打开的文件句柄的数量</li>
<li><code>lsof -i 6tcp@localhost:22</code></li>
<li><code>lsof -i 4tcp@127.0.0.1:22</code></li>
<li><code>lsof -i tcp@127.0.0.1:22</code></li>
<li><code>lsof -i tcp@localhost</code></li>
<li><code>lsof -i tcp:22</code></li>
<li><code>lsof -i :22</code></li>
</ul>
<p><strong>最佳实践：</strong></p>
<ol>
<li>如何查询指定tcp连接的建立时间：
<ul>
<li><code>lsof -i :&lt;端口号&gt;</code>：首先通过连接的端口号查询出socket信息，包括进程的pid以及fd</li>
<li><code>ll /proc/&lt;pid&gt;/fd/&lt;fd&gt;</code>：查看socket文件的创建时间，这个就是tcp连接的建立时间</li>
</ul>
</li>
</ol>
<h2 id="54-ss"><a class="markdownIt-Anchor" href="#54-ss"></a> 5.4 ss</h2>
<p><code>ss</code>是<code>Socket Statistics</code>的缩写。顾名思义，<code>ss</code>命令可以用来获取<code>socket</code>统计信息，它可以显示和<code>netstat</code>类似的内容。<code>ss</code>的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比<code>netstat</code>更快速更高效。</p>
<p>当服务器的socket连接数量变得非常大时，无论是使用<code>netstat</code>命令还是直接<code>cat /proc/net/tcp</code>，执行速度都会很慢。</p>
<p><code>ss</code>快的秘诀在于，它利用到了TCP协议栈中<code>tcp_diag</code>。<code>tcp_diag</code>是一个用于分析统计的模块，可以获得Linux内核中第一手的信息，这就确保了<code>ss</code>的快捷高效</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>ss [-talspnr]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-t</code>：列出tcp-socket</li>
<li><code>-u</code>：列出udp-socket</li>
<li><code>-a</code>：列出所有socket</li>
<li><code>-l</code>：列出所有监听的socket</li>
<li><code>-s</code>：仅显示摘要信息</li>
<li><code>-p</code>：显示用了该socket的进程</li>
<li><code>-n</code>：不解析服务名称</li>
<li><code>-r</code>：解析服务名称</li>
<li><code>-m</code>：显示内存占用情况</li>
<li><code>-h</code>：查看帮助文档</li>
<li><code>-i</code>：显示tcp-socket详情</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>ss -t -a</code>：显示所有tcp-socket</li>
<li><code>ss -ti -a</code>：显示所有tcp-socket以及详情</li>
<li><code>ss -u –a</code>：显示所有udp-socket</li>
<li><code>ss -lp | grep 22</code>：找出打开套接字/端口应用程序</li>
<li><code>ss -o state established</code>：显示所有状态为established的socket</li>
<li><code>ss -o state FIN-WAIT-1 dst 192.168.25.100/24</code>：显示出处于<code>FIN-WAIT-1</code>状态的，目标网络为<code>192.168.25.100/24</code>所有socket</li>
<li><code>ss -nap</code></li>
<li><code>ss -naptu</code></li>
</ul>
<h2 id="55-ip"><a class="markdownIt-Anchor" href="#55-ip"></a> 5.5 ip</h2>
<h3 id="551-ip-address"><a class="markdownIt-Anchor" href="#551-ip-address"></a> 5.5.1 ip address</h3>
<p>具体用法参考<code>ip address help</code></p>
<h3 id="552-ip-link"><a class="markdownIt-Anchor" href="#552-ip-link"></a> 5.5.2 ip link</h3>
<p>具体用法参考<code>ip link help</code></p>
<p><strong>示例：</strong></p>
<ul>
<li><code>ip link</code>：查看所有网卡</li>
<li><code>ip link up</code>：查看up状态的网卡</li>
<li><code>ip -d link</code>：查看详细的信息</li>
<li><code>ip link set eth0 up</code>：开启网卡</li>
<li><code>ip link set eth0 down</code>：关闭网卡</li>
<li><code>cat /sys/class/net/xxx/carrier</code>：查看网卡是否插了网线（对应于<code>ip link</code>的<code>state UP</code>或<code>state DOWN</code></li>
</ul>
<h3 id="553-ip-route"><a class="markdownIt-Anchor" href="#553-ip-route"></a> 5.5.3 ip route</h3>
<p>具体用法参考<code>ip route help</code></p>
<h4 id="5531-route-table"><a class="markdownIt-Anchor" href="#5531-route-table"></a> 5.5.3.1 route table</h4>
<p><strong>linux最多可以支持255张路由表，每张路由表有一个<code>table id</code>和<code>table name</code>。其中有4张表是linux系统内置的</strong></p>
<ul>
<li><strong><code>table id = 0</code>：系统保留</strong></li>
<li><strong><code>table id = 255</code>：本地路由表，表名为<code>local</code></strong>。像本地接口地址，广播地址，以及NAT地址都放在这个表。该路由表由系统自动维护，管理员不能直接修改
<ul>
<li><code>ip r show table local</code></li>
</ul>
</li>
<li><strong><code>table id = 254</code>：主路由表，表名为<code>main</code></strong>。如果没有指明路由所属的表，所有的路由都默认都放在这个表里。一般来说，旧的路由工具（如<code>route</code>）所添加的路由都会加到这个表。<code>main</code>表中路由记录都是普通的路由记录。而且，使用<code>ip route</code>配置路由时，如果不明确指定要操作的路由表，默认情况下也是对主路由表进行操作
<ul>
<li><code>ip r show table main</code></li>
</ul>
</li>
<li><strong><code>table id = 253</code>：称为默认路由表，表名为<code>default</code></strong>。一般来说默认的路由都放在这张表
<ul>
<li><code>ip r show table default</code></li>
</ul>
</li>
</ul>
<p><strong>此外：</strong></p>
<ul>
<li>系统管理员可以根据需要自己添加路由表，并向路由表中添加路由记录</li>
<li>可以通过<code>/etc/iproute2/rt_tables</code>文件查看<code>table id</code>和<code>table name</code>的映射关系。</li>
<li>如果管理员新增了一张路由表，需要在<code>/etc/iproute2/rt_tables</code>文件中为新路由表添加<code>table id</code>和<code>table name</code>的映射</li>
<li>路由表存储于内存中，通过<code>procfs</code>文件系统对用户态露出，具体的文件位置是<code>/proc/net/route</code></li>
</ul>
<h4 id="5532-route-type"><a class="markdownIt-Anchor" href="#5532-route-type"></a> 5.5.3.2 route type</h4>
<p><strong><code>unicast</code></strong>：单播路由是路由表中最常见的路由。这是到目标网络地址的典型路由，它描述了到目标的路径。即使是复杂的路由（如下一跳路由）也被视为单播路由。如果在命令行上未指定路由类型，则假定该路由为单播路由</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip route add unicast 192.168.0.0/24 via 192.168.100.5</span><br><span class="line">ip route add default via 193.7.255.1</span><br><span class="line">ip route add unicast default via 206.59.29.193</span><br><span class="line">ip route add 10.40.0.0/16 via 10.72.75.254</span><br></pre></td></tr></table></figure>
<p><strong><code>broadcast</code></strong>：此路由类型用于支持广播地址概念的链路层设备（例如以太网卡）。此路由类型仅在本地路由表中使用，通常由内核处理</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip route add table <span class="built_in">local</span> broadcast 10.10.20.255 dev eth0 proto kernel scope link src 10.10.20.67</span><br><span class="line">ip route add table <span class="built_in">local</span> broadcast 192.168.43.31 dev eth4 proto kernel scope link src 192.168.43.14</span><br></pre></td></tr></table></figure>
<p><strong><code>local</code></strong>：当IP地址添加到接口时，内核会将条目添加到本地路由表中。这意味着IP是本地托管的IP</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip route add table <span class="built_in">local</span> <span class="built_in">local</span> 10.10.20.64 dev eth0 proto kernel scope host src 10.10.20.67</span><br><span class="line">ip route add table <span class="built_in">local</span> <span class="built_in">local</span> 192.168.43.12 dev eth4 proto kernel scope host src 192.168.43.14</span><br></pre></td></tr></table></figure>
<p><strong><code>nat</code></strong>：当用户尝试配置无状态NAT时，内核会将此路由条目添加到本地路由表中</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip route add nat 193.7.255.184 via 172.16.82.184</span><br><span class="line">ip route add nat 10.40.0.0/16 via 172.40.0.0</span><br></pre></td></tr></table></figure>
<p><strong><code>unreachable</code></strong>：当对路由决策的请求返回的路由类型不可达的目的地时，将生成ICMP unreachable并返回到源地址</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip route add unreachable 172.16.82.184</span><br><span class="line">ip route add unreachable 192.168.14.0/26</span><br><span class="line">ip route add unreachable 209.10.26.51</span><br></pre></td></tr></table></figure>
<p><strong><code>prohibit</code></strong>：当路由选择请求返回具有禁止路由类型的目的地时，内核会生成禁止返回源地址的ICMP</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip route add prohibit 10.21.82.157</span><br><span class="line">ip route add prohibit 172.28.113.0/28</span><br><span class="line">ip route add prohibit 209.10.26.51</span><br></pre></td></tr></table></figure>
<p><strong><code>blackhole</code></strong>：匹配路由类型为黑洞的路由的报文将被丢弃。没有发送ICMP，也没有转发数据包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip route add blackhole default</span><br><span class="line">ip route add blackhole 202.143.170.0/24</span><br><span class="line">ip route add blackhole 64.65.64.0/18</span><br></pre></td></tr></table></figure>
<p><strong><code>throw</code></strong>：引发路由类型是一种便捷的路由类型，它会导致路由表中的路由查找失败，从而将路由选择过程返回到RPDB。当有其他路由表时，这很有用。请注意，如果路由表中没有默认路由，则存在隐式抛出，因此尽管合法，但是示例中第一个命令创建的路由是多余的</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip route add throw default</span><br><span class="line">ip route add throw 10.79.0.0/16</span><br><span class="line">ip route add throw 172.16.0.0/12</span><br></pre></td></tr></table></figure>
<h4 id="5533-route-scope"><a class="markdownIt-Anchor" href="#5533-route-scope"></a> 5.5.3.3 route scope</h4>
<p><strong><code>global</code></strong>：全局有效</p>
<p><strong><code>site</code></strong>：仅在当前站点有效（IPV6）</p>
<p><strong><code>link</code></strong>：仅在当前设备有效</p>
<p><strong><code>host</code></strong>：仅在当前主机有效</p>
<h4 id="5534-route-proto"><a class="markdownIt-Anchor" href="#5534-route-proto"></a> 5.5.3.4 route proto</h4>
<p><strong><code>proto</code>：表示路由的添加时机。可由数字或字符串表示，数字与字符串的对应关系详见<code>/etc/iproute2/rt_protos</code></strong></p>
<ol>
<li><strong><code>redirect</code></strong>：表示该路由是因为发生<code>ICMP</code>重定向而添加的</li>
<li><strong><code>kernel</code></strong>：该路由是内核在安装期间安装的自动配置</li>
<li><strong><code>boot</code></strong>：该路由是在启动过程中安装的。如果路由守护程序启动，它将会清除这些路由规则</li>
<li><strong><code>static</code></strong>：该路由由管理员安装，以覆盖动态路由</li>
</ol>
<h4 id="5535-route-src"><a class="markdownIt-Anchor" href="#5535-route-src"></a> 5.5.3.5 route src</h4>
<p>这被视为对内核的提示（用于回答：如果我要将数据包发往host X，我该用本机的哪个IP作为Source IP），该提示是关于要为该接口上的<code>传出</code>数据包上的源地址选择哪个IP地址</p>
<h4 id="5536-参数解释"><a class="markdownIt-Anchor" href="#5536-参数解释"></a> 5.5.3.6 参数解释</h4>
<p><strong><code>ip r show table local</code>参数解释（示例如下）</strong></p>
<ol>
<li>第一个字段指明该路由是用于<code>广播地址</code>、<code>IP地址</code>还是<code>IP范围</code>，例如
<ul>
<li><code>local 192.168.99.35</code>表示<code>IP地址</code></li>
<li><code>broadcast 127.255.255.255</code>表示<code>广播地址</code></li>
<li><code>local 127.0.0.0/8 dev</code>表示<code>IP范围</code></li>
</ul>
</li>
<li>第二个字段指明该路由通过哪个设备到达目标地址，例如
<ul>
<li><code>dev eth0 proto kernel</code></li>
<li><code>dev lo proto kernel</code></li>
</ul>
</li>
<li>第三个字段指明该路由的作用范围，例如
<ul>
<li><code>scope host</code></li>
<li><code>scope link</code></li>
</ul>
</li>
<li>第四个字段指明传出数据包的源IP地址
<ul>
<li><code>src 127.0.0.1</code></li>
</ul>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@tristan]$ ip route show table <span class="built_in">local</span></span><br><span class="line"><span class="built_in">local</span> 192.168.99.35 dev eth0  proto kernel  scope host  src 192.168.99.35 </span><br><span class="line">broadcast 127.255.255.255 dev lo  proto kernel  scope link  src 127.0.0.1 </span><br><span class="line">broadcast 192.168.99.255 dev eth0  proto kernel  scope link  src 192.168.99.35 </span><br><span class="line">broadcast 127.0.0.0 dev lo  proto kernel  scope link  src 127.0.0.1 </span><br><span class="line"><span class="built_in">local</span> 127.0.0.1 dev lo  proto kernel  scope host  src 127.0.0.1 </span><br><span class="line"><span class="built_in">local</span> 127.0.0.0/8 dev lo  proto kernel  scope host  src 127.0.0.1</span><br></pre></td></tr></table></figure>
<h3 id="554-ip-rule"><a class="markdownIt-Anchor" href="#554-ip-rule"></a> 5.5.4 ip rule</h3>
<p>基于策略的路由比传统路由在功能上更强大，使用更灵活，它使网络管理员不仅能够根据目的地址而且能够根据报文大小、应用或IP源地址等属性来选择转发路径。简单地来说，linux系统有多张路由表，而路由策略会根据一些条件，将路由请求转向不同的路由表。例如源地址在某些范围走路由表A，另外的数据包走路由表，类似这样的规则是有路由策略rule来控制</p>
<p>在linux系统中，一条路由策略<code>rule</code>主要包含三个信息，即<code>rule</code>的优先级，条件，路由表。其中rule的优先级数字越小表示优先级越高，然后是满足什么条件下由指定的路由表来进行路由。<strong>在linux系统启动时，内核会为路由策略数据库配置三条缺省的规则，即<code>rule 0</code>，<code>rule 32766</code>，<code>rule 32767</code>（数字是rule的优先级），具体含义如下</strong>：</p>
<ol>
<li><strong><code>rule 0</code></strong>：匹配任何条件的数据包，查询路由表<code>local（table id = 255）</code>。<code>rule 0</code>非常特殊，不能被删除或者覆盖。</li>
<li><strong><code>rule 32766</code></strong>：匹配任何条件的数据包，查询路由表<code>main（table id = 254）</code>。系统管理员可以删除或者使用另外的策略覆盖这条策略</li>
<li><strong><code>rule 32767</code></strong>：匹配任何条件的数据包，查询路由表<code>default（table id = 253）</code>。对于前面的缺省策略没有匹配到的数据包，系统使用这个策略进行处理。这个规则也可以删除</li>
</ol>
<ul>
<li>在linux系统中是按照rule的优先级顺序依次匹配。假设系统中只有优先级为<code>0</code>，<code>32766</code>及<code>32767</code>这三条规则。那么系统首先会根据规则<code>0</code>在本地路由表里寻找路由，如果目的地址是本网络，或是广播地址的话，在这里就可以找到匹配的路由；如果没有找到路由，就会匹配下一个不空的规则，在这里只有<code>32766</code>规则，那么将会在主路由表里寻找路由；如果没有找到匹配的路由，就会依据<code>32767</code>规则，即寻找默认路由表；如果失败，路由将失败</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加一条规则，规则匹配的对象是所有的数据包，动作是选用路由表1的路由，这条规则的优先级是32800</span></span><br><span class="line">$ ip rule add [from 0/0] table 1 pref 32800</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一条规则，规则匹配的对象是IP为192.168.3.112, tos等于0x10的包，使用路由表2，这条规则的优先级是1500，动作是丢弃。</span></span><br><span class="line">$ ip rule add from 192.168.3.112/32 [tos 0x10] table 2 pref 1500 prohibit</span><br></pre></td></tr></table></figure>
<h3 id="555-ip-netns"><a class="markdownIt-Anchor" href="#555-ip-netns"></a> 5.5.5 ip netns</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Usage: ip netns list</span><br><span class="line">       ip netns add NAME</span><br><span class="line">       ip netns <span class="built_in">set</span> NAME NETNSID</span><br><span class="line">       ip [-all] netns delete [NAME]</span><br><span class="line">       ip netns identify [PID]</span><br><span class="line">       ip netns pids NAME</span><br><span class="line">       ip [-all] netns <span class="built_in">exec</span> [NAME] cmd ...</span><br><span class="line">       ip netns monitor</span><br><span class="line">       ip netns list-id</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<ul>
<li><code>ip netns list</code>：列出网络命名空间（只会从<code>/var/run/netns</code>下读取）</li>
<li><code>ip netns exec test-ns ifconfig</code>：在网络命名空间<code>test-ns</code>中执行<code>ifconfig</code></li>
</ul>
<p><strong>与nsenter的区别</strong>：由于<code>ip netns</code>只从<code>/var/run/netns</code>下读取网络命名空间，而<code>nsenter</code>默认会读取<code>/proc/$&#123;pid&#125;/ns/net</code>。但是<code>docker</code>会隐藏容器的网络命名空间，即默认不会在<code>/var/run/netns</code>目录下创建命名空间，因此如果要使用<code>ip netns</code>进入到容器的命名空间，还需要做个软连接</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid=$(docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> <span class="variable">$&#123;container_id&#125;</span>)</span><br><span class="line">mkdir -p /var/run/netns/</span><br><span class="line">ln -sfT /proc/<span class="variable">$pid</span>/ns/net /var/run/netns/<span class="variable">$container_id</span></span><br></pre></td></tr></table></figure>
<h2 id="56-iptables"><a class="markdownIt-Anchor" href="#56-iptables"></a> 5.6 iptables</h2>
<h3 id="561-规则的查看"><a class="markdownIt-Anchor" href="#561-规则的查看"></a> 5.6.1 规则的查看</h3>
<p><strong>格式：</strong></p>
<ul>
<li><code>iptables [-S] [-t tables] [-L] [-nv]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-S</code>：输出指定table的规则，若没有指定table，则输出所有的规则，类似<code>iptables-save</code></li>
<li><code>-t</code>：后面接table，例如nat或filter，若省略此项目，则使用默认的filter</li>
<li><code>-L</code>：列出目前的table的规则</li>
<li><code>-n</code>：不进行IP与HOSTNAME的反查，显示信息的速度回快很多</li>
<li><code>-v</code>：列出更多的信息，包括通过该规则的数据包总数，相关的网络接</li>
</ul>
<p><strong>输出信息介绍：</strong></p>
<ul>
<li>每一个Chain就是每个链，Chain所在的括号里面的是默认的策略(即没有规则匹配时采取的操作(target))</li>
<li><code>target</code>：代表进行的操作
<ul>
<li><strong><code>ACCEPT</code></strong>：表示放行</li>
<li><strong><code>DROP</code></strong>：表示丢弃</li>
<li><strong><code>QUEUE</code></strong>：将数据包传递到用户空间</li>
<li><strong><code>RETURN</code></strong>：表示停止遍历当前链，并在上一个链中的下一个规则处恢复（假设在<code>Chain A</code>中调用了<code>Chain B</code>，<code>Chain B RETURN</code>后，继续<code>Chain A</code>的下一个规则）</li>
<li><strong>还可以是一个自定义的Chain</strong></li>
</ul>
</li>
<li><code>port</code>：代表使用的数据包协议，主要有TCP、UDP、ICMP3中数据包</li>
<li><code>opt</code>：额外的选项说明</li>
<li><code>source</code>：代表此规则是针对哪个来源IP进行限制</li>
<li><code>destination</code>：代表此规则是针对哪个目标IP进行限制</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>iptables -nL</code></li>
<li><code>iptables -t nat -nL</code></li>
</ul>
<p>由于<code>iptables</code>的上述命令的查看只是做格式化的查阅，要详细解释每个规则可能会与原规则有出入，因此，建议使用<code>iptables-save</code>这个命令来查看防火墙规则</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>iptables-save [-t table]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-t</code>：可以针对某些表格来输出，例如仅针对NAT或Filter等</li>
</ul>
<p><strong>输出信息介绍：</strong></p>
<ul>
<li>星号开头的指的是表格，这里为Filter</li>
<li>冒号开头的指的是链，3条内建的链，后面跟策略</li>
<li>链后面跟的是<code>[Packets:Bytes]</code>，分别表示通过该链的数据包/字节的数量</li>
</ul>
<h3 id="562-规则的清除"><a class="markdownIt-Anchor" href="#562-规则的清除"></a> 5.6.2 规则的清除</h3>
<p><strong>格式：</strong></p>
<ul>
<li><code>iptables [-t tables] [-FXZ] [chain]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-F [chain]</code>：清除指定chain或者所有chian中的所有的已制定的规则</li>
<li><code>-X [chain]</code>：清除指定<code>user-defined chain</code>或所有<code>user-defined chain</code></li>
<li><code>-Z [chain]</code>：将指定chain或所有的chain的计数与流量统计都归零</li>
</ul>
<h3 id="563-定义默认策略"><a class="markdownIt-Anchor" href="#563-定义默认策略"></a> 5.6.3 定义默认策略</h3>
<p>当数据包不在我们设置的规则之内时，该数据包的通过与否都以Policy的设置为准</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>iptables [-t nat] -P [INPUT,OUTPUT,FORWARD] [ACCEPT,DROP]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-P</code>：定义策略(Policy)
<ul>
<li><code>ACCEPT</code>：该数据包可接受</li>
<li><code>DROP</code>：该数据包直接丢弃，不会让Client知道为何被丢弃</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>iptables -P INPUT DROP</code></li>
<li><code>iptables -P OUTPUT ACCEPT</code></li>
<li><code>iptables -P FORWARD ACCEPT</code></li>
</ul>
<h3 id="564-数据包的基础对比ip-网络及接口设备"><a class="markdownIt-Anchor" href="#564-数据包的基础对比ip-网络及接口设备"></a> 5.6.4 数据包的基础对比：IP、网络及接口设备</h3>
<p><strong>格式：</strong></p>
<ul>
<li><code>iptables [-t tables] [-AI chain] [-io ifname] [-p prop] [-s ip/net] [-d ip/net] -j [ACCEPT|DROP|REJECT|LOG]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-t tables</code>：指定tables，默认的tables是<code>filter</code></li>
<li><code>-AI chain</code>：针对某条链进行规则的&quot;插入&quot;或&quot;累加&quot;
<ul>
<li><code>-A chain</code>：新增加一条规则，该规则增加在原规则后面，例如原来有4条规则，使用-A就可以加上第五条规则</li>
<li><code>-I chain [rule num]</code>：插入一条规则，可以指定插入的位置。如果没有指定此规则的顺序，默认插入变成第一条规则</li>
<li><code>链</code>：可以是内建链（<code>INPUT</code>、<code>OUTPUT</code>、<code>FORWARD</code>、<code>PREROUTING</code>、<code>POSTROUTING</code>）；也可以是自定义链</li>
</ul>
</li>
<li><code>-io ifname</code>：设置数据包进出的接口规范
<ul>
<li><code>-i</code>：数据包所进入的那个网络接口，例如eth0，lo等，需要与INPUT链配合</li>
<li><code>-o</code>：数据包所传出的网络接口，需要与OUTPUT配合</li>
</ul>
</li>
<li><code>-p prop</code>：设置此规则适用于哪种数据包格式
<ul>
<li>主要的数据包格式有：tcp、udp、icmp以及all</li>
</ul>
</li>
<li><code>-s ip/net</code>：设置此规则之数据包的来源地，可指定单纯的IP或网络
<ul>
<li><code>ip</code>：例如<code>192.168.0.100</code></li>
<li><code>net</code>：例如<code>192.168.0.0/24</code>、<code>192.168.0.0/255.255.255.0</code>均可</li>
<li><strong>若规范为&quot;不许&quot;时，加上<code>!</code>即可，例如<code>! -s 192.168.100.0/24</code></strong></li>
</ul>
</li>
<li><code>-d ip/net</code>：同-s，只不过这里是目标的</li>
<li><code>-j target</code>：后面接<code>target</code>
<ul>
<li><code>ACCEPT</code></li>
<li><code>DROP</code></li>
<li><code>QUEUE</code></li>
<li><code>RETURN</code></li>
<li><strong>其他Chain</strong></li>
<li><strong>规则的匹配过程类似于函数栈，从一个链跳到另一个链相当于函数调用。某些target会停止匹配过程，比如常见的<code>ACCEPT</code>、<code>DROP</code>、<code>SNAT</code>、<code>MASQUERADE</code>等等；某些target不会停止匹配过程，比如当target是另一个<code>Chain</code>时，或者常见的<code>LOG</code>、<code>ULOG</code>、<code>TOS</code>等</strong></li>
</ul>
</li>
<li><strong>重要的原则：没有指定的项目，就表示该项目完全接受</strong>
<ul>
<li>例如<code>-s</code>和<code>-d</code>不指定，就表示来源或去向的任意IP/网络都接受</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>iptables -A INPUT -i lo -j ACCEPT</code>：不论数据包来自何处或去向哪里，只要是lo这个接口，就予以接受，这就是所谓的信任设备</li>
<li><code>iptables -A INPUT -i eth1 -j ACCEPT</code>：添加接口为eth1的网卡为信任设备</li>
<li><code>iptables -A INPUT -s 192.168.2.200 -j LOG</code>：该网段的数据包，其相关信息就会被写入到内核日志文件中，即<code>/var/log/messages</code>，然后，该数据包会继续进行后续的规则比对(这一点与其他规则不同)</li>
<li>配置打印日志的规则（这些规则要放在第一条，否则命中其他规则时，当前规则就不执行了）
<ul>
<li><code>iptables -I INPUT -p icmp -j LOG --log-prefix &quot;liuye-input: &quot;</code></li>
<li><code>iptables -I FORWARD -p icmp -j LOG --log-prefix &quot;liuye-forward: &quot;</code></li>
<li><code>iptables -I OUTPUT -p icmp -j LOG --log-prefix &quot;liuye-output: &quot;</code></li>
<li><code>iptables -t nat -I PREROUTING -p icmp -j LOG --log-prefix &quot;liuye-prerouting: &quot;</code></li>
<li><code>iptables -t nat -I POSTROUTING -p icmp -j LOG --log-prefix &quot;liuye-postrouting: &quot;</code></li>
</ul>
</li>
</ul>
<h3 id="565-tcp-udp的规则针对端口设置"><a class="markdownIt-Anchor" href="#565-tcp-udp的规则针对端口设置"></a> 5.6.5 TCP、UDP的规则：针对端口设置</h3>
<p>TCP与UDP比较特殊的就是端口(port)，在TCP方面则另外有所谓的连接数据包状态，包括最常见的SYN主动连接的数据包格式</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>iptables [-AI 链] [-io 网络接口] [-p tcp|udp] [-s 来源IP/网络] [--sport 端口范围] [-d 目标IP/网络] [--dport 端口范围] --syn -j [ACCEPT|DROP|REJECT]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>--sport 端口范围</code>：限制来源的端口号码，端口号码可以是连续的，例如1024:65535</li>
<li><code>--dport 端口范围</code>：限制目标的端口号码</li>
<li><code>--syn</code>：主动连接的意思</li>
<li><strong>与之前的命令相比，就是多了<code>--sport</code>以及<code>--dport</code>这两个选项，因此想要使用<code>--dport</code>或<code>--sport</code>必须加上<code>-p tcp</code>或<code>-p udp</code>才行</strong></li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>iptables -A INPUT -i eth0 -p tcp --dport 21 -j DROP</code>：想要进入本机port 21的数据包都阻挡掉</li>
<li><code>iptables -A INPUT -i eth0 -p tcp --sport 1:1023 --dport 1:1023 --syn -j DROP</code>：来自任何来源port 1:1023的主动连接到本机端的1:1023连接丢弃</li>
</ul>
<h3 id="566-iptables匹配扩展"><a class="markdownIt-Anchor" href="#566-iptables匹配扩展"></a> 5.6.6 iptables匹配扩展</h3>
<p><code>iptables</code>可以使用扩展的数据包匹配模块。当指定<code>-p</code>或<code>--protocol</code>时，或者使用<code>-m</code>或<code>--match</code>选项，后跟匹配的模块名称；之后，取决于特定的模块，可以使用各种其他命令行选项。可以在一行中指定多个扩展匹配模块，并且可以在指定模块后使用<code>-h</code>或<code>--help</code>选项来接收特定于该模块的帮助文档（<code>iptables -m comment -h</code>，输出信息的最下方有<code>comment</code>模块的参数说明）</p>
<p><strong>常用模块</strong>，详细内容请参考<a target="_blank" rel="noopener" href="https://linux.die.net/man/8/iptables">Match Extensions</a></p>
<ol>
<li><code>comment</code>：增加注释</li>
<li><code>conntrack</code>：与连接跟踪结合使用时，此模块允许访问比“状态”匹配更多的连接跟踪信息。（仅当iptables在支持该功能的内核下编译时，此模块才存在）</li>
<li><code>tcp</code></li>
<li><code>udp</code></li>
</ol>
<h3 id="567-iptables目标扩展"><a class="markdownIt-Anchor" href="#567-iptables目标扩展"></a> 5.6.7 iptables目标扩展</h3>
<p>iptables可以使用扩展目标模块，并且可以在指定目标后使用<code>-h</code>或<code>--help</code>选项来接收特定于该目标的帮助文档（<code>iptables -j DNAT -h</code>）</p>
<p><strong>常用（可以通过<code>man iptables</code>或<code>man 8 iptables-extensions</code>，并搜索关键词<code>target</code>）：</strong></p>
<ol>
<li><code>ACCEPT</code></li>
<li><code>DROP</code></li>
<li><code>RETURN</code></li>
<li><code>REJECT</code></li>
<li><code>DNAT</code></li>
<li><code>SNAT</code></li>
<li><code>MASQUERADE</code>：用于实现自动化SNAT，若出口ip经常变化的话，可以通过该目标来实现SNAT</li>
</ol>
<h3 id="568-icmp数据包规则的比对针对是否响应ping来设计"><a class="markdownIt-Anchor" href="#568-icmp数据包规则的比对针对是否响应ping来设计"></a> 5.6.8 ICMP数据包规则的比对：针对是否响应ping来设计</h3>
<p><strong>格式：</strong></p>
<ul>
<li><code>iptables -A INPUT [-p icmp] [--icmp-type 类型] -j ACCEPT</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>--icmp-type</code>：后面必须要接ICMP的数据包类型，也可以使用代号</li>
</ul>
<h2 id="57-bridge"><a class="markdownIt-Anchor" href="#57-bridge"></a> 5.7 bridge</h2>
<h3 id="571-bridge-link"><a class="markdownIt-Anchor" href="#571-bridge-link"></a> 5.7.1 bridge link</h3>
<p>Bridge port</p>
<p><strong>示例：</strong></p>
<ol>
<li><code>bridge link show</code></li>
</ol>
<h3 id="572-bridge-fdb"><a class="markdownIt-Anchor" href="#572-bridge-fdb"></a> 5.7.2 bridge fdb</h3>
<p>Forwarding Database entry</p>
<p><strong>示例：</strong></p>
<ol>
<li><code>bridge fdb show</code></li>
</ol>
<h3 id="573-bridge-mdb"><a class="markdownIt-Anchor" href="#573-bridge-mdb"></a> 5.7.3 bridge mdb</h3>
<p>Multicast group database entry</p>
<h3 id="574-bridge-vlan"><a class="markdownIt-Anchor" href="#574-bridge-vlan"></a> 5.7.4 bridge vlan</h3>
<p>VLAN filter list</p>
<h3 id="575-bridge-monitor"><a class="markdownIt-Anchor" href="#575-bridge-monitor"></a> 5.7.5 bridge monitor</h3>
<h2 id="58-route"><a class="markdownIt-Anchor" href="#58-route"></a> 5.8 route</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>route [-nee]</code></li>
<li><code>route add [-net|-host] [网络或主机] netmask [mask] [gw|dev]</code></li>
<li><code>route del [-net|-host] [网络或主机] netmask [mask] [gw|dev]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-n</code>：不要使用通信协议或主机名，直接使用IP或port number，即在默认情况下，route会解析出该IP的主机名，若解析不到则会有延迟，因此一般加上这个参数</li>
<li><code>-ee</code>：显示更详细的信息</li>
<li><code>-net</code>：表示后面接的路由为一个网络</li>
<li><code>-host</code>：表示后面接的为连接到单个主机的路由</li>
<li><code>netmask</code>：与网络有关，可设置netmask决定网络的大小</li>
<li><code>gw</code>：gateway的缩写，后接IP数值</li>
<li><code>dev</code>：如果只是要制定由哪块网卡连接出去，则使用这个设置，后接网卡名，例如eth0等</li>
</ul>
<p><strong>打印参数说明：</strong></p>
<ul>
<li><strong>Destination、Genmask</strong>：这两个参数就分别是network与netmask</li>
<li><strong>Gateway</strong>：该网络通过哪个Gateway连接出去，若显示<code>0.0.0.0(default)</code>表示该路由直接由本级传送，也就是通过局域网的MAC直接传送，如果显示IP的话，表示该路由需要经过路由器(网关)的帮忙才能发送出去</li>
<li><strong>Flags</strong>：
<ul>
<li><code>U(route is up)</code>：该路由是启动的</li>
<li><code>H(target is a host)</code>：目标是一台主机而非网络</li>
<li><code>G(use gateway)</code>：需要通过外部的主机来传递数据包</li>
<li><code>R(reinstate route for dynamic routing)</code>：使用动态路由时，恢复路由信息的标志</li>
<li><code>D(Dynamically installed by daemon or redirect)</code>：动态路由</li>
<li><code>M(modified from routing daemon or redirect)</code>：路由已经被修改了</li>
<li><code>!(reject route)</code>：这个路由将不会被接受</li>
</ul>
</li>
<li><strong>Iface</strong>：该路由传递数据包的接口</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>route -n</code></li>
<li><code>route add -net 169.254.0.0 netmask 255.255.0.0 dev enp0s8</code></li>
<li><code>route del -net 169.254.0.0 netmask 255.255.0.0 dev enp0s8</code></li>
</ul>
<h2 id="59-nsenter"><a class="markdownIt-Anchor" href="#59-nsenter"></a> 5.9 nsenter</h2>
<p>nsenter用于在某个网络命名空间下执行某个命令。例如某些docker容器是没有curl命令的，但是又想在docker容器的环境下执行，这个时候就可以在宿主机上使用nsenter</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>nsenter -t &lt;pid&gt; -n &lt;cmd&gt;</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-t</code>：后接进程id</li>
<li><code>-n</code>：后接需要执行的命令</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>nsenter -t 123 -n curl baidu.com</code></li>
</ul>
<h2 id="510-tcpdump"><a class="markdownIt-Anchor" href="#510-tcpdump"></a> 5.10 tcpdump</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>tcpdump [-AennqX] [-i 接口] [port 端口号] [-w 存储文件名] [-c 次数] [-r 文件] [所要摘取数据包的格式]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-A</code>：数据包的内容以ASCII显示，通常用来抓取WWW的网页数据包数据</li>
<li><code>-e</code>：使用数据链路层(OSI第二层)的MAC数据包数据来显示</li>
<li><code>-n</code>：直接以IP以及port number显示，而非主机名与服务名称</li>
<li><code>-q</code>：仅列出较为简短的数据包信息，每一行的内容比较精简</li>
<li><code>-X</code>：可以列出十六进制(hex)以及ASCII的数据包内容，对于监听数据包很有用</li>
<li><code>-i</code>：后面接要监听的网络接口，例如eth0等</li>
<li><code>port</code>：后接要监听的端口号，例如22等</li>
<li><code>-w</code>：将监听得到的数据包存储下来</li>
<li><code>-r</code>：从后面接的文件将数据包数据读出来</li>
<li><code>-c</code>：监听数据包数，没有这个参数则会一直监听，直到[ctrl]+C</li>
<li><code>-vv/-vvv</code>：输出更多的信息，配合<code>-w</code>使用时，会显示目前监听的多少数据包</li>
<li>此外，还可以用<code>and</code>拼接多个条件</li>
</ul>
<p><strong>显示格式说明：</strong></p>
<ul>
<li><code>src &gt; dst: flags data-seqno ack window urgent options</code></li>
<li><code>src</code>: 源ip/port（或域名）</li>
<li><code>dst</code>: 宿ip/port（或域名）</li>
<li><code>flags</code>: TCP标志位的组合
<ul>
<li><code>S</code>: <code>SYNC</code></li>
<li><code>F</code>: <code>FIN</code></li>
<li><code>P</code>: <code>PUSH</code></li>
<li><code>R</code>: <code>RST</code></li>
<li><code>U</code>: <code>URG</code></li>
<li><code>W</code>: <code>ECN CWR</code></li>
<li><code>E</code>: <code>ECN-Echo</code></li>
<li><code>.</code>: <code>ACK</code></li>
<li><code>none</code>: 无任何标志位</li>
</ul>
</li>
<li><code>data-seqno</code>: 数据包的序号，可能是一个或多个（<code>1:4</code>）</li>
<li><code>ack</code>: 表示期望收到的下一个数据包的序号</li>
<li><code>window</code>: 接收缓存的大小</li>
<li><code>urgent</code>: 表示当前数据包是否包含紧急数据</li>
<li><code>option</code>: 用<code>&lt;&gt;</code>包围的部分</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>tcpdump -i lo0 port 22 -w output7.cap</code></li>
<li><code>tcpdump -i eth0 host www.baidu.com</code></li>
<li><code>tcpdump -i any -w output1.cap</code></li>
<li><code>tcpdump -n -i any -e icmp and host www.baidu.com</code></li>
</ul>
<h3 id="5101-tcpdump条件表达式"><a class="markdownIt-Anchor" href="#5101-tcpdump条件表达式"></a> 5.10.1 tcpdump条件表达式</h3>
<p>该表达式用于决定哪些数据包将被打印。如果不给定条件表达式，网络上所有被捕获的包都会被打印，否则，只有满足条件表达式的数据包被打印</p>
<p>表达式由一个或多个<code>表达元</code>组成（表达元, 可理解为组成表达式的基本元素）。一个表达元通常由一个或多个修饰符<code>qualifiers</code>后跟一个名字或数字表示的<code>id</code>组成（即：<code>qualifiers id</code>）。有三种不同类型的修饰符：<code>type</code>，<code>direction</code>以及<code>protocol</code></p>
<p><strong>表达元格式：<code>[protocol] [direction] [type] id</code></strong></p>
<ul>
<li><strong>type</strong>：包括<code>host</code>、<code>net</code>、<code>port</code>、<code>portrange</code>。默认值为<code>host</code></li>
<li><strong>direction</strong>：包括<code>src</code>、<code>dst</code>、<code>src and dst</code>、<code>src or dst</code>4种可能的方向。默认值为<code>src or dst</code></li>
<li><strong>protocol</strong>：包括<code>ether</code>、<code>fddi</code>、<code>tr</code>、<code>wlan</code>、<code>ip</code>、<code>ip6</code>、<code>arp</code>、<code>rarp</code>、<code>decnet</code>、<code>tcp</code>、<code>upd</code>等等。默认包含所有协议
<ul>
<li><strong>其中<code>protocol</code>要与<code>type</code>相匹配，比如当<code>protocol</code>是<code>tcp</code>时，那么<code>type</code>就不能是<code>host</code>或<code>net</code>，而应该是<code>port</code>或<code>portrange</code></strong></li>
</ul>
</li>
<li><strong>逻辑运算</strong>：<code>条件表达式</code>可由多个<code>表达元</code>通过<code>逻辑运算</code>组合而成。逻辑运算包括（<code>!</code>或<code>not</code>）、（<code>&amp;&amp;</code>或<code>and</code>）、（<code>||</code>或<code>or</code>）三种逻辑运算</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>tcp src port 123</code></li>
<li><code>tcp src portrange 100-200</code></li>
<li><code>host www.baidu.com and port 443</code></li>
</ul>
<h3 id="5102-tips"><a class="markdownIt-Anchor" href="#5102-tips"></a> 5.10.2 tips</h3>
<p>如何查看具体的协议，例如ssh协议</p>
<p>利用wireshark</p>
<ol>
<li>任意选中一个<code>length</code>不为<code>0</code>的数据包，右键选择解码（<code>decode as</code>），右边<code>Current</code>一栏，选择对应的协议即可</li>
</ol>
<h3 id="5103-如何使用tcpdump抓dockerd的http协议的数据"><a class="markdownIt-Anchor" href="#5103-如何使用tcpdump抓dockerd的http协议的数据"></a> 5.10.3 如何使用tcpdump抓dockerd的http协议的数据</h3>
<p>dockerd使用的是域套接字，对应的套接字文件是<code>/var/run/docker.sock</code>，而域套接字是不经过网卡设备的，因此tcpdump无法直接抓取相应的数据</p>
<p><strong>方式1：改变client的访问方式</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在终端1执行，监听本机的18080，然后将流量转到docker的域套接字</span></span><br><span class="line"><span class="comment"># 两个-d参数会输出fatel、error以及notice级别的信息</span></span><br><span class="line">socat -d -d TCP-LISTEN:18080,fork,<span class="built_in">bind</span>=127.0.0.1 UNIX:/var/run/docker.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端2执行tcpdump进行抓包</span></span><br><span class="line">tcpdump -i lo -netvv port 18080 -w file1.cap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端3执行docker命令</span></span><br><span class="line">docker -H tcp://localhost:18080 images</span><br></pre></td></tr></table></figure>
<p><strong>方式2：不改变client的访问方式</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在终端1执行，mv命令修改原始域套接字的文件名，这个操作不会改变文件的fd，因此，在移动后，dockerd监听的套接字是/var/run/docker.sock.original</span></span><br><span class="line">sudo mv /var/run/docker.sock /var/run/docker.sock.original</span><br><span class="line">sudo socat TCP-LISTEN:18081,reuseaddr,fork UNIX-CONNECT:/var/run/docker.sock.original</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端2执行</span></span><br><span class="line">sudo socat UNIX-LISTEN:/var/run/docker.sock,fork TCP-CONNECT:127.0.0.1:18081</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端3执行tcpdump进行抓包</span></span><br><span class="line">tcpdump -i lo -vv port 18081 -w file2.cap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端3执行docker命令</span></span><br><span class="line">docker -H tcp://localhost:18081 images</span><br></pre></td></tr></table></figure>
<h2 id="511-tcpkill"><a class="markdownIt-Anchor" href="#511-tcpkill"></a> 5.11 tcpkill</h2>
<p><code>tcpkill</code>用于杀死tcp连接，语法与<code>tcpdump</code>基本类似。其工作原理非常简单，首先会监听相关的数据报文，获取了<code>sequence number</code>之后，然后发起<code>Reset</code>报文。因此，当且仅当连接有报文交互的时候，<code>tcpkill</code>才能起作用</p>
<p><strong>如何安装：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y dsniff</span><br></pre></td></tr></table></figure>
<p><strong>格式：</strong></p>
<ul>
<li><code>tcpkill [-i interface] [-1...9] expression</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-i</code>：指定网卡</li>
<li><code>-1...9</code>：优先级，优先级越高越容易杀死</li>
<li><code>expression</code>：表达元，与tcpdump类似</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>tcpkill -9 -i any host 127.0.0.1 and port 22</code></li>
</ul>
<h2 id="512-socat"><a class="markdownIt-Anchor" href="#512-socat"></a> 5.12 socat</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>socat [options] &lt;address&gt; &lt;address&gt;</code></li>
<li>其中这2个<code>address</code>就是关键了，<code>address</code>类似于一个文件描述符，Socat所做的工作就是在2个<code>address</code>指定的描述符间建立一个 <code>pipe</code>用于发送和接收数据</li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>address</code>：可以是如下几种形式之一
<ul>
<li><code>-</code>：表示标准输入输出</li>
<li><code>/var/log/syslog</code>：也可以是任意路径，如果是相对路径要使用<code>./</code>，打开一个文件作为数据流。</li>
<li><code>TCP:127.0.0.1:1080</code>：建立一个TCP连接作为数据流，TCP也可以替换为UDP</li>
<li><code>TCP-LISTEN:12345</code>：建立TCP监听端口，TCP也可以替换为UDP</li>
<li><code>EXEC:/bin/bash</code>：执行一个程序作为数据流。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>socat - /var/www/html/flag.php</code>：通过Socat读取文件，绝对路径</li>
<li><code>socat - ./flag.php</code>：通过Socat读取文件，相对路径</li>
<li><code>echo &quot;This is Test&quot; | socat - /tmp/hello.html</code>：写入文件</li>
<li><code>socat TCP-LISTEN:80,fork TCP:www.baidu.com:80</code>：将本地端口转到远端</li>
<li><code>socat TCP-LISTEN:12345 EXEC:/bin/bash</code>：在本地开启shell代理</li>
</ul>
<h2 id="513-dhclient"><a class="markdownIt-Anchor" href="#513-dhclient"></a> 5.13 dhclient</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>dhclient [-dqr]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-d</code>：总是以前台方式运行程序</li>
<li><code>-q</code>：安静模式，不打印任何错误的提示信息</li>
<li><code>-r</code>：释放ip地址</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>dhclient</code>：获取ip</li>
<li><code>dhclient -r</code>：释放ip</li>
</ul>
<h2 id="514-arp"><a class="markdownIt-Anchor" href="#514-arp"></a> 5.14 arp</h2>
<p><strong>示例：</strong></p>
<ul>
<li><code>arp</code>：查看arp缓存</li>
<li><code>arp -n</code>：查看arp缓存，显示ip不显示域名</li>
<li><code>arp 192.168.56.1</code>：查看<code>192.168.56.1</code>这个ip的mac地址</li>
</ul>
<h2 id="515-arp-scan"><a class="markdownIt-Anchor" href="#515-arp-scan"></a> 5.15 <a target="_blank" rel="noopener" href="https://github.com/royhills/arp-scan">arp-scan</a></h2>
<p><strong>如何安装：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yum install -y git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/royhills/arp-scan.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> arp-scan</span><br><span class="line"></span><br><span class="line">yum install -y autoconf automake libtool</span><br><span class="line">autoreconf --install</span><br><span class="line"></span><br><span class="line">yum install -y libpcap.x86_64 libpcap-devel.x86_64</span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line">yum install -y make</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<ul>
<li><code>arp-scan -l</code></li>
<li><code>arp-scan 10.0.2.0/24</code></li>
<li><code>arp-scan -I enp0s8 -l</code></li>
<li><code>arp-scan -I enp0s8 192.168.56.1/24</code></li>
</ul>
<h2 id="516-ping"><a class="markdownIt-Anchor" href="#516-ping"></a> 5.16 ping</h2>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-c</code>：后接发包次数</li>
<li><code>-s</code>：指定数据大小</li>
<li><code>-M [do|want|dont]</code>：设置MTU策略，<code>do</code>表示不允许分片；<code>want</code>表示当数据包比较大时可以分片；<code>dont</code>表示不设置<code>DF</code>标志位</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>ping -c 3 www.baidu.com</code></li>
<li><code>ping -s 1460 -M do baidu.com</code>：发送大小包大小是1460（+28）字节，且禁止分片</li>
</ul>
<h2 id="517-arping"><a class="markdownIt-Anchor" href="#517-arping"></a> 5.17 arping</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>arping [-fqbDUAV] [-c count] [-w timeout] [-I device] [-s source] destination</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-c</code>：指定发包次数</li>
<li><code>-b</code>：持续用广播的方式发送request</li>
<li><code>-w</code>：指定超时时间</li>
<li><code>-I</code>：指定使用哪个以太网设备</li>
<li><code>-D</code>：开启地址冲突检测模式</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>arping -c 1 -w 1 -I eth0 -b -D 192.168.1.1</code>：该命令可以用于检测局域网是否存在IP冲突
<ul>
<li>若该命令行返回0：说明不存在冲突；否则存在冲突</li>
</ul>
</li>
</ul>
<p><strong>-D参数为啥能够检测ip冲突</strong></p>
<ul>
<li>环境说明
<ul>
<li>机器A，ip为：<code>192.168.2.2/24</code>，mac地址为<code>68:ed:a4:39:92:4b</code></li>
<li>机器B，ip为：<code>192.168.2.2/24</code>，mac地址为<code>68:ed:a4:39:91:e6</code></li>
<li>路由器，ip为：<code>192.168.2.1/24</code>，mac地址为<code>c8:94:bb:af:bd:8c</code></li>
</ul>
</li>
<li>在机器A执行<code>arping -c 1 -w 1 -I eno1 -b 192.168.2.2</code>，分别在机器A、机器B上抓包，抓包结果如下
<ul>
<li><img src="/images/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/arping-1.png" alt="arping-1" /></li>
<li><img src="/images/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/arping-2.png" alt="arping-2" /></li>
<li>arp-reply发送到路由器后，路由器不知道将数据包转发给谁，就直接丢弃了</li>
</ul>
</li>
<li>在机器A执行<code>arping -c 1 -w 1 -I eno1 -D -b 192.168.2.2</code>，分别在机器A、机器B上抓包，抓包结果如下
<ul>
<li><img src="/images/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/arping-3.png" alt="arping-3" /></li>
<li><img src="/images/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/arping-4.png" alt="arping-3" /></li>
<li>arp-reply直接指定了目标机器的mac地址，因此直接送达机器A</li>
</ul>
</li>
</ul>
<h2 id="518-hping3"><a class="markdownIt-Anchor" href="#518-hping3"></a> 5.18 hping3</h2>
<p><strong>安装：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 yum 源</span></span><br><span class="line">yum install -y epel-release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装hping3</span></span><br><span class="line">yum install -y hping3</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-c</code>：发送、接收数据包的数量（如果只发包不收包是不会停止的）</li>
<li><code>-d</code>：指定数据包大小（不包含header）</li>
<li><code>-S</code>：只发送syn数据包</li>
<li><code>-w</code>：设置tcp窗口大小</li>
<li><code>-p</code>：目的端口</li>
<li><code>--flood</code>：洪范模式，尽可能快地发送数据包</li>
<li><code>--rand-source</code>：使用随机ip作为源IP</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>hping3 -c 10000 -d 120 -S -w 64 -p 21 --flood --rand-source www.baidu.com</code></li>
</ul>
<h1 id="6-运维监控"><a class="markdownIt-Anchor" href="#6-运维监控"></a> 6 运维监控</h1>
<h2 id="61-ssh"><a class="markdownIt-Anchor" href="#61-ssh"></a> 6.1 ssh</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>ssh [-f] [-o options] [-p port] [account@]host [command]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-f</code>：需要配合后面的[command]，不登录远程主机直接发送一个命令过去而已</li>
<li><code>-o</code>：后接<code>options</code>
<ul>
<li><code>ConnectTimeout=&lt;seconds&gt;</code>：等待连接的秒数，减少等待的事件</li>
<li><code>StrictHostKeyChecking=[yes|no|ask]</code>：默认是ask，若要让public key主动加入known_hosts，则可以设置为no即可</li>
</ul>
</li>
<li><code>-p</code>：后接端口号，如果sshd服务启动在非标准的端口，需要使用此项目</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>ssh 127.0.0.1</code>：由于SSH后面没有加上账号，因此默认采用当前的账号来登录远程服务器</li>
<li><code>ssh student@127.0.0.1</code>：账号为该IP的主机上的账号，而非本地账号哦</li>
<li><code>ssh student@127.0.0.1 find / &amp;&gt; ~/find1.log</code></li>
<li><code>ssh -f student@127.0.0.1 find / &amp;&gt; ~/find1.log</code>：会立即注销127.0.0.1，find在远程服务器运行</li>
</ul>
<h3 id="611-免密登录"><a class="markdownIt-Anchor" href="#611-免密登录"></a> 6.1.1 免密登录</h3>
<p><strong>Client端步骤：</strong></p>
<ol>
<li><code>ssh-keygen [-t rsa|dsa]</code></li>
<li><code>scp ~/.ssh/id_rsa.pub [account@]host:~</code></li>
</ol>
<p><strong>Server端步骤：</strong></p>
<ol>
<li><code>mkdir ~/.ssh; chmod 700 .ssh</code>，若不存在<code>~/.ssh</code>文件夹，则创建</li>
<li><code>cat id_rsa.pub &gt;&gt; .ssh/authorized_keys</code></li>
<li><code>chmod 644 .ssh/authorized_keys</code></li>
</ol>
<h3 id="612-禁止密码登录"><a class="markdownIt-Anchor" href="#612-禁止密码登录"></a> 6.1.2 禁止密码登录</h3>
<p>修改<code>/etc/ssh/sshd_config</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure>
<h2 id="62-scp"><a class="markdownIt-Anchor" href="#62-scp"></a> 6.2 scp</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>scp [-pPr] [-l 速率] local_file [account@]host:dir</code></li>
<li><code>scp [-pPr] [-l 速率] [account@]host:file local_dir</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-p</code>：保留源文件的权限信息</li>
<li><code>-P</code>：指定端口号</li>
<li><code>-r</code>：复制来源为目录时，可以复制整个目录(含子目录)</li>
<li><code>-l</code>：可以限制传输速率，单位Kbits/s</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>scp /etc/hosts* student@127.0.0.1:~</code></li>
<li><code>scp /tmp/Ubuntu.txt root@192.168.136.130:~/Desktop</code></li>
<li><code>scp -P 16666 root@192.168.136.130:/tmp/test.log ~/Desktop</code>：指定主机<code>192.168.136.130</code>的端口号为16666</li>
<li><code>scp -r local_folder remote_username@remote_ip:remote_folder</code></li>
</ul>
<h2 id="63-watch"><a class="markdownIt-Anchor" href="#63-watch"></a> 6.3 watch</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>watch [option] [cmd]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-n</code>：watch缺省该参数时，每2秒运行一下程序，可以用<code>-n</code>或<code>-interval</code>来指定间隔的时间</li>
<li><code>-d</code>：<code>watch</code>会高亮显示变化的区域。<code>-d=cumulative</code>选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来</li>
<li><code>-t</code>：关闭watch命令在顶部的时间间隔命令，当前时间的输出</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>watch -n 1 -d netstat -ant</code>：每隔一秒高亮显示网络链接数的变化情况</li>
<li><code>watch -n 1 -d 'pstree | grep http'</code>：每隔一秒高亮显示http链接数的变化情况</li>
<li><code>watch 'netstat -an | grep :21 | grep &lt;ip&gt; | wc -l'</code>：实时查看模拟攻击客户机建立起来的连接数</li>
<li><code>watch -d 'ls -l | grep scf'</code>：监测当前目录中 scf’ 的文件的变化</li>
<li><code>watch -n 10 'cat /proc/loadavg'</code>：10秒一次输出系统的平均负载</li>
</ul>
<h2 id="64-top"><a class="markdownIt-Anchor" href="#64-top"></a> 6.4 top</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>top [-H] [-p &lt;pid&gt;]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-H</code>：显示线程</li>
<li><code>-p</code>：查看指定进程</li>
<li><code>-b</code>：非交互式，通常与<code>-n</code>参数一起使用，<code>-n</code>用于指定统计的次数</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>top -p 123</code>：查看进程号为123的进程</li>
<li><code>top -Hp 123</code>：查看进程号为123以及该进程的所有线程</li>
<li><code>top -b -n 3</code></li>
</ul>
<p><strong>打印参数说明：</strong></p>
<ul>
<li><strong>第一行</strong>：
<ul>
<li>目前的时间</li>
<li>开机到目前为止所经过的时间</li>
<li>已经登录的人数</li>
<li>系统在1，5，15分钟的平均工作负载</li>
</ul>
</li>
<li><strong>第二行</strong>：显示的是目前进程的总量，与各个状态下进程的数量</li>
<li><strong>第三行</strong>：显示的CPU整体负载，特别注意wa，这个代表的是I/Owait，通常系统变慢都是I/O产生的问题比较大</li>
<li><strong>第四五行</strong>：物理内存与虚拟内存的使用情况，注意swap的使用量越少越好，大量swap被使用说明系统物理内存不足</li>
<li><strong>第六行</strong>：top进程中，输入命令时显示的地方</li>
<li><strong>第七行以及以后</strong>：每个进程的资源使用情况
<ul>
<li>PID：每个进程的ID</li>
<li>USER：进程所属用户名称</li>
<li>PR：Priority，优先顺序，越小优先级越高</li>
<li>NI：Nice，与Priority有关，越小优先级越高</li>
<li>%CPU：CPU使用率</li>
<li>%MEN：内存使用率</li>
<li>TIME+：CPU使用时间累加</li>
<li>COMMAND</li>
</ul>
</li>
<li><strong>top默认使用CPU使用率作为排序的终点，键入<code>h</code>显示帮助菜单</strong></li>
<li><strong>排序顺序</strong>
<ul>
<li><code>P</code>：按CPU使用量排序，默认从大到小，<code>R</code>更改为从小到大</li>
<li><code>M</code>：按内存使用量排序，默认从大到小，<code>R</code>更改为从小到大</li>
<li><code>T</code>：按使用时间排序，默认从大到小，<code>R</code>更改为从小到大</li>
</ul>
</li>
<li><strong>其他功能按键</strong>
<ul>
<li><code>1</code>：概览信息中分别展示每个核的使用状态</li>
<li><code>2</code>：概览信息和只展示所有核的平均使用状态</li>
<li><code>x</code>：高亮排序的列</li>
<li><code>-R</code>：反转排序</li>
<li><code>n [num]</code>：只显示前几列，当num=0时，表示无限制</li>
<li><code>l</code>：调整cpu负载信息的展示方式</li>
<li><code>t</code>：调整cpu以及任务详情的展示方式</li>
<li><code>m</code>：调整memory详情的展示方式</li>
<li><code>c</code>：展示完整command</li>
<li><code>V</code>：以树型格式展示command</li>
<li><code>H</code>：展示线程</li>
<li><code>W</code>：将当前交互式的一些配置（比如是否展示每个cpu的状态，是否以cpu使用量排序等等）存储到配置文件<code>~/.toprc</code>中，然后我们就可以用<code>top -b -n 1</code>这种非交互的方式来获取top的输出了（会读取<code>~/.toprc</code>中的内容）</li>
</ul>
</li>
</ul>
<h2 id="65-slabtop"><a class="markdownIt-Anchor" href="#65-slabtop"></a> 6.5 slabtop</h2>
<p><code>slabtop</code>用于展示内核的<code>slab cache</code>相关信息</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>slabtop</code></li>
</ul>
<h2 id="66-sar"><a class="markdownIt-Anchor" href="#66-sar"></a> 6.6 sar</h2>
<p>sar是由有类似日志切割的功能的，它会依据<code>/etc/cron.d/sysstat</code>中的计划任务，将日志放入<code>/var/log/sa/</code>中</p>
<p><strong>安装：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y sysstat</span><br></pre></td></tr></table></figure>
<p><strong>格式：</strong></p>
<ul>
<li><code>sar [ 选项 ] [ &lt;时间间隔&gt; [ &lt;次数&gt; ] ]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-u</code>：查看cpu使用率</li>
<li><code>-q</code>：查看cpu负载</li>
<li><code>-r</code>：查看内存使用情况</li>
<li><code>-b</code>：I/O 和传输速率信息状况</li>
<li><code>-f &lt;filename&gt;</code>：指定sa日志文件</li>
<li><code>-n [关键词]</code>：查看网络相关的情况，其中关键词可以是
<ul>
<li><code>DEV</code>：网卡</li>
<li><code>SOCK</code>：套接字</li>
<li><code>IP</code>：IP流</li>
<li><code>TCP</code>：TCP流</li>
<li><code>UDP</code>：UDP流</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>sar -u 1 10</code></li>
<li><code>sar -n DEV 1</code></li>
</ul>
<h2 id="67-tsar"><a class="markdownIt-Anchor" href="#67-tsar"></a> 6.7 tsar</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>tsar [-l]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-l</code>：查看实时数据</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>tsar -l</code></li>
</ul>
<h2 id="68-vmstat"><a class="markdownIt-Anchor" href="#68-vmstat"></a> 6.8 vmstat</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>vmstat [options] [delay [count]]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-a, --active</code>：显示活跃和非活跃内存</li>
<li><code>-f, --forks</code>：从系统启动至今的fork数量，linux下创建进程的系统调用是fork
<ul>
<li>信息是从<code>/proc/stat</code>中的processes字段里取得的</li>
</ul>
</li>
<li><code>-m, --slabs</code>：查看系统的slab信息</li>
<li><code>-s, --stats</code>：查看内存使用的详细信息</li>
<li><code>-d, --disk</code>：查看磁盘使用的详细信息</li>
<li><code>-D, --disk-sum</code>         summarize disk statistics</li>
<li><code>-p, --partition &lt;dev&gt;</code>：查看指定分区的详细信息</li>
<li><code>-S, --unit &lt;char&gt;</code>：指定输出单位，只支持<code>k/K</code>以及<code>m/M</code>，默认是<code>K</code></li>
<li><code>-w, --wide</code>：输出更详细的信息</li>
<li><code>-t, --timestamp</code>：输出时间戳</li>
<li><code>delay</code>：采样间隔</li>
<li><code>count</code>：采样次数</li>
</ul>
<p><strong>输出信息介绍：</strong></p>
<ul>
<li><code>process</code>
<ul>
<li><code>r</code>：运行中的进程数量（<code>running</code>或<code>waiting</code>状态</li>
<li><code>b</code>：阻塞中的进程数量</li>
</ul>
</li>
<li><code>memory</code>
<ul>
<li><code>swpd</code>：虚拟内存总量</li>
<li><code>free</code>：空闲内存总量</li>
<li><code>buff</code>：被用作buffer的内存总量</li>
<li><code>cache</code>：被用作cache的内存总量</li>
<li><code>inact</code>：无效内存总量（需要加<code>-a</code>参数）</li>
<li><code>active</code>：有效内存总量（需要加<code>-a</code>参数）</li>
</ul>
</li>
<li><code>swap</code>
<ul>
<li><code>si</code>：每秒从磁盘交换的内存总量</li>
<li><code>so</code>：每秒交换到磁盘的内存总量</li>
</ul>
</li>
<li><code>io</code>
<ul>
<li><code>bi</code>：每秒从块设备接收的block数量</li>
<li><code>bo</code>：每秒写入块设备的block数量</li>
</ul>
</li>
<li><code>system</code>
<ul>
<li><code>in</code>：每秒中断次数，包括时钟中断</li>
<li><code>cs</code>：每秒上下文切换的次数</li>
</ul>
</li>
<li><code>cpu</code>
<ul>
<li><code>us</code>：用户cpu时间</li>
<li><code>sy</code>：系统（内核）cpu时间</li>
<li><code>id</code>：空闲cpu时间</li>
<li><code>wa</code>：等待IO的cpu时间</li>
<li><code>st</code>：从虚拟机窃取的时间</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>vmstat</code></li>
<li><code>vmstat 2</code></li>
<li><code>vmstat 2 5</code></li>
<li><code>vmstat -s</code></li>
<li><code>vmstat -s -S m</code></li>
<li><code>vmstat -f</code></li>
<li><code>vmstat -d</code></li>
<li><code>vmstat -p /dev/sda1</code></li>
<li><code>vmstat -m</code></li>
</ul>
<h2 id="69-mpstat"><a class="markdownIt-Anchor" href="#69-mpstat"></a> 6.9 mpstat</h2>
<p><code>mpstat</code>（<code>multiprocessor statistics</code>）是实时监控工具，报告与cpu的一些统计信息这些信息都存在<code>/proc/stat</code>文件中，在多cpu系统里，其不但能查看所有的cpu的平均状况的信息，而且能够有查看特定的cpu信息，<code>mpstat</code>最大的特点是可以查看多核心的cpu中每个计算核心的统计数据；而且类似工具<code>vmstat</code>只能查看系统的整体cpu情况</p>
<p><strong>输出信息介绍：</strong></p>
<ul>
<li><strong><code>%usr</code></strong>：用户cpu时间百分比</li>
<li><code>%nice</code>：改变过优先级的进程的占用cpu时间百分比
<ul>
<li><code>PRI</code>是比较好理解的，即进程的优先级，或者通俗点说就是程序被cpu执行的先后顺序，此值越小进程的优先级别越高。那<code>NI</code>呢？就是我们所要说的<code>nice</code>值了，其表示进程可被执行的优先级的修正数值。如前面所说，<code>PRI</code>值越小越快被执行，那么加入<code>nice</code>值后，将会使得<code>PRI</code>变为：<code>PRI(new) = PRI(old) + nice</code></li>
<li>在linux系统中，<code>nice</code>值的范围从<code>-20</code>到<code>+19</code>（不同系统的值范围是不一样的），正值表示低优先级，负值表示高优先级，值为零则表示不会调整该进程的优先级。具有最高优先级的程序，其<code>nice</code>值最低，所以在linux系统中，值<code>-20</code>使得一项任务变得非常重要；<strong>与之相反，如果任务的<code>nice</code>为<code>+19</code>，则表示它是一个高尚的、无私的任务，允许所有其他任务比自己享有宝贵的CPU时间的更大使用份额，这也就是<code>nice</code>的名称的来意</strong></li>
<li>进程在创建时被赋予不同的优先级值，而如前面所说，<code>nice</code>的值是表示进程优先级值可被修正数据值，因此，每个进程都在其计划执行时被赋予一个<code>nice</code>值，这样系统就可以根据系统的资源以及具体进程的各类资源消耗情况，主动干预进程的优先级值。在通常情况下，子进程会继承父进程的<code>nice</code>值，比如在系统启动的过程中，<code>init</code>进程会被赋予<code>0</code>，其他所有进程继承了这个<code>nice</code>值（因为其他进程都是<code>init</code>的子进程）</li>
<li><strong>对<code>nice</code>值一个形象比喻，假设在一个cpu轮转中，有2个runnable的进程<code>A</code>和<code>B</code>，如果他们的<code>nice</code>值都为0，假设内核会给他们每人分配1k个cpu时间片。但是假设进程<code>A</code>的<code>nice</code>值为0，但是<code>B</code>的<code>nice</code>值为-10，那么此时cpu可能分别给<code>A</code>和<code>B</code>分配1k和1.5k的时间片。故可以形象的理解为，<code>nice</code>的值影响了内核分配给进程的cpu时间片的多少，时间片越多的进程，其优先级越高，其优先级值（PRI）越低。<code>%nice</code>：就是改变过优先级的进程的占用cpu的百分比，如上例中就是<code>0.5k / 2.5k = 1/5 = 20%</code></strong></li>
<li>由此可见，进程<code>nice</code>值和进程优先级不是一个概念，但是进程<code>nice</code>值会影响到进程的优先级变化</li>
</ul>
</li>
<li><strong><code>%sys</code></strong>：系统（内核）cpu时间百分比，不包括处理硬中断和软中断的时间</li>
<li><strong><code>%iowait</code></strong>：在系统有未完成的磁盘<code>I/O</code>请求期间，一个或多个CPU空闲的时间百分比</li>
<li><code>%irq</code>：处理硬中断的cpu时间百分比</li>
<li><code>%soft</code>：处理软中断的cpu时间百分比</li>
<li><code>%steal</code>：在管理程序为另一个虚拟处理器提供服务时，一个或多个虚拟CPU在非自愿等待中花费的时间百分比</li>
<li><code>%guest</code>：一个或多个CPU运行虚拟处理器所花费的时间百分比</li>
<li><code>%gnice</code>：一个或多个CPU运行一个<code>niced guest</code>所花费的时间百分</li>
<li><strong><code>%idle</code></strong>：一个或多个CPU空闲且系统没有未完成的磁盘<code>I/O</code>请求的时间百分比</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>mpstat 2 5</code>：打印整体信息，间隔2s，打印5次</li>
<li><code>mpstat -P ALL 2 5</code>：已单核为粒度打印信息，间隔2s，打印5次</li>
</ul>
<h2 id="610-iostat"><a class="markdownIt-Anchor" href="#610-iostat"></a> 6.10 iostat</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>iostat [ -c | -d ] [ -k | -m ] [ -t ] [ -x ] [ interval [ count ] ]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-c</code>：与<code>-d</code>互斥，只显示cpu相关的信息</li>
<li><code>-d</code>：与<code>-c</code>互斥，只显示磁盘相关的信息</li>
<li><code>-k</code>：以<code>kB</code>的方式显示io速率（默认是<code>Blk</code>，即文件系统中的<code>block</code>）</li>
<li><code>-m</code>：以<code>MB</code>的方式显示io速率（默认是<code>Blk</code>，即文件系统中的<code>block</code>）</li>
<li><code>-t</code>：打印日期信息</li>
<li><code>-x</code>：打印扩展信息</li>
<li><code>interval</code>: 打印间隔</li>
<li><code>count</code>: 打印几次，不填一直打印</li>
</ul>
<p><strong>输出信息介绍：</strong></p>
<ul>
<li><code>cpu</code>
<ul>
<li><code>%user</code>：用户cpu时间百分比</li>
<li><code>%nice</code>：改变过优先级的进程的占用cpu时间百分比</li>
<li><code>%system</code>：系统（内核）cpu时间百分比，不包括处理硬中断和软中断的时间</li>
<li><code>%iowait</code>：在系统有未完成的磁盘I/O请求期间，一个或多个CPU空闲的时间百分比</li>
<li><code>%steal</code>：在管理程序为另一个虚拟处理器提供服务时，一个或多个虚拟CPU在非自愿等待中花费的时间</li>
<li><code>%idle</code>：一个或多个CPU空闲且系统没有未完成的磁盘I/O请求的时间百分比</li>
</ul>
</li>
<li><code>device</code>
<ul>
<li><code>tps</code>：每秒处理的io请求</li>
<li><code>Blk_read/s (kB_read/s, MB_read/s)</code>：每秒读取的数据量，单位可以是Block、kB、MB</li>
<li><code>Blk_wrtn/s (kB_wrtn/s, MB_wrtn/s)</code>：每秒写入的数据量，单位可以是Block、kB、MB</li>
<li><code>Blk_read (kB_read, MB_read)</code>：读取的数据总量，单位可以是Block、kB、MB</li>
<li><code>Blk_wrtn (kB_wrtn, MB_wrtn)</code>：写入的数据总量，单位可以是Block、kB、MB</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>iostat -d -t -x 1</code></li>
</ul>
<h2 id="611-dstat"><a class="markdownIt-Anchor" href="#611-dstat"></a> 6.11 dstat</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>dstat [options]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-c, --cpu</code>：cpu统计信息
<ul>
<li><code>system</code></li>
<li><code>user</code></li>
<li><code>idle</code></li>
<li><code>wait</code></li>
<li><code>hardware interrupt</code></li>
<li><code>software interrupt</code></li>
</ul>
</li>
<li><code>-d, --disk</code>：磁盘统计信息
<ul>
<li><code>read</code></li>
<li><code>write</code></li>
</ul>
</li>
<li><code>-i, --int</code>：中断统计信息</li>
<li><code>-l, --load</code>：cpu负载统计信息
<ul>
<li><code>1 min</code></li>
<li><code>5 mins</code></li>
<li><code>15mins</code></li>
</ul>
</li>
<li><code>-m, --mem</code>：内存统计信息
<ul>
<li><code>used</code></li>
<li><code>buffers</code></li>
<li><code>cache</code></li>
<li><code>free</code></li>
</ul>
</li>
<li><code>-n, --net</code>：网络统计信息
<ul>
<li><code>receive</code></li>
<li><code>send</code></li>
</ul>
</li>
<li><code>-p, --proc</code>：进程统计信息
<ul>
<li><code>runnable</code></li>
<li><code>uninterruptible</code></li>
<li><code>new</code></li>
</ul>
</li>
<li><code>-r, --io</code>：I/O统计信息
<ul>
<li><code>read requests</code></li>
<li><code>write requests</code></li>
</ul>
</li>
<li><code>-s, --swap</code>：swap统计信息
<ul>
<li><code>used</code></li>
<li><code>free</code></li>
</ul>
</li>
<li><code>-t, --time</code>：时间信息</li>
<li><code>-y, --sys</code>：系统统计信息
<ul>
<li><code>interrupts</code></li>
<li><code>context switches</code></li>
</ul>
</li>
<li><code>--fs, --filesystem</code>：文件系统统计信息
<ul>
<li><code>open files</code></li>
<li><code>inodes</code></li>
</ul>
</li>
<li><code>--ipc</code>：ipc统计信息
<ul>
<li><code>message queue</code></li>
<li><code>semaphores</code></li>
<li><code>shared memory</code></li>
</ul>
</li>
<li><code>--lock</code>：文件锁统计信息
<ul>
<li><code>posix</code></li>
<li><code>flock</code></li>
<li><code>read</code></li>
<li><code>write</code></li>
</ul>
</li>
<li><code>--socket</code>：socket统计信息
<ul>
<li><code>total</code></li>
<li><code>tcp</code></li>
<li><code>udp</code></li>
<li><code>raw</code></li>
<li><code>ip-fragments</code></li>
</ul>
</li>
<li><code>--tcp</code>：tcp统计信息，包括
<ul>
<li><code>listen</code></li>
<li><code>established</code></li>
<li><code>syn</code></li>
<li><code>time_wait</code></li>
<li><code>close</code></li>
</ul>
</li>
<li><code>--udp</code>：udp统计信息，包括
<ul>
<li><code>listen</code></li>
<li><code>active</code></li>
</ul>
</li>
<li><strong><code>-f, --full</code></strong>：显示详情，例如cpu会按每个cpu分别展示，network会按网卡分别展示</li>
<li><strong><code>--top-cpu</code>：显示最耗cpu资源的进程</strong></li>
<li><strong><code>--top-cpu-adv</code>：显示最耗cpu资源的进程，以及进程的其他信息</strong></li>
<li><strong><code>--top-io</code>：显示最耗io资源的进程</strong></li>
<li><strong><code>--top-io-adv</code>：显示最耗io资源的进程，以及进程的其他信息</strong></li>
<li><strong><code>--top-mem</code>：显示最耗mem资源的进程</strong></li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>dstat -h</code>：参数说明</li>
<li><code>dstat 5 10</code>：5秒刷新一次，刷新10次</li>
<li><code>dstat -cdgilmnprstTy</code></li>
<li><code>dstat -tcndylp --top-cpu</code>
<ul>
<li>等价于<code>dstat --time --cpu --net --disk --sys --load --proc --top-cpu</code></li>
</ul>
</li>
<li><code>dstat -tcyif</code></li>
</ul>
<h2 id="612-ifstat"><a class="markdownIt-Anchor" href="#612-ifstat"></a> 6.12 ifstat</h2>
<p>该命令用于查看网卡的流量状况，包括成功接收/发送，以及错误接收/发送的数据包，看到的东西基本上和<code>ifconfig</code>类似</p>
<h2 id="613-pidstat"><a class="markdownIt-Anchor" href="#613-pidstat"></a> 6.13 pidstat</h2>
<h2 id="614-nethogs"><a class="markdownIt-Anchor" href="#614-nethogs"></a> 6.14 nethogs</h2>
<p>nethogs会以进程为单位，列出每个进程占用的网卡以及带宽</p>
<p><strong>安装：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 yum 源</span></span><br><span class="line">yum install -y epel-release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装nethogs</span></span><br><span class="line">yum install -y nethogs</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<ul>
<li><code>nethogs</code></li>
</ul>
<h2 id="615-iptraf"><a class="markdownIt-Anchor" href="#615-iptraf"></a> 6.15 iptraf</h2>
<h2 id="616-iftop"><a class="markdownIt-Anchor" href="#616-iftop"></a> 6.16 iftop</h2>
<p>iftop会以连接为单位，列出每个连接的进出流量</p>
<p><strong>安装：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 yum 源</span></span><br><span class="line">yum install -y epel-release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装ifgop</span></span><br><span class="line">yum install -y iftop</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<ul>
<li><code>iftop</code></li>
</ul>
<h2 id="617-iotop"><a class="markdownIt-Anchor" href="#617-iotop"></a> 6.17 iotop</h2>
<p><strong>安装：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 yum 源</span></span><br><span class="line">yum install -y epel-release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装iotop</span></span><br><span class="line">yum install -y iotop</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-o</code>：只显示正在执行io操作的进程或者线程</li>
<li><code>-u</code>：后接用户名</li>
<li><code>-P</code>：只显示进程不显示线程</li>
<li><code>-b</code>：批处理，即非交互模式</li>
<li><code>-n</code>：后接次数</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>iotop</code></li>
<li><code>iotop -oP</code></li>
<li><code>iotop -oP -b -n 10</code></li>
<li><code>iotop -u admin</code></li>
</ul>
<h1 id="7-性能分析工具"><a class="markdownIt-Anchor" href="#7-性能分析工具"></a> 7 性能分析工具</h1>
<h2 id="71-strace"><a class="markdownIt-Anchor" href="#71-strace"></a> 7.1 strace</h2>
<p><code>strace</code>是Linux环境下的一款程序调试工具，用来监察一个应用程序所使用的系统调用<br />
<code>strace</code>是一个简单的跟踪系统调用执行的工具。在其最简单的形式中，它可以从开始到结束跟踪二进制的执行，并在进程的生命周期中输出一行具有系统调用名称，每个系统调用的参数和返回值的文本行</p>
<p>在Linux中，进程是不能直接去访问硬件设备的，比如读取磁盘文件、接收网络数据等，但可以将用户态模式切换到内核模式，通过系统调用来访问硬件设备。这时<code>strace</code>就可以跟踪到一个进程产生的系统调用，包括参数，返回值，执行消耗的时间、调用次数，成功和失败的次数</p>
<p><strong>strace能做什么：</strong></p>
<ol>
<li>基于特定的系统调用或系统调用组进行过滤</li>
<li>通过统计特定系统调用的使用次数，所花费的时间，以及成功和错误的数量来分析系统调用的使用</li>
<li>跟踪发送到进程的信号</li>
<li>通过pid附加到任何正在运行的进程</li>
<li>调试性能问题，查看系统调用的频率，找出耗时的程序段</li>
<li>查看程序读取的是哪些文件从而定位比如配置文件加载错误问题</li>
<li>查看某个php脚本长时间运行“假死”情况</li>
<li>当程序出现<code>Out of memory</code>时被系统发出的SIGKILL信息所kill</li>
<li>另外因为strace拿到的是系统调用相关信息，一般也即是IO操作信息，这个对于排查比如cpu占用100%问题是无能为力的。这个时候就可以使用GDB工具了</li>
</ol>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-c</code>：输出统计报表</li>
<li><code>-e</code>：后接系统调用的表达式</li>
<li><code>-p</code>：后接进程id，用于跟踪指定进程</li>
</ul>
<p><strong>示例：</strong></p>
<ol>
<li><code>strace cat /etc/fstab</code>：跟踪cat查看文件使用了哪些系统调用（按时间顺序）</li>
<li><code>strace -e read cat /etc/fstab</code>：跟踪cat查看文件时使用的<code>read</code>这一系统调用</li>
<li><code>strace -c cat /etc/fstab</code>：统计cat查看文件的系统调用（按调用频率）</li>
<li><code>timeout 10 strace -p &#123;PID&#125; -f -c</code>：统计指定进程的系统调用</li>
</ol>
<h2 id="72-perf"><a class="markdownIt-Anchor" href="#72-perf"></a> 7.2 perf</h2>
<p><strong><code>perf</code>的原理是这样的：每隔一个固定的时间，就在CPU上（每个核上都有）产生一个中断，在中断上看看，当前是哪个<code>pid</code>，哪个函数，然后给对应的<code>pid</code>和函数加一个统计值，这样，我们就知道CPU有百分几的时间在某个<code>pid</code>，或者某个函数上了</strong></p>
<p><strong>常用子命令</strong></p>
<ul>
<li><code>archive</code>：由于<code>perf.data</code>的解析需要一些其他信息，比如符号表、<code>pid</code>、进程对应关系等，该命令就是将这些相关的文件都打成一个包，这样在别的机器上也能进行分析</li>
<li><code>diff</code>：用于展示两个<code>perf.data</code>之间的差异</li>
<li><code>evlist</code>：列出<code>perf.data</code>中包含的额事件</li>
<li><code>list</code>：查看支持的所有事件</li>
<li><code>record</code>：启动分析，并将记录写入<code>perf.data</code>
<ul>
<li><code>perf record</code>在当前目录产生一个<code>perf.data</code>文件（如果这个文件已经存在，旧的文件会被改名为<code>perf.data.old</code>）</li>
<li><code>perf record</code>不一定用于跟踪自己启动的进程，通过指定<code>pid</code>，可以直接跟踪固定的一组进程。另外，大家应该也注意到了，上面给出的跟踪都仅仅跟踪发生在特定pid的事件。但很多模型，比如一个webserver，你其实关心的是整个系统的性能，网络上会占掉一部分CPU，WebServer本身占一部分CPU，存储子系统也会占据部分的CPU，网络和存储不一定就属于你的WebServer这个<code>pid</code>。<strong>所以，对于全系统调优，我们常常给<code>perf record</code>命令加上<code>-a</code>参数，这样可以跟踪整个系统的性能</strong></li>
</ul>
</li>
<li><code>report</code>：读取<code>perf.data</code>并展示</li>
<li><code>stat</code>：仅展示一些统计信息</li>
<li><code>top</code>：以交互式的方式进行分析</li>
</ul>
<p><strong>关键参数：</strong></p>
<ul>
<li><code>-e</code>：指定跟踪的事件
<ul>
<li><code>perf top -e branch-misses,cycles</code></li>
<li><code>perf top -e branch-misses:u,cycles</code>：事件可以指定后缀，只跟踪发生在用户态时产生的分支预测失败</li>
<li><code>perf top -e ‘&#123;branch-misses,cycles&#125;:u'</code>：全部事件都只关注用户态部分</li>
</ul>
</li>
<li><code>-s</code>：指定按什么参数来进行分类
<ul>
<li><code>perf top -e 'cycles' -s comm,pid,dso</code></li>
</ul>
</li>
<li><code>-p</code>：指定跟踪的<code>pid</code></li>
</ul>
<p><strong>示例：</strong></p>
<ol>
<li><code>perf list</code>查看支持的所有事件</li>
<li><code>perf stat -e L1-dcache-load-misses,L1-dcache-loads -- cat /etc/passwd</code>：统计缓存miss率</li>
<li><code>timeout 10 perf record -e 'cycles' -a</code>：统计整个系统，统计10秒</li>
<li><code>perf record -e 'cycles' -p xxx</code>：统计指定的进程</li>
<li><code>perf record -e 'cycles' -- myapplication arg1 arg2</code>：启动程序并进行统计</li>
<li><code>perf report</code>：查看分析报告</li>
<li><strong><code>perf top -p &lt;pid&gt;</code>：以交互式的方式分析一个程序的性能（神器）</strong>
<ul>
<li>选中某个条目，然后选择<code>Anotate xxx</code>可以查看对应的汇编</li>
</ul>
</li>
</ol>
<h1 id="8-audit"><a class="markdownIt-Anchor" href="#8-audit"></a> 8 audit</h1>
<p><a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/index">红帽企业版 Linux 7安全性指南</a></p>
<h2 id="81-架构"><a class="markdownIt-Anchor" href="#81-架构"></a> 8.1 架构</h2>
<p><img src="/images/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/audit_architecture.png" alt="audit_architecture" /></p>
<p>审核系统包含两个主要部分：用户空间的应用程序、实用程序，以及<code>kernel-side</code>系统调用处理。Kernel的组件从用户空间的应用程序接受系统调用，并且通过三个过滤器中的一个过滤器来进行筛选：<code>user</code>、<code>task</code>或者<code>exit</code>。一旦系统调用通过其中的一个过滤器，就将通过<code>exclude</code>过滤器进行传送，这是基于审核规则的配置，并把它传送给审核的守护程序做进一步的处理</p>
<p>处理过程和<code>iptables</code>差不多，有规则链，可以在链中增加规则，它发现一个<code>syscall</code>或者特殊事件的时候会去遍历这个链，然后按规则处理，吐不同的日志</p>
<p><strong>与audit相关的内核编译参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_AUDIT_ARCH=y</span><br><span class="line">CONFIG_AUDIT=y</span><br><span class="line">CONFIG_AUDITSYSCALL=y</span><br><span class="line">CONFIG_AUDIT_WATCH=y</span><br><span class="line">CONFIG_AUDIT_TREE=y</span><br><span class="line">CONFIG_NETFILTER_XT_TARGET_AUDIT=m</span><br><span class="line">CONFIG_IMA_AUDIT=y</span><br><span class="line">CONFIG_KVM_MMU_AUDIT=y</span><br></pre></td></tr></table></figure>
<p><strong>只要编译内核时，开启了审计的选项，那么内核就会产生审计事件，并将审计事件送往一个socket，然后auditd负责从这个socket读出审计事件并记录</strong></p>
<h2 id="82-auditctl"><a class="markdownIt-Anchor" href="#82-auditctl"></a> 8.2 auditctl</h2>
<h3 id="821-控制规则"><a class="markdownIt-Anchor" href="#821-控制规则"></a> 8.2.1 控制规则</h3>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-b</code>：设置允许的未完成审核缓冲区的最大数量，默认值是<code>64</code></li>
<li><code>-e [0..2]</code>：设置启用标志位
<ul>
<li><code>0</code>：关闭审计功能</li>
<li><code>1</code>：开启审计功能，且允许修改配置</li>
<li><code>2</code>：开启审计功能，且不允许修改配置</li>
</ul>
</li>
<li><code>-f [0..2]</code>：设置异常标志位（告诉内如如何处理这些异常）
<ul>
<li><code>0</code>：silent，当发现异常时，不处理（静默）</li>
<li><code>1</code>：printk，打日志（这是默认值）</li>
<li><code>2</code>：panic，崩溃</li>
</ul>
</li>
<li><code>-r</code>：消息产生的速率，单位秒</li>
<li><code>-s</code>：报告审核系统状态</li>
<li><code>-l</code>：列出所有当前装载的审核规则</li>
<li><code>-D</code>：清空所有规则以及watch</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>auditctl -b 8192</code></li>
<li><code>auditctl -e 0</code></li>
<li><code>auditctl -r 0</code></li>
<li><code>auditctl -s</code></li>
<li><code>auditctl -l</code></li>
</ul>
<h3 id="822-文件系统规则"><a class="markdownIt-Anchor" href="#822-文件系统规则"></a> 8.2.2 文件系统规则</h3>
<p><strong>格式：</strong></p>
<ul>
<li><code>auditctl -w &lt;path_to_file&gt; -p &lt;permissions&gt; -k &lt;key_name&gt;</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-w</code>：路径名称</li>
<li><code>-p</code>：后接权限，包括
<ul>
<li><code>r</code>：读取文件或者目录</li>
<li><code>w</code>：写入文件或者目录</li>
<li><code>x</code>：运行文件或者目录</li>
<li><code>a</code>：改变在文件或者目录中的属性</li>
</ul>
</li>
<li><code>-k</code>：后接字符串，可以任意指定，用于搜索</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>auditctl -w /etc/shadow -p wa -k passwd_changes</code>：等价于<code>auditctl -a always,exit -F path=/etc/shadow -F perm=wa -k passwd_changes</code></li>
</ul>
<h3 id="823-系统调用规则"><a class="markdownIt-Anchor" href="#823-系统调用规则"></a> 8.2.3 系统调用规则</h3>
<p><strong>格式：</strong></p>
<ul>
<li><code>auditctl -a &lt;action&gt;,&lt;filter&gt; -S &lt;system_call&gt; -F field=value -k &lt;key_name&gt;</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-a</code>：后接<code>action</code>和<code>filter</code>
<ul>
<li><code>action</code>：决定匹配<code>filter</code>的审计事件是否要记录，可选值包括
<ul>
<li><code>always</code>：记录</li>
<li><code>never</code>：不记录</li>
</ul>
</li>
<li><code>filter</code>：审计事件过滤器，可选值包括
<ul>
<li><code>task</code>：匹配进程创建时（<code>fork</code>或<code>clone</code>）产生的审计事件</li>
<li><strong><code>exit</code>：匹配系统调用结束时产生的审计事件</strong></li>
<li><code>user</code>：匹配来自用户空间的审计事件</li>
<li><code>exclude</code>：用于屏蔽不想要的审计事件</li>
</ul>
</li>
</ul>
</li>
<li><code>-S</code>：后接系统调用名称，系统调用清单可以参考<code>/usr/include/asm/unistd_64.h</code>，如果要指定多个系统调用名称，那么需要多个<code>-S</code>参数，每个指定一个系统调用</li>
<li><code>-F</code>：扩展选项，键值对</li>
<li><code>-k</code>：后接字符串，可以任意指定，用于搜索</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>auditctl -a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time_change</code></li>
</ul>
<h2 id="83-ausearch"><a class="markdownIt-Anchor" href="#83-ausearch"></a> 8.3 ausearch</h2>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-i</code>：翻译结果，使其更可读</li>
<li><code>-m</code>：指定类型</li>
<li><code>-sc</code>：指定系统调用名称</li>
<li><code>-sv</code>：系统调用是否成功</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>ausearch -i</code>：搜索全量事件</li>
<li><code>ausearch --message USER_LOGIN --success no --interpret</code>：搜索登录失败的相关事件</li>
<li><code>ausearch -m ADD_USER -m DEL_USER -m ADD_GROUP -m USER_CHAUTHTOK -m DEL_GROUP -m CHGRP_ID -m ROLE_ASSIGN -m ROLE_REMOVE -i</code>：搜索所有的账户，群组，角色变更相关的事件</li>
<li><code>ausearch --start yesterday --end now -m SYSCALL -sv no -i</code>：搜寻从昨天至今所有的失败的系统调用相关的事件</li>
<li><code>ausearch -m SYSCALL -sc open -i</code>：搜寻系统调用open相关的事件</li>
</ul>
<h2 id="84-审核记录类型"><a class="markdownIt-Anchor" href="#84-审核记录类型"></a> 8.4 审核记录类型</h2>
<p><a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/sec-Audit_Record_Types">B.2. 审核记录类型</a></p>
<h1 id="9-内建"><a class="markdownIt-Anchor" href="#9-内建"></a> 9 内建</h1>
<h2 id="91-shift"><a class="markdownIt-Anchor" href="#91-shift"></a> 9.1 shift</h2>
<p>shift用于移动参数的位置</p>
<p><strong>格式：</strong></p>
<ul>
<li><code>shift [n]</code>：n是数字，默认是1</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="built_in">set</span> -- a b c d</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> <span class="comment"># 输出a</span></span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> <span class="comment"># 输出b</span></span><br><span class="line"><span class="built_in">shift</span> 2</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> <span class="comment"># 输出d</span></span><br></pre></td></tr></table></figure>
<h2 id="92-eval"><a class="markdownIt-Anchor" href="#92-eval"></a> 9.2 eval</h2>
<p>通过连接参数构造命令，如果包含间接引用，也会保持原有语义，下面以一个例子来说明</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo=10 x=foo</span><br><span class="line">y=<span class="string">&#x27;$&#x27;</span><span class="variable">$x</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$y</span> <span class="comment"># 输出foo</span></span><br><span class="line"><span class="built_in">eval</span> y=<span class="string">&#x27;$&#x27;</span><span class="variable">$x</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$y</span> <span class="comment"># 输出10</span></span><br></pre></td></tr></table></figure>
<h2 id="93-set"><a class="markdownIt-Anchor" href="#93-set"></a> 9.3 set</h2>
<p><strong>格式：</strong></p>
<ul>
<li><code>set [option]</code></li>
</ul>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>-e</code>：当任意一个命令的返回值为非0时，立即退出</li>
<li><code>-x</code>：将每个命令及其详细参数输出到标准输出中</li>
<li><code>-o pipefail</code>：针对管道命令，取从右往左第一个非零返回值作为整个管道命令的返回值</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><code>set -e</code></li>
<li><code>set -x</code></li>
<li><code>set -o pipefail</code></li>
<li><code>eval set -- &quot;some new params&quot;</code>：设置当前shell的参数</li>
</ul>
<h2 id="94-exec"><a class="markdownIt-Anchor" href="#94-exec"></a> 9.4 exec</h2>
<p><code>exec</code>用于进程替换（类似系统调用<code>exec</code>），或者标准输入输出的重定向</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>exec 1&gt;my.log 2&gt;&amp;1</code>：将标准输出、以及标准异常重定向到my.log文件中，对后续的所有命令都生效</li>
</ul>
<h2 id="95-shopt"><a class="markdownIt-Anchor" href="#95-shopt"></a> 9.5 shopt</h2>
<p>用于启用/禁用shell扩展功能</p>
<p><strong>示例：</strong></p>
<ul>
<li><code>shopt -s extglob</code>：启用<code>extglob</code></li>
<li><code>shopt -u extglob</code>：禁用<code>extglob</code></li>
</ul>
<h1 id="10-包管理工具"><a class="markdownIt-Anchor" href="#10-包管理工具"></a> 10 包管理工具</h1>
<h2 id="101-yum"><a class="markdownIt-Anchor" href="#101-yum"></a> 10.1 yum</h2>
<p><strong>示例：</strong></p>
<ul>
<li><code>yum list docker-ce --showduplicates | sort -r</code>：查询软件的版本信息</li>
</ul>
<!--

**格式：**

* `find [文件路径] [option] [action]`

**参数说明：**

* `-name`：后接文件名，支持通配符。**注意匹配的是相对路径**

**示例：**

* `find . -name "*.c"`

-->
<h1 id="11-参考"><a class="markdownIt-Anchor" href="#11-参考"></a> 11 参考</h1>
<ul>
<li>《鸟哥的Linux私房菜》</li>
<li><a target="_blank" rel="noopener" href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/index.html">Linux Tools Quick Tutorial</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengmo/archive/2010/10/04/1842073.html">linux shell awk 流程控制语句（if,for,while,do)详细介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengmo/archive/2010/10/11/1847772.html">awk 正则表达式、正则运算符详细介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/gatieme/article/details/52777721">解决Linux关闭终端(关闭SSH等)后运行的程序自动停止</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ftl1012/p/ss.html">Linux ss命令详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.hi-linux.com/posts/61543.html">Socat 入门教程</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuruixn/article/details/8210760">Linux 流量控制工具 TC 详解</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31265993/docker-networking-namespace-not-visible-in-ip-netns-list">docker networking namespace not visible in ip netns list</a></li>
<li><a target="_blank" rel="noopener" href="http://linux-ip.net/html/">Guide to IP Layer Network Administration with Linux</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jellythink.com/archives/469">Linux ip命令详解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangjianno2/article/details/72853735">linux中路由策略rule和路由表table</a></li>
<li><a target="_blank" rel="noopener" href="https://serverfault.com/questions/63014/ip-address-scope-parameter">ip address scope parameter</a></li>
<li><a target="_blank" rel="noopener" href="http://linux-ip.net/html/tools-ip-route.html">Displaying a routing table with ip route show</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/10259266/what-does-proto-kernel-means-in-unix-routing-table">What does “proto kernel” means in Unix Routing Table?</a></li>
<li><a target="_blank" rel="noopener" href="http://linux-ip.net/html/routing-tables.html">Routing Tables</a></li>
<li><a target="_blank" rel="noopener" href="https://superuser.com/questions/454907/how-to-execute-a-command-in-screen-and-detach">How to execute a command in screen and detach?</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yoo2767/p/6016300.html">Linux使echo命令输出结果带颜色</a></li>
<li><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/32908/how-to-insert-the-content-of-a-file-into-another-file-before-a-pattern-marker">How to insert the content of a file into another file before a pattern (marker)?</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16715373/insert-contents-of-a-file-after-specific-pattern-match">Insert contents of a file after specific pattern match</a></li>
<li><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/285644/how-can-i-copy-a-hidden-directory-recursively-and-preserving-its-permissions">How can I copy a hidden directory recursively and preserving its permissions?</a></li>
<li><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/77127/rm-rf-all-files-and-all-hidden-files-without-error">rm -rf all files and all hidden files without . &amp; … error</a></li>
<li><a target="_blank" rel="noopener" href="https://plantegg.github.io/2018/01/01/%E9%80%9A%E8%BF%87tcpdump%E5%AF%B9Unix%20Socket%20%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85%E8%A7%A3%E6%9E%90/">通过tcpdump对Unix Domain Socket 进行抓包解析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tangxiaosheng/p/4950055.html">tcpdump 选项及过滤规则</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/48ca58e55077">如何知道进程运行在哪个 CPU 内核上？</a></li>
<li><a target="_blank" rel="noopener" href="https://serverfault.com/questions/373871/dont-understand-00-iptable-syntax">Don’t understand [0:0] iptable syntax</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/magerguo/article/details/81052106">Linux iptables drop日志记录</a></li>
<li><a target="_blank" rel="noopener" href="https://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html">Iptables 指南 1.1.19</a></li>
<li><a target="_blank" rel="noopener" href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/sec-defining_audit_rules_and_controls">redhat-安全性指南-定义审核规则</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c2e2b8f8ea0d">addr2line</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16056135/how-to-use-openssl-to-encrypt-decrypt-files">How to use OpenSSL to encrypt/decrypt files?</a></li>
<li><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/117414/confusion-about-mount-options">confusion about mount options</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22194920">在Linux下做性能分析3：perf</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%91%98%E5%BD%95/" rel="tag"># 摘录</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/" rel="prev" title="操作系统内存管理详解">
      <i class="fa fa-chevron-left"></i> 操作系统内存管理详解
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/08/15/Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" rel="next" title="Linux-文件系统">
      Linux-文件系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-livere">livere</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzY0My8xMDE5OA=="></div>
  </div>
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF"><span class="nav-text"> 1 系统信息</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-uname"><span class="nav-text"> 1.1 uname</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-chsh"><span class="nav-text"> 1.2 chsh</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-man"><span class="nav-text"> 1.3 man</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-demsg"><span class="nav-text"> 1.4 demsg</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-last"><span class="nav-text"> 1.5 last</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-w"><span class="nav-text"> 1.6 w</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-useradd"><span class="nav-text"> 1.7 useradd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-usermod"><span class="nav-text"> 1.8 usermod</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-passwd"><span class="nav-text"> 1.9 passwd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#110-readelf"><span class="nav-text"> 1.10 readelf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#111-getconf"><span class="nav-text"> 1.11 getconf</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%B8%B8%E7%94%A8%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7"><span class="nav-text"> 2 常用处理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#21-echo"><span class="nav-text"> 2.1 echo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-sed"><span class="nav-text"> 2.2 sed</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-awk"><span class="nav-text"> 2.3 awk</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#231-%E5%9C%A8awk%E4%B8%AD%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F"><span class="nav-text"> 2.3.1 在awk中引用变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#232-%E5%9C%A8awk%E4%B8%AD%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5"><span class="nav-text"> 2.3.2 在awk中写简单的控制流语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#233-%E5%9C%A8awk%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text"> 2.3.3 在awk中使用正则表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-cut"><span class="nav-text"> 2.4 cut</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-grep"><span class="nav-text"> 2.5 grep</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-sort"><span class="nav-text"> 2.6 sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-uniq"><span class="nav-text"> 2.7 uniq</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-tr"><span class="nav-text"> 2.8 tr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-xargs"><span class="nav-text"> 2.9 xargs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#210-tee"><span class="nav-text"> 2.10 tee</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#211-cat"><span class="nav-text"> 2.11 cat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#212-find"><span class="nav-text"> 2.12 find</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#213-locate"><span class="nav-text"> 2.13 locate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#214-cp"><span class="nav-text"> 2.14 cp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#215-rm"><span class="nav-text"> 2.15 rm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#216-tar"><span class="nav-text"> 2.16 tar</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#217-wget"><span class="nav-text"> 2.17 wget</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#218-tree"><span class="nav-text"> 2.18 tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#219-split"><span class="nav-text"> 2.19 split</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#220-base64"><span class="nav-text"> 2.20 base64</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#221-md5sum"><span class="nav-text"> 2.21 md5sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#222-openssl"><span class="nav-text"> 2.22 openssl</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#223-bc"><span class="nav-text"> 2.23 bc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#224-dirname"><span class="nav-text"> 2.24 dirname</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#225-addr2line"><span class="nav-text"> 2.25 addr2line</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#226-objdump"><span class="nav-text"> 2.26 objdump</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="nav-text"> 3 设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#31-mount"><span class="nav-text"> 3.1 mount</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#311-%E4%BC%A0%E6%92%AD%E7%BA%A7%E5%88%AB"><span class="nav-text"> 3.1.1 传播级别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-umount"><span class="nav-text"> 3.2 umount</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-findmnt"><span class="nav-text"> 3.3 findmnt</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-free"><span class="nav-text"> 3.4 free</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-swap"><span class="nav-text"> 3.5 swap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-df"><span class="nav-text"> 3.6 df</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-du"><span class="nav-text"> 3.7 du</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-lsblk"><span class="nav-text"> 3.8 lsblk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-lsusb"><span class="nav-text"> 3.9 lsusb</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#310-lspci"><span class="nav-text"> 3.10 lspci</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#311-sync"><span class="nav-text"> 3.11 sync</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-text"> 4 进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#41-jobs"><span class="nav-text"> 4.1 jobs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-fg"><span class="nav-text"> 4.2 fg</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-bg"><span class="nav-text"> 4.3 bg</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-kill"><span class="nav-text"> 4.4 kill</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-pkill"><span class="nav-text"> 4.5 pkill</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-ps"><span class="nav-text"> 4.6 ps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-pgrep"><span class="nav-text"> 4.7 pgrep</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-pstree"><span class="nav-text"> 4.8 pstree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49-pstack"><span class="nav-text"> 4.9 pstack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#410-taskset"><span class="nav-text"> 4.10 taskset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#411-su"><span class="nav-text"> 4.11 su</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#412-sudo"><span class="nav-text"> 4.12 sudo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#413-pkexec"><span class="nav-text"> 4.13 pkexec</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#414-nohup"><span class="nav-text"> 4.14 nohup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#415-screen"><span class="nav-text"> 4.15 screen</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86"><span class="nav-text"> 5 网络管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#51-netstat"><span class="nav-text"> 5.1 netstat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-tc"><span class="nav-text"> 5.2 tc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-lsof"><span class="nav-text"> 5.3 lsof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54-ss"><span class="nav-text"> 5.4 ss</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55-ip"><span class="nav-text"> 5.5 ip</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#551-ip-address"><span class="nav-text"> 5.5.1 ip address</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#552-ip-link"><span class="nav-text"> 5.5.2 ip link</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#553-ip-route"><span class="nav-text"> 5.5.3 ip route</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5531-route-table"><span class="nav-text"> 5.5.3.1 route table</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5532-route-type"><span class="nav-text"> 5.5.3.2 route type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5533-route-scope"><span class="nav-text"> 5.5.3.3 route scope</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5534-route-proto"><span class="nav-text"> 5.5.3.4 route proto</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5535-route-src"><span class="nav-text"> 5.5.3.5 route src</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5536-%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A"><span class="nav-text"> 5.5.3.6 参数解释</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#554-ip-rule"><span class="nav-text"> 5.5.4 ip rule</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#555-ip-netns"><span class="nav-text"> 5.5.5 ip netns</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56-iptables"><span class="nav-text"> 5.6 iptables</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#561-%E8%A7%84%E5%88%99%E7%9A%84%E6%9F%A5%E7%9C%8B"><span class="nav-text"> 5.6.1 规则的查看</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#562-%E8%A7%84%E5%88%99%E7%9A%84%E6%B8%85%E9%99%A4"><span class="nav-text"> 5.6.2 规则的清除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#563-%E5%AE%9A%E4%B9%89%E9%BB%98%E8%AE%A4%E7%AD%96%E7%95%A5"><span class="nav-text"> 5.6.3 定义默认策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#564-%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AF%B9%E6%AF%94ip-%E7%BD%91%E7%BB%9C%E5%8F%8A%E6%8E%A5%E5%8F%A3%E8%AE%BE%E5%A4%87"><span class="nav-text"> 5.6.4 数据包的基础对比：IP、网络及接口设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#565-tcp-udp%E7%9A%84%E8%A7%84%E5%88%99%E9%92%88%E5%AF%B9%E7%AB%AF%E5%8F%A3%E8%AE%BE%E7%BD%AE"><span class="nav-text"> 5.6.5 TCP、UDP的规则：针对端口设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#566-iptables%E5%8C%B9%E9%85%8D%E6%89%A9%E5%B1%95"><span class="nav-text"> 5.6.6 iptables匹配扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#567-iptables%E7%9B%AE%E6%A0%87%E6%89%A9%E5%B1%95"><span class="nav-text"> 5.6.7 iptables目标扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#568-icmp%E6%95%B0%E6%8D%AE%E5%8C%85%E8%A7%84%E5%88%99%E7%9A%84%E6%AF%94%E5%AF%B9%E9%92%88%E5%AF%B9%E6%98%AF%E5%90%A6%E5%93%8D%E5%BA%94ping%E6%9D%A5%E8%AE%BE%E8%AE%A1"><span class="nav-text"> 5.6.8 ICMP数据包规则的比对：针对是否响应ping来设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#57-bridge"><span class="nav-text"> 5.7 bridge</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#571-bridge-link"><span class="nav-text"> 5.7.1 bridge link</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#572-bridge-fdb"><span class="nav-text"> 5.7.2 bridge fdb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#573-bridge-mdb"><span class="nav-text"> 5.7.3 bridge mdb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#574-bridge-vlan"><span class="nav-text"> 5.7.4 bridge vlan</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#575-bridge-monitor"><span class="nav-text"> 5.7.5 bridge monitor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58-route"><span class="nav-text"> 5.8 route</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59-nsenter"><span class="nav-text"> 5.9 nsenter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#510-tcpdump"><span class="nav-text"> 5.10 tcpdump</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5101-tcpdump%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text"> 5.10.1 tcpdump条件表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5102-tips"><span class="nav-text"> 5.10.2 tips</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5103-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tcpdump%E6%8A%93dockerd%E7%9A%84http%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-text"> 5.10.3 如何使用tcpdump抓dockerd的http协议的数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#511-tcpkill"><span class="nav-text"> 5.11 tcpkill</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#512-socat"><span class="nav-text"> 5.12 socat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#513-dhclient"><span class="nav-text"> 5.13 dhclient</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#514-arp"><span class="nav-text"> 5.14 arp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#515-arp-scan"><span class="nav-text"> 5.15 arp-scan</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#516-ping"><span class="nav-text"> 5.16 ping</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#517-arping"><span class="nav-text"> 5.17 arping</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#518-hping3"><span class="nav-text"> 5.18 hping3</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E8%BF%90%E7%BB%B4%E7%9B%91%E6%8E%A7"><span class="nav-text"> 6 运维监控</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#61-ssh"><span class="nav-text"> 6.1 ssh</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#611-%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95"><span class="nav-text"> 6.1.1 免密登录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#612-%E7%A6%81%E6%AD%A2%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95"><span class="nav-text"> 6.1.2 禁止密码登录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-scp"><span class="nav-text"> 6.2 scp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63-watch"><span class="nav-text"> 6.3 watch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-top"><span class="nav-text"> 6.4 top</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#65-slabtop"><span class="nav-text"> 6.5 slabtop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#66-sar"><span class="nav-text"> 6.6 sar</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#67-tsar"><span class="nav-text"> 6.7 tsar</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#68-vmstat"><span class="nav-text"> 6.8 vmstat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#69-mpstat"><span class="nav-text"> 6.9 mpstat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#610-iostat"><span class="nav-text"> 6.10 iostat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#611-dstat"><span class="nav-text"> 6.11 dstat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#612-ifstat"><span class="nav-text"> 6.12 ifstat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#613-pidstat"><span class="nav-text"> 6.13 pidstat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#614-nethogs"><span class="nav-text"> 6.14 nethogs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#615-iptraf"><span class="nav-text"> 6.15 iptraf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#616-iftop"><span class="nav-text"> 6.16 iftop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#617-iotop"><span class="nav-text"> 6.17 iotop</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="nav-text"> 7 性能分析工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#71-strace"><span class="nav-text"> 7.1 strace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72-perf"><span class="nav-text"> 7.2 perf</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-audit"><span class="nav-text"> 8 audit</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#81-%E6%9E%B6%E6%9E%84"><span class="nav-text"> 8.1 架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#82-auditctl"><span class="nav-text"> 8.2 auditctl</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#821-%E6%8E%A7%E5%88%B6%E8%A7%84%E5%88%99"><span class="nav-text"> 8.2.1 控制规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#822-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%A7%84%E5%88%99"><span class="nav-text"> 8.2.2 文件系统规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#823-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-text"> 8.2.3 系统调用规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#83-ausearch"><span class="nav-text"> 8.3 ausearch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#84-%E5%AE%A1%E6%A0%B8%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 8.4 审核记录类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E5%86%85%E5%BB%BA"><span class="nav-text"> 9 内建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#91-shift"><span class="nav-text"> 9.1 shift</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#92-eval"><span class="nav-text"> 9.2 eval</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#93-set"><span class="nav-text"> 9.3 set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#94-exec"><span class="nav-text"> 9.4 exec</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#95-shopt"><span class="nav-text"> 9.5 shopt</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="nav-text"> 10 包管理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#101-yum"><span class="nav-text"> 10.1 yum</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E5%8F%82%E8%80%83"><span class="nav-text"> 11 参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liuyehcf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Liuyehcf</p>
  <div class="site-description" itemprop="description">大音希声，大象无形</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">322</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">120</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liuyehcf</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qhEhLuMeMOy1zgcBhkqUS6P8-gzGzoHsz',
      appKey     : 'uhkruDLNLNdL5rQjRBY2X9Ke',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
