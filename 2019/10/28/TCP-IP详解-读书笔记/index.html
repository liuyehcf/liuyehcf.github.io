<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="阅读更多">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP-IP详解-读书笔记">
<meta property="og:url" content="http://example.com/2019/10/28/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Liuye Notebook">
<meta property="og:description" content="阅读更多">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-2-1.jpg">
<meta property="og:image" content="http://example.com/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-2-2.jpg">
<meta property="og:image" content="http://example.com/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-2-3.jpg">
<meta property="og:image" content="http://example.com/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-2-4.jpg">
<meta property="og:image" content="http://example.com/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-5-1.jpg">
<meta property="og:image" content="http://example.com/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-5-2.jpg">
<meta property="og:image" content="http://example.com/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-6-1.jpg">
<meta property="og:image" content="http://example.com/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/14-3-1.jpg">
<meta property="og:image" content="http://example.com/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/14-3-2.jpg">
<meta property="og:image" content="http://example.com/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/flow_control.jpeg">
<meta property="og:image" content="http://example.com/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/cwnd.png">
<meta property="article:published_time" content="2019-10-28T09:46:22.000Z">
<meta property="article:modified_time" content="2021-12-25T05:46:06.746Z">
<meta property="article:author" content="Liuyehcf">
<meta property="article:tag" content="摘录">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-2-1.jpg">

<link rel="canonical" href="http://example.com/2019/10/28/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>TCP-IP详解-读书笔记 | Liuye Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Liuye Notebook</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-explore">

    <a href="/explore/" rel="section"><i class="fa fa-sitemap fa-fw"></i>发现</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/10/28/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Liuyehcf">
      <meta itemprop="description" content="大音希声，大象无形">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liuye Notebook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TCP-IP详解-读书笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-28 17:46:22" itemprop="dateCreated datePublished" datetime="2019-10-28T17:46:22+08:00">2019-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-25 13:46:06" itemprop="dateModified" datetime="2021-12-25T13:46:06+08:00">2021-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          
            <span id="/2019/10/28/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="TCP-IP详解-读书笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/28/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/28/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>阅读更多</strong></p>
<a id="more"></a>
<h1 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1 概述</h1>
<ol>
<li><strong>网桥</strong>是在<strong>链路层</strong>对网络进行互连，而<strong>路由器</strong>则是在<strong>网络层</strong>上对网络进行互连</li>
<li><code>ICMP</code>是<code>IP</code>的附属协议，<code>IP</code>层用它来与其他主机或路由器交换错误报文和其他重要信息</li>
<li>为<code>ICMP</code>、<code>IGMP</code>、<code>ARP</code>、<code>RARP</code>协议定位是比较棘手的，在不同的场景下可以位于不同的网络层级</li>
</ol>
<h1 id="2-链路层"><a class="markdownIt-Anchor" href="#2-链路层"></a> 2 链路层</h1>
<ol>
<li>在<code>TCP/IP</code>协议簇中，链路层主要有三个目的
<ul>
<li>为<code>IP</code>模块发送和接收<code>IP</code>数据报</li>
<li>为<code>ARP</code>模块发送<code>ARP</code>请求和接收<code>ARP</code>应答</li>
<li>为<code>RARP</code>发送<code>RARP</code>请求和接收<code>RARP</code>应答</li>
</ul>
</li>
<li>几个不同的标准集
<ul>
<li><code>802.3</code>：整个<code>CSMA/CD</code>网络（Carrier Sense, Multiple Access with Collision Detection）</li>
<li><code>802.4</code>：针对令牌总线网络</li>
<li><code>802.5</code>：针对令牌环网络</li>
</ul>
</li>
<li><code>802.3</code>标准定义的帧和以太网的帧都有最小长度要求。<code>802.3</code>规定<strong>数据部分</strong>必须至少为38字节，而对于以太网，则要求最少要有46字节（这是为什么？）。为了保证这一点，必须在不足的空间插入填充字节</li>
<li>大多数的产品都支持环回接口（Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信</li>
<li>以太网和<code>802.3</code>对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特性称为<code>MTU</code>，最大传输单元。如果<code>IP</code>层有一个数据报要传，且数据报的长度比链路层的<code>MTU</code>还大，那么<code>IP</code>层就需要进行分片</li>
<li>两台主机之间的通信如果经过多个网络，那么每个网络的链路层可能有不同的<code>MTU</code>，在这多个网络中，具有的最小<code>MTU</code>称作路径<code>MTU</code></li>
<li>两台主机之间的<code>MTU</code>不一定是个常数，它取决于当时所选择的路由，而选路不一定是对称的，因此路径<code>MTU</code>在两个方向上不一定是一致的</li>
<li>网络地址划分
<ul>
<li>A类地址：0.0.0.0 -&gt; 127.255.255.255</li>
<li>B类地址：128.0.0.0 -&gt; 191.255.255.255</li>
<li>C类地址：192.0.0.0 -&gt; 223.255.255.255</li>
<li>D类地址：224.0.0.0 -&gt; 239.255.255.255</li>
<li>E类地址：240.0.0.0 -&gt; 255.255.255.255</li>
</ul>
</li>
</ol>
<h1 id="3-网际协议"><a class="markdownIt-Anchor" href="#3-网际协议"></a> 3 网际协议</h1>
<ol>
<li><code>IP</code>提供不可靠、无连接的数据报传送服务
<ul>
<li>不可靠：不保证<code>IP</code>数据报能成功到达目的地。<code>IP</code>仅能提供尽力而为的传输服务</li>
<li>无连接：<code>IP</code>并不维护任何关于后续数据报的状态信息，每个数据报的处理是独立的，也就是说，<code>IP</code>数据报可以不按发送顺序接收（每个数据报的选路是独立的）</li>
</ul>
</li>
<li><code>IP</code>协议格式
<ul>
<li>4位版本、4位首部长度、8位服务类型（TOS）、16位总长度（字节数）</li>
<li>16位标志、3位标志、13位片偏移</li>
<li>8位生存时间、8位协议、16位首部校验和</li>
<li>32位源IP地址</li>
<li>32位目的IP地址</li>
<li>选项</li>
<li>数据</li>
</ul>
</li>
<li>目前协议版本号是4，因此<code>IP</code>有时也称为<code>IPv4</code></li>
<li>首部长度指的是首部占<code>32bit字</code>的数目（32bit记为一份），由于这是一个4bit字段（0-15），因此首部最长为 <code>15*32bit=480bit=60Byte</code></li>
<li><code>TOS</code>字段包括一个3bit的优先权子字段（现已被忽略）、4bit的<code>TOS</code>子字段、1bit的未用字段（必须置0）。其中，4bit的<code>TOS</code>子字段分别代表
<ul>
<li>最小时延（0x10）</li>
<li>最大吞吐量（0x08）</li>
<li>最高可靠性（0x04）</li>
<li>最小费用（0x02）</li>
<li>一般服务（0x00）</li>
</ul>
</li>
<li>总长度字段是指整个<code>IP</code>数据报的长度，以字节为单位（区别于首部长度，首部长度的单位是32bit，也就是4字节），由于该字段长度为16bit，所以<code>IP</code>数据报最长可达65535字节</li>
<li><code>TTL</code>（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数，<code>TTL</code>的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，他的值就会减去1。当该字段的值为0时，数据报就被丢弃，并发送<code>ICMP</code>报文通知源主机</li>
<li>首部检验和字段是根据IP首部计算的检验和码，他不对首部后面的数据进行计算。<code>ICMP</code>、<code>IGMP</code>、<code>UDP</code>和<code>TCP</code>在它们各自的首部中均含有同时覆盖首部和数据的检验和码</li>
<li>最后一个字段是任选项，是数据报中的一个可变长的可选信息，这些选项定义如下（这些选项很少使用，并非所有主机和路由器都支持，且选项都是以32bit作为界限，在必要时需要插入0填充，这样就保证了<code>IP</code>首部始终是32bit的整数倍）
<ul>
<li>安全和处理限制</li>
<li>记录路径</li>
<li>时间戳</li>
<li>宽松的源站选路</li>
<li>严格的源站选路</li>
</ul>
</li>
<li><code>IP</code>层既可以配置成路由器的功能，也可以配置成主机的功能。本质的区别在于主机从不把数据报从一个接口转发到另一个接口，而路由器则要转发数据报</li>
<li>路由表包含如下信息
<ul>
<li>目的<code>IP</code>地址，既可以是一个完整的主机地址，也可以是一个网络地址</li>
<li>下一站路由器的<code>IP</code>地址，指一个在直接相连网络上的路由器</li>
<li>标志，其中一个标志标明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器还是一个直接相连的接口</li>
<li>为数据报传输指定一个网络接口</li>
</ul>
</li>
<li><code>IP</code>路由器主要完成如下功能
<ul>
<li>搜索路由表，寻找能与目的<code>IP</code>地址完全匹配的表目</li>
<li>搜索路由表，寻找能与目的网络号相匹配的表目</li>
<li>搜索路由表，寻找标为默认（default）的路由表</li>
</ul>
</li>
<li>现在所有的主机都要求支持子网编址，不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号。这样做的原因是A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数太多了</li>
<li>通常把B类地址留给主机的16bit中的前8bit作为子网地址，后8bit作为主机号</li>
<li>子网对外部路由器来说隐藏了内部网络组织，但是对子网内部的路由器来说是不透明的（与30个C类地址相比，用一个包含30个子网的B类地址的好处是可以减小路由表的规模）</li>
<li>子网掩码用来确定多少bit用于子网号，多少bit用于主机号（网络号的划分是明确的，而子网的划分是不明确的），其中值为1的bit表示网络号和子网号，为0的bit用于主机号</li>
<li>给定IP和子网掩码后，主机就可以确定IP数据报的目的地，根据IP可以确定网络号和子网号的分界线，根据子网掩码可以确定子网号和主机号的分界线
<ul>
<li>本子网上的主机</li>
<li>本网络中其他子网中的主机</li>
<li>其他网络上的主机</li>
</ul>
</li>
</ol>
<h1 id="4-arp-地址解析协议"><a class="markdownIt-Anchor" href="#4-arp-地址解析协议"></a> 4 ARP: 地址解析协议</h1>
<ol>
<li>链路层如以太网或令牌环网都有自己的寻址机制（通常为48bit），这是使用链路层的任何网络都必须遵从的
<ul>
<li>例如，一组使用<code>TCP/IP</code>协议的主机和另一组使用某种PC网络软件的主机可以共享相同的电缆</li>
</ul>
</li>
<li>当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据48bit的以太网地址来确定目的接口的。设备驱动程序从不检查<code>IP</code>数据报中的目的<code>IP</code>地址</li>
<li>地址解析为这两种不同的地址形式提供映射：32bit的<code>IP</code>地址和数据链路层使用的任何类型的地址
<ul>
<li>ARP为IP地址到对应的硬件地址之间提供动态映射，动态是指这个过程是自动完成的，一般用户和管理员无需关心</li>
</ul>
</li>
<li><strong>ARP背后有一个基本概念，那就是网络接口有一个硬件地址（一个48bit的值，标识不同的以太网或令牌环网接口）。在硬件层次上进行的数据帧交换必须有正确的接口地址。知道主机的IP并不能让内核发送一帧数据给主机。内核（如以太网驱动程序）必须知道目的端的硬件地址才能发送数据。ARP的功能是在32bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射</strong></li>
<li>ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Internet地址到硬件地址之间的映射记录。高速缓存中每一项的生存时间一般为20分钟
<ul>
<li><code>arp -a</code>可以查看高速缓存中的内容</li>
</ul>
</li>
<li>对于一个<code>IP</code>数据报，如果目的主机在本网络上（如以太网、令牌环网或点对点链接的另一端），那么<code>IP</code>数据报可以直接发送到目的主机上。如果目的主机在一个远程网络上，那么就通过<code>IP</code>选路函数来确定位于本地网络上的下一站路由器地址，并让它转发<code>IP</code>数据报。这两种情况下，<code>IP</code>数据报都是被送到本地网络上的一台主机或路由器（假定是以太网）
<ul>
<li><code>ARP</code>发送一份称为<code>ARP</code>请求的以太网数据帧给以太网上的每个主机。这个过程称作广播。<code>ARP</code>请求中包含目的主机的IP地址。该请求的意思是：如果你是这个IP地址的拥有者，请回答你的硬件地址</li>
<li>目的主机的<code>ARP</code>层收到这份广播报文后，识别出这是发送端在询问它的IP地址，于是发送一个<code>ARP</code>应答，这个<code>ARP</code>应答包含IP地址及对应的硬件地址</li>
<li>收到<code>ARP</code>应答后，使<code>ARP</code>进行请求-应答交换的IP数据报现在就可以传送了</li>
<li>发送IP数据报道目的主机</li>
</ul>
</li>
<li>直到<code>ARP</code>应答返回时，<code>TCP</code>报文才会被发送，因此对不存在的主机发送<code>TCP</code>报文，在链路上是看不到任何<code>TCP</code>数据的，但是会触发<code>TCP</code>的重传机制</li>
<li><code>ARP</code>代理：如果<code>ARP</code>请求是从一个网络的主机发往另一个网络的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称为<code>ARP</code>代理（<code>Proxy ARP</code>）</li>
<li>免费ARP：是指主机发送ARP查找自己的IP地址，通常它发生在系统引导期间进行接口配置的时候
<ul>
<li>一个主机可以通过它来确定另一个主机是否设置了相同的IP地址</li>
<li>使其他主机高速缓存中旧的硬件地址进行相应的更新（当某个主机更换了网卡接口的时候）。当某个主机收到了某个IP地址的ARP请求，而且它已经在接受者的高速缓存中，那么就要用ARP请求中的发送端硬件地址对高速缓存中相应的内容进行更新</li>
</ul>
</li>
</ol>
<h1 id="5-rarp-逆地址解析协议"><a class="markdownIt-Anchor" href="#5-rarp-逆地址解析协议"></a> 5 RARP: 逆地址解析协议</h1>
<ol>
<li>具有本地磁盘的系统引导时，一般从磁盘上的配置文件中读取<code>IP</code>地址。但是无盘机，需要采用其他方法来获得<code>IP</code>地址，这种方式就是<code>RARP</code></li>
<li>网络上的每个系统都有唯一的硬件地址，然后发送一份<code>RARP</code>请求，请求某个主机响应该误判系统的<code>IP</code>地址</li>
</ol>
<h1 id="6-icmp-internet控制报文协议"><a class="markdownIt-Anchor" href="#6-icmp-internet控制报文协议"></a> 6 ICMP: Internet控制报文协议</h1>
<h1 id="7-防火墙和网络地址转换"><a class="markdownIt-Anchor" href="#7-防火墙和网络地址转换"></a> 7 防火墙和网络地址转换</h1>
<h2 id="71-防火墙"><a class="markdownIt-Anchor" href="#71-防火墙"></a> 7.1 防火墙</h2>
<ol>
<li>最常用的两种防火墙是<code>代理防火墙（proxy firewall）和包过滤防火墙（packet-filter）</code>。他们之间的主要区别是所操作的协议栈的层次以及由此决定IP地址和端口号的使用</li>
</ol>
<h3 id="711-包过滤防火墙"><a class="markdownIt-Anchor" href="#711-包过滤防火墙"></a> 7.1.1 包过滤防火墙</h3>
<ol>
<li>包过滤防火墙能够过滤（filter）（丢弃）一些网络流量。他们一般都可以配置为丢弃或转发数据包头中符合（或不符合）特定标准的数据报，这些标准称为过滤器（filter）</li>
<li>包过滤防火墙可以看做一个互联网路由器</li>
</ol>
<h3 id="712-代理防火墙"><a class="markdownIt-Anchor" href="#712-代理防火墙"></a> 7.1.2 代理防火墙</h3>
<ol>
<li>代理防火墙，并不是真正意义上的互联网路由器。相反，它们本质上是运行一个或多个应用层网关（Application-Layer Gateways, ALG）的主机。该主机拥有多个网络接口，能够在应用层中继两个连接（或关联）之间的特定类型的流量</li>
</ol>
<h1 id="8-tcp-传输控制协议初步"><a class="markdownIt-Anchor" href="#8-tcp-传输控制协议初步"></a> 8 TCP: 传输控制协议（初步）</h1>
<p><strong>ARP和重传</strong></p>
<ol>
<li>Automatic Repeat Request, ARQ: 自从重复请求，是差错处理的一种非常重要的方法</li>
<li>一个直接处理分组丢失（和比特差错）的方法是重发分组直到它被正确接收。这需要一个方法来判断，如下：
<ul>
<li>接收方是否已收到分组</li>
<li>接收方收到的分组是否与之前发送方发送的一样</li>
<li>接收方给发送方发信号以确认自己已经接收到一个分组，这种方法称为确认（acknowledgment），或<code>ACK</code>。当发送方接收到这个<code>ACK</code>，它再发送另一个分组，这个过程就这样继续，但是会出现一些有意思的问题
<ol>
<li>发送方对一个<code>ACK</code>应该等待多长时间？</li>
<li>如果<code>ACK</code>丢失了怎么办？</li>
<li>如果分组被接收到了，但是里面有错怎么办？</li>
</ol>
</li>
</ul>
</li>
<li>接收方可能受到被传送分组的重复副本，这个问题要使用序列号（sequence number）来处理</li>
</ol>
<p><strong>分组窗口和滑动窗口</strong></p>
<ol>
<li>分组窗口（window）：已被发送方注入但还没完成确认的分组的集合。这个窗口中的分组数量称为窗口大小（window size）
<ul>
<li>术语窗口来自这样的想法：如果你把在一个通信对话中发送的所有分组排成长长的一行，但只能通过一个小孔来观察它们，你就只能看到它们的一个自己—通过一个窗口观看一样</li>
</ul>
</li>
<li>当分组窗口中最左边的分组已收到<code>ACK</code>之后，窗口左侧的边界便可向右移动一格；窗口原右侧边界之外的第一个分组可以进入发送状态，随机进入分组窗口中，于是窗口的右侧边界便可向右移动一格，这便形成了分组窗口的滑动</li>
</ol>
<p><strong>变量窗口：流量控制和拥塞控制</strong></p>
<ol>
<li>流量控制：用于解决当接收方相对发送方处理速度太慢时产生的问题，具体手段就是强迫发送方慢下来</li>
<li>基于速率（rate-based）流量控制：给发送方指定某个速率，同时确保数据永远不能超过这个速率发送。这种类型的流量控制最适合流应用程序，可被用于广播和组播发现</li>
<li>基于窗口（window-based）流量控制：窗口大小是不固定的，而且允许随时间而变动
<ul>
<li>必须有一种方法可以通知发送方使用多大的窗口，一般称为窗口通告（window advertisement）或者窗口更新（window update）</li>
</ul>
</li>
<li>拥塞控制：发送方减低速度以不至于压垮其与接收方之间的网络</li>
</ol>
<p><strong>设置重传超时</strong></p>
<ol>
<li>发送方在重发一个分组之前应等待的时间量大概是下面时间的总和
<ol>
<li>发送分组所用的时间</li>
<li>接收方处理它和发送一个<code>ACK</code>所用的时间</li>
<li><code>ACK</code>返回到发送方所用的时间</li>
<li>以及发送方处理<code>ACK</code>所用的时间</li>
</ol>
<ul>
<li>遗憾的是，上述这些时间没有一个是固定不变的，都是随着环境的变化而变化的</li>
</ul>
</li>
<li>一个更好的策略是让协议实现尝试去估计这个重传超时时间，这称为往返时间估计（<code>round-trip-time estimation, RTT</code>），这是一个统计过程。总的来说，选择一组<code>RTT</code>样本的样本均值作为真实的<code>RTT</code>是最有可能的，这个平均值很自然地会随着时间而改变，因为通信穿过的网络路径可能会改变</li>
<li>把重传超时时间设置为<code>RTT</code>均值是不合理的，因为很有可能许多实际的<code>RTT</code>将会比较大，从而会导致不必要的重传</li>
</ol>
<p><strong>TCP服务模型</strong></p>
<ol>
<li>TCP和UDP使用相同的网络层（IPv4或IPv6），但是TCP给应用程序提供了一种与UDP完全不同的服务。<strong>TCP提供了一种面向连接的（connection-oriented）、可靠的字节流服务</strong>。</li>
<li>面向连接的：是指使用TCP的两个应用程序必须在它们可能交换数据之前，通过相互联系来建立一个TCP连接、就好像拨打一个电话号码，等待另一方接听电话并说“喂”，然后再说“找谁”。<strong>因此，TCP中不存在广播、组播这种概念</strong>，这两个概念与连接是矛盾的</li>
<li>字节流服务：<strong>TCP不会自动插入记录标志或消息边界</strong>。例如，发送方可能分两次先后写入10字节、20字节，但是接收方可能一次性读入30字节，也有可能分3次每次读入10字节</li>
</ol>
<p><strong>TCP中的可靠性</strong></p>
<ol>
<li>TCP提供一个字节流接口，TCP必须把一个发送应用程序的字节流转换成一组IP可以携带的分组。这被称为组包</li>
</ol>
<h1 id="9-tcp连接管理"><a class="markdownIt-Anchor" href="#9-tcp连接管理"></a> 9 TCP连接管理</h1>
<p>TCP服务模型是一个字节流。TCP必须检测并修补所有在IP层产生的数据传输问题，比如丢包、重复以及错误</p>
<h2 id="91-tcp连接的建立与终止"><a class="markdownIt-Anchor" href="#91-tcp连接的建立与终止"></a> 9.1 TCP连接的建立与终止</h2>
<ol>
<li>一个TCP连接由一个4元组构成，他们分别是两个IP地址和两个端口号</li>
<li>一个TCP连接通常分为3个阶段：启动、数据传输和退出
<ul>
<li><img src="/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-2-1.jpg" alt="fig" /></li>
</ul>
</li>
<li>TCP建连步骤如下：
<ol>
<li>主动开启者（通常称为客户端）发送一个<code>SYN</code>报文段，并指明自己想要连接的端口号和它的客户端初始序列号（<code>ISN(c)</code>）</li>
<li>服务器也发送自己的<code>SYN</code>报文段作为响应，并包含了它的初始序列号（<code>ISN(s)</code>）。此外，为了确认客户端的<code>SYN</code>，服务器将其包含的<code>ISN(c)</code>数值加1后作为返回的<code>ACK</code>数值。因此，每发送一个<code>SYN</code>，序列号就会自动加<code>1</code>。这样如果出现丢失的情况，该<code>SYN</code>段将会重传</li>
<li>为了确认服务器的<code>SYN</code>，客户端将<code>ISN(s)</code>的数值加<code>1</code>后作为返回的<code>ACK</code>值</li>
</ol>
<ul>
<li>三次握手的目的不仅在于让通信双方了解一个连接正在建立，还在于利用数据包的选项来承载特殊的信息，交换初始序列号（<code>Initial Sequence Number, ISN</code>）</li>
</ul>
</li>
<li>TCP关闭步骤如下：
<ol>
<li>连接的主动关闭者发送一个<code>FIN</code>报文段，指明接受者希望看到的自己当前的序列号（图中的<code>K</code>），<code>FIN</code>段还包含了一个<code>ACK</code>段用于确认对方最近一次发来的数据（图中的<code>L</code>）</li>
<li>连接的被动关闭者将<code>K</code>的数值加1作为响应的<code>ACK</code>值，以表明它已经成功接收到主动关闭者发送的<code>FIN</code>。此时，上层的应用程序会被告知连接的另一端已经提出了关闭的请求。通常，这将导致应用程序发起自己的关闭操作。接着，被动关闭者将身份转变为主动关闭者，并发送自己的<code>FIN</code>。该报文段的序列号为<code>L</code></li>
<li>为了完成连接的关闭，最后发送的报文段还包含一个<code>ACK</code>用于确认上一个<code>FIN</code>。值得注意的是，如果出现<code>FIN</code>丢失的情况，那么发送方将重新传输直到接收到一个<code>ACK</code>确认为止</li>
</ol>
</li>
<li>通常情况下，建立一个TCP连接需要3个报文段，而关闭一个TCP连接需要4个报文段。此外，TCP的通信模型是双向的，因此还支持半开启/半关闭（很少见）
<ul>
<li>半开启：只有一个方向正在进行数据传输</li>
<li>半关闭：仅关闭数据流的一个方向</li>
<li>这两个概念描述的可能是同一个状态，只不过角度不同</li>
</ul>
</li>
<li>伯克利套接字的API提供了半关闭操作，用<code>shutdown()</code>来代替<code>close()</code>
<ul>
<li>首次发送的两个报文段，与TCP正常关闭时完全相同：主动关闭者发送<code>FIN</code>，被动关闭者回应该<code>FIN</code>的<code>ACK</code></li>
<li>被动关闭者可以发送任意数量的数据段</li>
<li>当被动关闭者完成数据发送后，他将会发送一个<code>FIN</code>来关闭本方连接，同时向发起半关闭的应用程序发出一个文件尾提示</li>
<li>当第二个<code>FIN</code>被确认后，整个连接完全关闭</li>
<li><img src="/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-2-2.jpg" alt="fig" /></li>
</ul>
</li>
<li>同时打开：通信双方在接收到来自对方的<code>SYN</code>之前必须先发送一个<code>SYN</code>（这种情况其实非常少见，但是对于TCP协议的实现来说，必须要考虑这种情况）。
<ul>
<li>同时打开过程需要交换4个报文段，比普通的三次握手增加了一个</li>
<li><img src="/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-2-3.jpg" alt="fig" /></li>
</ul>
</li>
<li>同时关闭：与普通关闭并无太大区别，因为通信双方都需要主动提出关闭请求
<ul>
<li><img src="/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-2-4.jpg" alt="fig" /></li>
</ul>
</li>
<li>初始序列号：TCP报文段在经过网络路由后可能会存在延迟抵达与排序混乱的情况，初始序列号就是为了解决这个问题
<ul>
<li>在发送用于建立连接的<code>SYN</code>之前通信双方都会选择一个初始序列号。初始序列号会随着时间递增，它被设计成一个32位的计数器，该计数器每4微妙增加1</li>
<li>TCP连接由四元组确定，因此即便是同一个连接也会出现不同的实例（同样的四元组建连关闭，再建连再关闭，就是2个不同的实例）</li>
<li>一个TCP报文段只有同时具备连接的四元组与当前活动窗口的序列号，才会在通信过程中被对方认为是正确的的。这也侧面反映了TCP的脆弱性。如果不加以限制，任何人只要知道四元组，就能伪造TCP报文段，从而干扰正常连接</li>
<li>现代系统通常采用半随机的方法选择初始序列号</li>
</ul>
</li>
<li>连接建立超时
<ul>
<li><code>net.ipv4.tcp_syn_retries(/proc/sys/net/ipv4/tcp_syn_retries)</code>：一次主动打开申请中尝试重新发送<code>SYN</code>报文段的最大次数</li>
<li><code>net.ipv4.tcp_synack_retries(/proc/sys/net/ipv4/tcp_synack_retries)</code>：表示响应对方的一个主动打开请求时尝试重新发送<code>SYN+ACK</code>报文段的最大次数</li>
</ul>
</li>
</ol>
<h2 id="92-tcp选项"><a class="markdownIt-Anchor" href="#92-tcp选项"></a> 9.2 TCP选项</h2>
<table>
<thead>
<tr>
<th style="text-align:left">种类</th>
<th style="text-align:left">长度</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">参考</th>
<th style="text-align:left">目的与描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left"><code>EOL</code></td>
<td style="text-align:left">[RFC0793]</td>
<td style="text-align:left">选项列表结束</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left"><code>NOP</code></td>
<td style="text-align:left">[RFC0793]</td>
<td style="text-align:left">无操作（用于填补）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">4</td>
<td style="text-align:left"><code>MSS</code></td>
<td style="text-align:left">[RFC0793]</td>
<td style="text-align:left">最大段大小</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong><code>WSOPT</code></strong></td>
<td style="text-align:left">[RFC01323]</td>
<td style="text-align:left"><strong>窗口放缩因子</strong></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">2</td>
<td style="text-align:left"><code>SACK-Permitted</code></td>
<td style="text-align:left">[RFC02018]</td>
<td style="text-align:left">发送者支持<code>SACK</code>选项</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">可变</td>
<td style="text-align:left"><code>SACK</code></td>
<td style="text-align:left">[RFC02018]</td>
<td style="text-align:left"><code>SACK</code>阻塞（接收到乱序数据）</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">10</td>
<td style="text-align:left"><code>TSOPT</code></td>
<td style="text-align:left">[RFC01323]</td>
<td style="text-align:left">时间戳选项</td>
</tr>
<tr>
<td style="text-align:left">28</td>
<td style="text-align:left">4</td>
<td style="text-align:left"><code>UTO</code></td>
<td style="text-align:left">[RFC05482]</td>
<td style="text-align:left">用户超时（一段空闲时间后的终止）</td>
</tr>
<tr>
<td style="text-align:left">29</td>
<td style="text-align:left">可变</td>
<td style="text-align:left"><code>TCP-AO</code></td>
<td style="text-align:left">[RFC05925]</td>
<td style="text-align:left">认证选项（使用多种算法)</td>
</tr>
<tr>
<td style="text-align:left">253</td>
<td style="text-align:left">可变</td>
<td style="text-align:left"><code>Experimental</code></td>
<td style="text-align:left">[RFC04727]</td>
<td style="text-align:left">保留供实验室所用</td>
</tr>
<tr>
<td style="text-align:left">254</td>
<td style="text-align:left">可变</td>
<td style="text-align:left"><code>Experimental</code></td>
<td style="text-align:left">[RFC04727]</td>
<td style="text-align:left">保留供实验室所用</td>
</tr>
</tbody>
</table>
<ol>
<li>TCP支持的选项如上表，种类指明了该选项的类型，不能被理解的选项会被直接忽略</li>
</ol>
<h3 id="921-最大段大小选项"><a class="markdownIt-Anchor" href="#921-最大段大小选项"></a> 9.2.1 最大段大小选项</h3>
<ol>
<li>最大段大小是指TCP协议锁允许的从对方接收到的最大报文段，且只记录TCP数据的字节数（不包括其他相关的TCP与IP头部）。默认为536字节。<strong>经典设置值是1460（1460字节的TCP数据+20字节的TCP协议头+20字节的IP协议头=1500，这是MTU的经典设置值）</strong></li>
</ol>
<h3 id="922-选择确认选项"><a class="markdownIt-Anchor" href="#922-选择确认选项"></a> 9.2.2 选择确认选项</h3>
<ol>
<li>TCP的选择确认选项（<code>SACK</code>）能够让发送方了解到接收方的窗口信息，从而能够更好地进行重传</li>
<li><code>SACK</code>选项包含了一组<code>SACK</code>块，每个<code>SACK</code>块包含了接收方已经成功接收的数据块的序列号范围，由一对32位的序列号表示。因此，一个<code>SACK</code>选项包含了n个<code>SACK</code>块，长度为(8n+2)</li>
<li>同时，由于TCP头部选项空间是有限的。因此，一个报文段中发送的最大<code>SACK</code>块的数量为3</li>
</ol>
<h3 id="923-窗口缩放因子"><a class="markdownIt-Anchor" href="#923-窗口缩放因子"></a> 9.2.3 窗口缩放因子</h3>
<ol>
<li>根据[RFC1323]，窗口缩放选项（表示为<code>WSCALE</code>或<code>WSOPT</code>）能够有效地将TCP窗口字段的范围从16位增加至30位。TCP头部不需要改变窗口字段的大小，仍然维持16位的数值。同时，使用另一个选项作为这16位数值的比例因子。该比例因子能够使窗口字段有效地左移</li>
<li>比例因子最小是0，最大是14，当比例因子是14时，能提供一个最大为$(65536\ *\ 2^{14})$的窗口，该数据接近1GB。因此TCP使用一个32位的值来维护这个&quot;真实&quot;的窗口大小</li>
<li>该选项只能出现于一个<code>SYN</code>报文段中。因此当连接建立之后，比例因子也是与方向有关的。为了保证窗口的调整，通信双方都需要在<code>SYN</code>报文段中包含该选项</li>
<li>默认的比例因子是0</li>
</ol>
<h3 id="924-时间戳选项与防回绕序列号"><a class="markdownIt-Anchor" href="#924-时间戳选项与防回绕序列号"></a> 9.2.4 时间戳选项与防回绕序列号</h3>
<ol>
<li>时间戳选项（<code>TSOPT</code>）要求发送方在每个报文段中添加2个4字节的时间戳数值。接收方会在确认中反映这些数值（<code>原封不动传回去</code>），允许发送方针对每一个接收到的<code>ACK</code>估算TCP连接的往返时间（由于TCP协议经常利用一个<code>ACK</code>来确认多个报文段，此处必须指出“是每个接收到的<code>ACK</code>”而不是“每个报文段”）。关于这部分细节，在<code>TCP数据流与窗口管理</code>一章中会详细讨论，这里不展开</li>
<li>该选项并不要求在两台主机之间进行任何形式的时钟同步（比如一端用的是北京时间，一端用的是纽约时间），<strong>两个时间戳都是同一侧产生的（发送方发包时产生一个时间戳，发送方接收<code>ACK</code>时产生一个时间戳，根据这两个时间戳的差值便可计算）</strong>，因此只要每一端保证单调递增即可</li>
<li>TCP的序列号是32位的，是个有限的数值，因此它是会循环的。而时间戳选项可以帮助<code>接收者</code>有效区分新旧报文，这被称为<code>防回绕序列号（Protection Against Wrapped Sequence numbers, PAWS）</code>
<ul>
<li>如果报文段的时间戳与当前时间戳的间隔超过<code>MSL（一个报文段在网络中存在的最大时间）</code>时，根据防回绕序列号算法，会将其丢弃</li>
<li>由于接收方和发送方时钟不同步，接收方只能得知下一个发送方发送的报文段的最小时间戳（记为<code>MIN_NEXT_TIMESTAMP</code>)，一定比上一次收到的报文段的时间戳要大（发送方必须确保时间戳单调递增）。因此，当报文段到达的时候，如果<code>MIN_NEXT_TIMESTAMP - TIME_STAMP &gt; MSL</code>，那么报文将被丢弃</li>
</ul>
</li>
</ol>
<h3 id="925-用户超时选项"><a class="markdownIt-Anchor" href="#925-用户超时选项"></a> 9.2.5 用户超时选项</h3>
<ol>
<li><code>用户超时（UTO）</code>选项的数值<code>USER_TIMEOUT</code>指明了TCP发送者在确认对方未能成功接收数据之前愿意等待该数据<code>ACK</code>确认的时间</li>
<li>用户超时选项的数值是建议性的，另一端并不一定要遵从</li>
<li>一般建议值如下
<ul>
<li>规则1：当TCP连接打到3次重传阈值时应该通知应用程序</li>
<li>规则2：当超时大于100秒时应该关闭连接</li>
</ul>
</li>
</ol>
<h3 id="926-认证选项"><a class="markdownIt-Anchor" href="#926-认证选项"></a> 9.2.6 认证选项</h3>
<ol>
<li>TCP设置了一个选项用于增强连接的安全性。通信双方必须采用一种方法在TCP认证选项运行之前建立出一套共享秘钥</li>
<li>发送数据时，TCP会根据共享秘钥生成一个通信秘钥。接收者装配有相同的秘钥，同样也能够生成通信秘钥</li>
<li>由于需要创建并分发一个共享秘钥，该选项并未得到广泛使用</li>
</ol>
<h2 id="93-tcp的路径最大传输单元发现"><a class="markdownIt-Anchor" href="#93-tcp的路径最大传输单元发现"></a> 9.3 TCP的路径最大传输单元发现</h2>
<ol>
<li>路径最大传输单元（MTU）是指经过两台主机之间路径的所有网络报文段中最大传输单元的最小值。知道路径最大传输单元后能够有助于一些协议（比如TCP）避免分片</li>
<li><code>分组层路径最大传输单元发现（Packetization Layer Path MTU Discovery, PLPMTUD）</code>，该算法可以为TCP以及其他协议计算路径最大传输单元，<strong>同时避免使对ICMP的使用（为什么要避免使用ICMP？）</strong>
<ul>
<li>在该算法中，利用<code>IPv6</code>协议中的”数据包太大“<code>（PTB，Packet Too Big）</code>来代表ICMPv4地址不可达（需要分片）或ICMPv6数据包太大的消息</li>
</ul>
</li>
<li>TCP常规的路径最大传输单元发现过程如下：
<ol>
<li>在一个连接建立时，TCP使用对外接口的最大传输单元的最小值，或者根据通信对方声明的最大段大小来选择发送方的最大段大小（<code>SMSS</code>）。<code>路径最大传输单元发现</code>不允许TCP发送方有超过另一方声明的最大段大小的行为。如果对方没有指明最大段大小的数值，发送方将假设采用默认的536字节</li>
<li>一旦为发送方的最大段大小选定了初始值，TCP通过这条连接发送的所有IPv4数据报都会对DF位字段进行设置。<strong>TCP/IP没有DF位字段，因此只需要假设所有的数据报都已经设置了该字段而不必进行实际操作</strong></li>
<li>如果接收到了PTB消息，TCP就会减少段的大小，然后用修改过的段进行重传。如果在PTB消息中已经包含了下一跳推荐的最大传输单元，数据段大小的数值可以设置为下一跳最大传输单元的数值减去IPv4（或IPv6）与TCP头部的大小；如果下一跳最大传输单元的数值不存在，发现者可能需要尝试多个数值（例如二分法）</li>
<li>由于路由是动态变化的，在减少段大小的数值一段时间后需要尝试一个更大的数值（接近初始的发送方最大段大小），该时间间隔大约为10分钟</li>
</ol>
</li>
<li>在互联网环境中，由于防火墙阻塞PTB消息，路径最大传输单元发现过程会存在一些问题
<ol>
<li>如果TCP的实现依靠ICMP消息来调整它的段大小的情况下，如果TCP从未接收到任何ICMP消息，那么在路径最大传输单元发现过程中就会造成黑洞问题。其原因可能是防火墙或NAT配置禁止转发ICMP消息</li>
<li>一些TCP的实现具有“黑洞探测”功能，当一个报文在反复重传数次后，将会尝试发送一个较小的报文段</li>
</ol>
</li>
</ol>
<h2 id="94-tcp状态转换"><a class="markdownIt-Anchor" href="#94-tcp状态转换"></a> 9.4 TCP状态转换</h2>
<p><img src="/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-5-1.jpg" alt="fig" /></p>
<ol>
<li>状态图解释
<ul>
<li>椭圆表示状态</li>
<li>箭头表示状态转换</li>
</ul>
</li>
<li><strong>只有一部分状态转移被认为是“典型的”</strong>
<ul>
<li>客户端典型的状态转移用深黑色的实线箭头表示</li>
<li>服务端典型的转台转移用虚线箭头表示</li>
</ul>
</li>
</ol>
<p><img src="/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-5-2.jpg" alt="fig" /></p>
<ol>
<li><strong><code>SYN_SENT</code></strong>：主动发起者发出<code>SYN(K)</code>后，进入到该状态，等待对方回复<code>ACK(K+1)</code></li>
<li><strong><code>SYN_RCVD</code></strong>：被动发起者收到<code>SYN(K)</code>，且回复<code>ACK(K+1)</code>以及<code>SYN(L)</code>之后，进入到该状态，等待对方回复<code>ACK(L+1)</code></li>
<li><strong><code>ESTABLISHED</code></strong>：有两种情况
<ul>
<li>主动发起者收到<code>ACK(K+1)</code>以及<code>SYN(L)</code>，并回复<code>ACK(L+1)</code>之后，进入到该状态</li>
<li>被动发起者收到<code>ACK(L+1)</code>之后，进入到该状态</li>
</ul>
</li>
<li><strong><code>FIN_WAIT_1</code></strong>：主动关闭者发送<code>FIN(M)</code>之后，进入到该状态</li>
<li><strong><code>CLOSE_WAIT</code></strong>：被动关闭者收到<code>FIN(M)</code>之后，并回复<code>ACK(M+1)</code>之后，进入到该状态。此时，连接的一个方向已关闭，等待另一个方向的数据传输完毕并发送<code>FIN</code></li>
<li><strong><code>FIN_WAIT_2</code></strong>：主动关闭者收到对方发送的<code>ACK(M+1)</code>之后，进入到该状态。此时，连接的一个方向已关闭，等待另一个方向的数据传输完毕并发送<code>FIN</code></li>
<li><strong><code>LAST_ACK</code></strong>：被动关闭者传输完毕所有数据，发送<code>FIN(N)</code>之后，进入到该状态</li>
<li><strong><code>TIME_WAIT</code></strong>：主动关闭者收到<code>FIN(N)</code>，且回复<code>ACK(N+1)</code>之后，进入到该状态</li>
<li><strong><code>CLOSED</code></strong>：有两种情况
<ul>
<li>当被动关闭者收到<code>ACK(N+1)</code>之后，进入到该状态</li>
<li>当主动关闭者等待<code>2MSL</code>之后，将会从<code>TIME_WAIT</code>进入到该状态</li>
</ul>
</li>
</ol>
<h3 id="941-time_wait状态"><a class="markdownIt-Anchor" href="#941-time_wait状态"></a> 9.4.1 TIME_WAIT状态</h3>
<ol>
<li><code>TIME_WAIT</code>状态也称为<code>2MSL</code>等待状态。在该状态中，TCP将会等待两倍于最大段生存期（<code>Maximum Segment Lifetime，MSL</code>）的时间，有时也被称作加倍等待。它代表任何报文段在被丢弃前在网络中被允许存在的最长时间。这个时间是有限的，因为TCP报文段是以IP数据报的形式传输的，IP数据报拥有TTL字段和条数限制字段。这两个字段限制了IP数据报的有效生存时间</li>
<li>[RFC0793]将最大段生存期设置为2分钟。在常见的实现中，最大段生存期的数值可以为30秒、1分钟或2分钟。在linux系统中，<code>net.ipv4.tcp_fin_timeout（/proc/sys/net/ipv4/tcp_fin_timeout）</code>记录了<code>2MSL</code>状态需要等待的超时时间</li>
<li>当TCP执行一个主动关闭并发送最终的<code>ACK</code>时，连接必须处于<code>TIME_WAIT</code>状态并持续两倍于最大生存期的时间。这样就能够让TCP重新发送最终的<code>ACK</code>以避免出现丢失的情况。重新发送最终的<code>ACK</code>并不是因为TCP重传了<code>ACK</code>（<code>ACK</code>不消耗序列号，也不会被TCP重传），而是因为通信另一方重传了它的<code>FIN</code>（它消耗一个序列号）。事实上，TCP总是重传<code>FIN</code>，直到它收到一个最终的<code>ACK</code></li>
<li><strong>当TCP处于<code>2MSL</code>等待状态时，该连接（四元组）不可重新使用（一些实现施加了更加严格的约束，在这些系统中，如果一个端口号处于<code>2MSL</code>等待状态，那么该端口号将不能再次被使用）。许多实现和API都提供了绕开这一约束的方法，在伯克利套接字API中<code>SO_REUSEADDR</code>套接字选项就支持绕开该操作</strong></li>
<li>对于交互式的应用程序而言，客户端通常执行主动关闭操作并进入<code>TIME_WAIT</code>状态，服务器通常执行被动关闭操作并且不会直接进入<code>TIME_WAIT</code>状态</li>
</ol>
<p><strong><code>TCP/IP</code>设计<code>TIME_WAIT</code>状态有两个原因：</strong></p>
<ol>
<li><strong>可靠地实现TCP全双工连接的终止</strong>
<ul>
<li>TCP协议在关闭连接的四次握手过程中，最终的<code>ACK</code>是由主动关闭连接的一端（后面统称A端）发出的，<strong>如果这个<code>ACK</code>丢失，对方（后面统称B端）将重发出最终的<code>FIN</code>，因此A端必须维护状态信息（<code>TIME_WAIT</code>）允许它重发最终的<code>ACK</code></strong>。如果A端不维持<code>TIME_WAIT</code>状态，而是处于<code>CLOSED</code>状态，那么A端在收到<code>FIN</code>后将会响应<code>RST</code>而不是<code>ACK</code>，B端收到<code>RST</code>后将此分节解释成一个错误</li>
<li>因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的A端必须维持<code>TIME_WAIT</code>状态</li>
</ul>
</li>
<li><strong>允许老的重复分节在网络中消逝</strong>
<ul>
<li>TCP分节可能由于路由器异常而迷途，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个迟到的迷途分节到达时可能会引起问题。在关闭前一个连接之后，马上又重新建立起一个相同的IP和端口之间的新连接，<strong>前一个连接的迷途重复分组在前一个连接终止后到达，而被新连接收到了</strong>。为了避免这个情况，TCP协议不允许处于<code>TIME_WAIT</code>状态的连接启动一个新的可用连接，<strong>因为<code>TIME_WAIT</code>状态持续<code>2MSL</code>，就可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝</strong></li>
</ul>
</li>
</ol>
<p><strong>此外，处于<code>TIME_WAIT</code>状态下的tcp连接，不会占用文件描述符</strong></p>
<h3 id="942-close_wait状态"><a class="markdownIt-Anchor" href="#942-close_wait状态"></a> 9.4.2 CLOSE_WAIT状态</h3>
<p><strong>处于<code>CLOSE_WAIT</code>状态下的tcp连接，会占用文件描述符。如果系统中出现了大量的<code>CLOSE_WAIT</code>状态，可能会导致新的连接无法正常建立</strong></p>
<h3 id="943-静默时间的概念"><a class="markdownIt-Anchor" href="#943-静默时间的概念"></a> 9.4.3 静默时间的概念</h3>
<ol>
<li>在TCP四元组都相同的情况下，<code>2MSL</code>状态能够防止新的连接将前一个连接的延迟报文段解释成自身数据的情况。如果一台处于<code>TIME_WAIT</code>状态下的连接相关联的主机崩溃，然后在<code>MSL</code>内重新启动，并且使用与主机崩溃之前处于<code>TIME_WAIT</code>状态的连接相同的IP地址与端口号，那么该连接在主机崩溃之前产生的延迟报文段会被认为属于主机重启后创建的新连接。<strong>为了防止上述情况发生，[RFC0793]指出在崩溃或重启后TCP协议应当在创建新的连接之前等待相当于一个<code>MSL</code>的时间。该段时间被称为静默时间（只有极少数TCP的实现遵循了这一点，因为如果上层的应用程序自己做了校验或加密，那么这种错误会很容易判断出来）</strong></li>
</ol>
<h3 id="944-fin_wait_2状态"><a class="markdownIt-Anchor" href="#944-fin_wait_2状态"></a> 9.4.4 FIN_WAIT_2状态</h3>
<ol>
<li><code>FIN_WAIT_2</code>状态表达式：某TCP通信端已发送一个<code>FIN</code>并已得到另一端的确认</li>
<li>只有收到了另一端的<code>FIN</code>之后，才会从<code>FIN_WAIT_2</code>状态转移到<code>TIME_WAIT</code>状态，这意味着连接的一端能够永远保持这种状态（另一端会处于<code>CLOSED_WAIT</code>状态）</li>
<li>许多方法都能防止连接进入<code>FIN_WAIT_2</code>这一无限等待状态：如果负责关闭的应用程序执行的是一个完全关闭操作，而不是用一个半关闭来指明它还期望接收数据，那么就会设置一个计时器。如果当计时器超时时，连接是空闲的，那么TCP连接就会转移到<code>CLOSED</code>状态。在Linux中，可以通过调整<code>net.ipv4.tcp_fin_timeout（/proc/sys/net/ipv4/tcp_fin_timeout（）</code>的数值来设置计时器的秒数，默认是60s</li>
</ol>
<h3 id="945-同时打开与关闭的转换"><a class="markdownIt-Anchor" href="#945-同时打开与关闭的转换"></a> 9.4.5 同时打开与关闭的转换</h3>
<ol>
<li>同时打开
<ol>
<li>通信两端几乎在相同的时刻都会发送一个<code>SYN</code>报文段，然后它们进入<code>SYN_SENT</code>状态</li>
<li>当它们接收到对方发来的<code>SYN</code>报文段时会将状态迁移至<code>SYN_RCVD</code>，然后重新发送一个新的<code>SYN</code>并确认之前收到的<code>SYN</code></li>
<li>当通信两端都收到了<code>SYN</code>与<code>ACK</code>，它们的状态都会迁移至<code>ESTABLISHED</code>状态</li>
</ol>
</li>
<li>同时关闭
<ol>
<li>通信两端的状态都会从<code>ESTABLISHED</code>状态迁移至<code>FIN_WAIT_1</code>状态。与此同时，都会向对方发送一个<code>FIN</code></li>
<li>在接收到对方发来的<code>FIN</code>之后，本地通信段的状态将从<code>FIN_WAIT_1</code>状态迁移至<code>CLOSING</code>状态，通信双方还会发送最终的<code>ACK</code></li>
<li>当接收到最终的<code>ACK</code>后，每个通信段会将状态更改为<code>TIME_WAIT</code>，从而初始化<code>2MSL</code>等待过程</li>
</ol>
</li>
</ol>
<h2 id="95-重置报文段rst"><a class="markdownIt-Anchor" href="#95-重置报文段rst"></a> 9.5 重置报文段RST</h2>
<p><strong>在TCP协议中<code>RST, Reset the connection</code>表示复位，用来异常的关闭连接，一个将<code>RST</code>字段置位的报文段被称作重置报文段或简称为重置，一般来说，当发现一个到达的报文段相对于关联连接而言是不正确时，TCP就会发送一个重置报文段</strong>。在TCP的设计中它是不可或缺的。发送<code>RST</code>包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送<code>RST</code>包。而接收端收到<code>RST</code>包后，也不必发送<code>ACK</code>包来确认</p>
<p><strong>在网络编程过程中，各种<code>RST</code>错误其实是比较难排查和找到原因的。下面我列出几种会出现<code>RST</code>的情况</strong></p>
<ol>
<li>端口未打开</li>
<li>请求超时</li>
<li>提前关闭</li>
<li>在一个已关闭的socket上收到数据</li>
</ol>
<h3 id="951-针对不存在端口的连接请求"><a class="markdownIt-Anchor" href="#951-针对不存在端口的连接请求"></a> 9.5.1 针对不存在端口的连接请求</h3>
<ol>
<li>一般而言，当一个连接请求到达本地却没有相关进程在目的端口侦听时，就会产生一个重置报文段
<ul>
<li>UDP使用<code>ICMP</code>目的不可达（端口不可达）消息来表示端口不可用</li>
<li>TCP使用重置报文段来代替ICMP消息</li>
</ul>
</li>
<li>对于一个被TCP端接收的重置报文段而言，它的<code>ACK</code>位字段必须被置位，并且<code>ACK</code>的序列号数值必须在正确的窗口范围内，这样有助于防止一种简单的攻击：在这种攻击中，任何人都能够生成一个与相应连接（4元组）匹配的重置报文段，从而扰乱这个连接</li>
</ol>
<h3 id="952-终止一条连接"><a class="markdownIt-Anchor" href="#952-终止一条连接"></a> 9.5.2 终止一条连接</h3>
<ol>
<li>终止一条连接的正常方法是由通信一方发送一个<code>FIN</code>，这种方法有时被称为<code>有序释放</code>，这种方式通常不会出现丢失数据的情况</li>
<li>在任何时刻，我们都可以通过发送一个重置报文段替代<code>FIN</code>终止一条连接，这种方式有时被称为<code>终止释放</code></li>
<li>终止一条连接可以为应用程序提供两大特性
<ol>
<li>任何排队的数据都将被抛弃，一个重置报文段会被立即发送出去</li>
<li>重置报文段的接收方会说明通信一端采用了终止的方式而不是一次正常关闭</li>
</ol>
</li>
<li>套接字API通过将“逗留于关闭”套接字选项（<code>SO_LINGER</code>)数值设为0来实现上述功能。该参数设置为0表示：不会在终止之前为了确定数据是否到达另一端而逗留任何时间</li>
<li>重置报文段中包含了一个序列号与一个确认号。重置报文段不会令通信另一端做出任何响应—它不会被确认。接收重置报文段的一端会终止连接并通知应用程序当前连接已被重置。通常会看到“连接被另一端重置（Connection reset by peer）”的错误提示</li>
</ol>
<h3 id="953-半开连接"><a class="markdownIt-Anchor" href="#953-半开连接"></a> 9.5.3 半开连接</h3>
<ol>
<li>如果在未告知另一端的情况下通信一端关闭或终止连接，那么就认为该条连接处于半开状态。这种情况通常发生在通信一方主机崩溃的情况下。只要不尝试通过半开连接传输数据，正常工作的一端将不会检测出另一端已经崩溃</li>
<li>产生半开连接的另一个共同原因是某一台主机的电源被切断而不是被正常关机</li>
<li>可以利用TCP的keepalive选项发现另一端已经消失</li>
</ol>
<h3 id="954-时间等待错误"><a class="markdownIt-Anchor" href="#954-时间等待错误"></a> 9.5.4 时间等待错误</h3>
<ol>
<li>设计<code>TIME_WAIT</code>状态的目的是允许任何受制于一条关闭连接的数据报被丢弃。在这段时期，等待的TCP通常不需要做任何操作，它只需要维持当前状态直到<code>2MSL</code>的计时结束。然而，如果它在这段时间期内接收到来自于这条连接的一些报文段，或是更加特殊的重置报文段，它将会被破坏。这种情况被称为时间等待错误（<code>TIME_WAIT Assassination，TWA</code>）</li>
</ol>
<p><img src="/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/13-6-1.jpg" alt="fig" /></p>
<ol>
<li>在上述例子中，服务器完成了其在连接中的角色所承担的工作并清除了所有状态，客户端依然保持<code>TIME_WAIT</code>状态。当完成<code>FIN</code>交换，客户端的下一个序列号为<code>K</code>，而服务器的下一个序列号为<code>L</code>。最近到达的报文段是由服务器发送至客户端，它使用的序列号为<code>L-100</code>，包含的<code>ACK</code>号为<code>K-200</code>。当客户端收到这个报文段时，它认为序列号与<code>ACK</code>号的数值都是旧的。因此发送一个<code>ACK</code>作为响应，其中包含了最新的序列号和<code>ACK</code>号（分别是K与L）。然而，当服务器收到这个报文段后，它没有关于这条连接的任何信息，因此发送一个重置报文段作为响应，这会使得客户端过早得从<code>TIME_WAIT</code>状态转移至<code>CLOSED</code>状态。因此，许多系统规定处于<code>TIME_WAIT</code>状态时不对重置报文段作出反应，从而避免了上述问题</li>
</ol>
<h2 id="96-与tcp连接管理相关的攻击"><a class="markdownIt-Anchor" href="#96-与tcp连接管理相关的攻击"></a> 9.6 与TCP连接管理相关的攻击</h2>
<h3 id="961-syn泛洪"><a class="markdownIt-Anchor" href="#961-syn泛洪"></a> 9.6.1 SYN泛洪</h3>
<ol>
<li><code>SYN</code>泛洪是一种TCP拒绝服务攻击，在这种攻击中一个或多个恶意的客户端产生一系列TCP连接尝试（<code>SYN</code>报文段），并将它们发送给一台服务器，它们通常采用伪造的源IP地址，服务器会发送<code>ACK</code>以及<code>SYN</code>包给这个伪造的源IP，当然是收不到的，于是就阻塞在了半连接状态。服务器会为每一条连接分配一定数量的连接资源。由于连接尚未完全建立，服务器为了维护大量的板打开连接会耗尽自身内存后拒绝为后续的合法连接请求服务
<ul>
<li>检测<code>SYN</code>泛洪攻击的方式非常简单，即当服务器上有大量半连接状态且源IP地址是随机的，则可以断定遭到<code>SYN</code>泛洪攻击了，<code>netstat -nap | grep SYN_RECV</code></li>
</ul>
</li>
<li><code>SYN cookies</code>是解决<code>SYN</code>泛洪问题的一种机制，<strong>它的主要思想是，当一个<code>SYN</code>到达时，这条连接存储的大部分信息都会被编码并保存在<code>SYN+ACK</code>报文段的序列号字段</strong>。采用<code>SYN cookies</code>的目标主机不需要为进入的连接请求分配任何存储资源–只有当<code>SYN+ACK</code>报文段本身被确认后（并且已返回初始序列号）才会分配真正的内存</li>
<li>服务器在接收到一个<code>SYN</code>后会采用下面的方法设置初始序列号（保存于<code>SYN+ACK</code>报文段，供于客户端）的数值
<ul>
<li>首5位是t模32的结果，其中t是一个32位的计数器，每个64秒增加1</li>
<li>接着3位是服务器最大段大小（8种可能之一）的编码值；剩余的24位保存了4元组与t值的散列值</li>
</ul>
</li>
<li><strong>这种方法有2个缺陷，因此这一功能未作为默认设置</strong>
<ul>
<li>需要对最大段大小进行编码，这种方法禁止使用任意大小的报文段</li>
<li>计数器会回绕，连接建立过程会因周期非常长（长于64秒）而无法正常工作</li>
</ul>
</li>
</ol>
<h3 id="962-劫持"><a class="markdownIt-Anchor" href="#962-劫持"></a> 9.6.2 劫持</h3>
<ol>
<li>如何实现劫持
<ul>
<li>在连接建立过程中引发不正确的状态传输（类似于时间等待错误）</li>
<li>在<code>ESTABLISHED</code>状态下产生额外的数据（被攻击者认为连接已经建立，其实是和攻击者建立的连接）</li>
<li>于是攻击者就能在连接中注入新的流量</li>
</ul>
</li>
</ol>
<h3 id="963-欺骗攻击"><a class="markdownIt-Anchor" href="#963-欺骗攻击"></a> 9.6.3 欺骗攻击</h3>
<ol>
<li>这类攻击所涉及的TCP报文段都是攻击者精心定制的，目的在于破坏或改变现有TCP连接的行为</li>
<li>攻击者可以生成一个伪造的重置报文段并将其发送给一个TCP通信节点，假定与连接相关的4元组以及校验和都是正确的，序列号也处在正确的范围。这样就会造成连接的任意一端失败</li>
</ol>
<h1 id="10-tcp超时与重传"><a class="markdownIt-Anchor" href="#10-tcp超时与重传"></a> 10 TCP超时与重传</h1>
<h2 id="101-概要"><a class="markdownIt-Anchor" href="#101-概要"></a> 10.1 概要</h2>
<ol>
<li>当数据段或确认信息丢失，TCP启动重传操作，重传尚未确认的数据</li>
<li>TCP拥有两套独立机制来完成重传，一是基于时间，二是基于确认信息的构成。第二种方法通常比第一种方法更有效</li>
<li>TCP在发送数据时会设置一个计时器，若至计时器超时仍未收到数据确认信息，则会引发相应的<code>超时</code>或<code>基于计时器的重传</code>操作，计时器超时称为<code>重传超时（RTO）</code></li>
<li>另一种方式称为<code>快速重传</code>，通常发生在没有延时的情况下。若TCP累积确认无法返回新的<code>ACK</code>，或者当<code>ACK</code>包含的选择确认信息（<code>SACK</code>）表明出现失序报文段时，快速重传会推断出现丢包</li>
</ol>
<h2 id="102-简单的超时与重传"><a class="markdownIt-Anchor" href="#102-简单的超时与重传"></a> 10.2 简单的超时与重传</h2>
<h2 id="103-设置重传超时"><a class="markdownIt-Anchor" href="#103-设置重传超时"></a> 10.3 设置重传超时</h2>
<ol>
<li><code>Round Trip Time, RTT</code>和<code>Retransmission Timeout, RTO</code>
<ul>
<li>若TCP先于<code>RTT</code>开始重传，可能会在网络中引入不必要的重复数据</li>
<li>若延迟远大于<code>RTT</code>的间隔发送重传数据，整体网络利用率（及单个连接吞吐量）会随之下降</li>
</ul>
</li>
<li><code>RTT</code>的测量较为复杂，根据路由与网络资源的不同，它会随时间而改变。TCP必须跟踪这些变化并适时做出调整来维持好的性能</li>
<li><strong>TCP在收到数据后会返回确认信息，因此可在该信息中携带一个字节的数据（采用一个特殊序列号，注意，不是TCP的时间戳选项）来测量传输该确认信息所需的时间，每个此类的测量称为<code>RTT样本</code></strong></li>
</ol>
<h3 id="1031-经典方法"><a class="markdownIt-Anchor" href="#1031-经典方法"></a> 10.3.1 经典方法</h3>
<ol>
<li>最初的TCP规范[RFC0793]采用如下公式计算得到平滑的<code>RTT</code>估计值（称为<code>SRTT</code>）
<ul>
<li>
$$SRTT ← \alpha(SRTT) + (1 - \alpha)RTT_s$$
</li>
<li>其中$RTT_s$是新的样本值，常量<code>α</code>为平滑因子，推荐值为<code>0.8~0.9</code></li>
</ul>
</li>
<li>这种估算方法称为指数加权移动平均，或低通过滤器</li>
<li>[RFC0793]推荐根据如下公式设置<code>RTO</code>
<ul>
<li>
$$RTO = min(ubound, max(lbound, (SRTT)\beta)$$
</li>
<li>其中<code>β</code>为离散因子，推荐之为<code>1.3~2.0</code>，<code>ubound</code>为<code>RTO</code>的上边界（建议值1分钟），lbound为<code>RTO</code>的下边界（建议值1s）</li>
</ul>
</li>
<li>对于相对稳定的<code>RTT</code>分布来说，这种方法能取得不错的性能。若TCP运行于<code>RTT</code>变化较大的网络中，则无法获得期望的效果</li>
</ol>
<h3 id="1032-标准方法"><a class="markdownIt-Anchor" href="#1032-标准方法"></a> 10.3.2 标准方法</h3>
<ol>
<li>可以通过记录<code>RTT</code>测量值的变化情况以及均值来得到较为准确的估计值。基于均值和估计值的变化来设置<code>RTO</code>，将比仅使用均值的常数倍来计算<code>RTO</code>更能适应<code>RTT</code>变化幅度较大的情况</li>
<li>平均偏差（mean deviation）是对标准偏差的一种好的逼近。计算标准差需要对方差进行平方根运算，对于快速TCP实现来说代价较大</li>
<li>可对每个<code>RTT</code>测量值<code>M</code>（前面称为$RTT_s$）采用如下算式
<ul>
<li><code>srtt</code>值代替了之前的<code>SRTT</code>，且<code>rttvar</code>为平均偏差的<code>EWMA</code>，而非采用先前的<code>β</code>来设置<code>RTO</code></li>
</ul>
</li>
</ol>
$$\begin{split}
srtt &= (1 - g)(srtt) + (g)M \\
rttvar &= (1 - h)rttvar +(h)(|M - srtt|) \\
RTO &= srtt + 4(rttvar)
\end{split}$$
<ol>
<li>上述算式可以简化为
<ul>
<li><code>srtt</code>为均值的<code>EWMA</code>，<code>rttvar</code>为绝对误差<code>|Err|</code>的<code>EWMA</code>，<code>Err</code>为测量值<code>M</code>与当前<code>RTT</code>估计值<code>srtt</code>之间的偏差</li>
<li><code>srtt</code>与<code>rttvar</code>均用于计算<code>RTO</code>且随时间变化</li>
<li>增量<code>g</code>为新<code>RTT</code>样本<code>M</code>占<code>srtt</code>估计值的权重，取<code>1/8</code></li>
<li>增量<code>h</code>为新平均偏差样本（新样本<code>M</code>与当前平均值<code>srtt</code>之间的绝对误差）占偏差估计值<code>rttvar</code>的权重，取<code>1/4</code></li>
<li><code>g</code>和<code>h</code>取值为2的负幂次，使得计算过程较为简单，只需要移位和加法即可</li>
</ul>
</li>
</ol>
$$\begin{split}
Err &= M - srtt \\
srtt &= srtt + g(Err) \\
rttvar &= rttvar + h(|Err| - rttvar) \\
RTO &= srtt + 4(rttvar)
\end{split}$$
<h4 id="10321-时钟粒度与rto边界"><a class="markdownIt-Anchor" href="#10321-时钟粒度与rto边界"></a> 10.3.2.1 时钟粒度与RTO边界</h4>
<ol>
<li>时钟粒度会影响<code>RTT</code>的测量以及<code>RTO</code>的设置。在[RFC6298]中，粒度用于优化<code>RTO</code>的更新情况，并给<code>RTO</code>设置一个下界
<ul>
<li>这里G为计时器粒度，1000ms为<code>RTO</code>的下界值。因此<code>RTO</code>至少为1s</li>
</ul>
</li>
</ol>
$$
RTO = max(srtt + max(G, 4(rttvar)), 1000)
$$
<h4 id="10322-初始值"><a class="markdownIt-Anchor" href="#10322-初始值"></a> 10.3.2.2 初始值</h4>
<ol>
<li>在首个<code>SYN</code>交换前，TCP无法设置<code>RTO</code>初始值。除非系统提供（有些系统在转发表中缓存了该信息），否则也无法设置估计器的初始值</li>
<li>根据[RFC6298]，<code>RTO</code>的初始值为1s，而初始<code>SYN</code>报文段采用的超时时间间隔为3s</li>
<li>当接收到首个<code>RTT</code>的测量结果M，估计器按如下方式进行初始化</li>
</ol>
$$\begin{split}
srtt &= M \\
rttvar &= M/2
\end{split}$$
<h4 id="10323-重传二义性与karn算法"><a class="markdownIt-Anchor" href="#10323-重传二义性与karn算法"></a> 10.3.2.3 重传二义性与Karn算法</h4>
<ol>
<li>在测量<code>RTT</code>样本的过程中若出现重传，就可能导致某些问题。<strong>假设一个包的传输出现超时，该数据包会被重传，接着收到一个确认信息。那么该信息是对第一次还是第二次传输的确认就存在二义性</strong></li>
<li>[KP87]指出，当出现超时重传时，接收到重传数据的确认信息时不能更新<code>RTT</code>估计值。<strong>这是Karn算法的第一部分</strong></li>
<li>如果我们在设置<code>RTO</code>过程中简单将重传问题完全忽略，就可能将网络提供的一些有用信息也同时忽略</li>
<li>TCP在计算<code>RTO</code>过程中采用一个退避系数（backoff factor），每当重传计时器出现超时，退避系数加倍，该过程一直持续至接收到非重传数据。此时，退避系数重新设为1，重传计时器返回正常值。<strong>这是Karn算法的第二部分</strong></li>
<li><strong>Karn算法定义</strong>：当接收到重复传输（即至少重传一次）数据的确认信息时，不进行该数据包的<code>RTT</code>测量，可以避免重传二义性问题。另外，对数据后续的包采取退避策略。仅当接收到未经重传的数据时，该<code>SRTT</code>采用与计算<code>RTO</code></li>
<li>Karn算法一直作为TCP实现的必要方法。当然也有例外情况，在使用TCP时间戳选项的情况下，可以避免二义性，因此在这种情况下，Karn算法的第一部分不适用</li>
</ol>
<h4 id="10324-带时间戳选项的rtt测量"><a class="markdownIt-Anchor" href="#10324-带时间戳选项的rtt测量"></a> 10.3.2.4 带时间戳选项的RTT测量</h4>
<ol>
<li>时间戳值（<code>TSV</code>）携带于初始<code>SYN</code>的<code>TSOPT</code>中，并在<code>SYN+ACK</code>的<code>TSOPT</code>的<code>TSER</code>部分返回，以此设定<code>srtt</code>、<code>rttvar</code>与<code>RTO</code>的初始值</li>
<li>由于初始<code>SYN</code>可看做数据（即同样采取丢失重传策略且占用一个序列号），应测量其<code>RTT</code>值。其他报文段包含<code>TSOPT</code>，因此可结合其他样本值估算该连接的<code>RTT</code></li>
<li>该过程看似简单但实际存在很多不确定因素，因为TCP并非对接收到的每个报文段都返回<code>ACK</code>。例如，当传输大批量的数据时，TCP通常采取每两个报文段返回一个<code>ACK</code>的方法。另外，当数据出现丢失、失序、或重传成功时，TCP的累积确认机制表明报文段与其<code>ACK</code>之间并非严格的一一对应关系</li>
<li>为了解决上述问题，采用如下算法来测量<code>RTT</code>样本值
<ul>
<li>TCP发送端：
<ol>
<li>在其发送的每个报文段的<code>TSOPT</code>的<code>TSV</code>部分携带一个32比特的时间戳值。该值包含数据发送时刻的TCP时钟值</li>
<li>接收到<code>ACK</code>后，将当前TCP时钟减去<code>TSOPT</code>的<code>TSER</code>部分的值，得到的差值即为新的<code>RTT</code>样本估计值。<strong>注意，如果该<code>ACK</code>没有使得窗口前移，那么该<code>ACK</code>的<code>TSER</code>将被忽略，例如发生丢包时重复的<code>ACK</code></strong></li>
</ol>
</li>
<li>TCP接收端：
<ol>
<li>用一个名为<code>TsRecent</code>的变量记录收到的<code>TSV</code>值</li>
<li>用一个名为<code>LastACK</code>的变量记录其上一个发送的<code>ACK</code>序列号。回忆一下，<code>ACK</code>号代表接收端（即<code>ACK</code>的发送方）期望接收的下一个有序序号</li>
<li>发送任何一个<code>ACK</code>都包含<code>TSOPT</code>，其中，<code>TSER</code>部分的值为变量<code>TsRecent</code>的值</li>
<li>当一个新的报文段到达TCP接收端时，如果其序号与变量<code>LastACK</code>的值吻合（即为下一个期望接收的报文段），则将变量<code>TsRecent</code>的值更新为这个新报文段的<code>TSV</code>值</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="1033-linux采用的方法"><a class="markdownIt-Anchor" href="#1033-linux采用的方法"></a> 10.3.3 Linux采用的方法</h3>
<ol>
<li>Linux的<code>RTT</code>测量过程与标准方法有所差别。它采用的时钟粒度为1ms，与其他实现方法相比，其粒度更细，<code>TSOPT</code>也是如此。采用更频繁的<code>RTT</code>测量与更细的时钟粒度，<code>RTT</code>测量也更为精确，但也易于导致<code>rttvar</code>值随时间减为最小。这是由于当累积了大量的平均偏差样本时，这些样本之间易产生相互抵消的效果。这是其<code>RTO</code>设置区别于标准方法的一个原因</li>
<li><strong>此外，当某个<code>RTT</code>样本显著低于现有的<code>RTT</code>估计值<code>srtt</code>时，标准方法会增大<code>rttvar</code></strong>。为了更好地理解这个问题，首先回顾一下<code>RTO</code>通常设置为<code>srtt + 4(rttvar)</code>。因此，无论最大<code>RTT</code>样本值是大于还是小于<code>srtt</code>，<code>rttvar</code>的任何大的变动都会导致<code>RTO</code>增大（这与直觉相反–若实际<code>RTT</code>大幅降低，<code>RTO</code>应该减小才对）Linux通过减小<code>RTT</code>样本值大幅下降对<code>rttvar</code>的影响来解决这一问题</li>
<li>与标准方法一样，Linux也记录变量<code>srtt</code>与<code>rttvar</code>值，但同时还记录两个新的变量，即<code>mdev</code>和<code>mdev_max</code>
<ul>
<li><strong><code>mdev</code>为采用标准方法的瞬时平均偏差估计值，即前面方法的<code>rttvar</code></strong></li>
<li><strong><code>mdev_max</code>则记录在测量<code>RTT</code>样本过程中的最大<code>mdev</code>，其最小值不小于50ms</strong></li>
<li><strong>另外，<code>rttvar</code>需定期更新已保证其不小于<code>mdev_max</code>，因此<code>RTO</code>不会小于200ms</strong></li>
</ul>
</li>
</ol>
<p><img src="/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/14-3-1.jpg" alt="fig" /></p>
<ul>
<li>上述示例中，初始<code>RTT</code>测量值如下
<ul>
<li>
$srtt = 16ms$
</li>
<li>
$mdev = (\frac{16}{2})ms = 8ms$
</li>
<li>
$rttvar = mdev\_max = max(mdev, TCP\_RTO\_MIN) = max(8, 50) = 50ms$
</li>
<li>
$RTO = srtt + 4(rttvar) = 16 + 4(50) = 216ms$
</li>
</ul>
</li>
<li>在初始<code>SYN</code>交换后，发送端对接收端的<code>SYN</code>返回一个<code>ACK</code>，接收端则进行一次相应的窗口更新</li>
<li>当应用首次执行写操作，发送端TCP发送两个报文段（seq=1，seq=1401），每个报文段包含一个值为127的<code>TSV</code>。由于两次发送间隔小于1ms（发送端TCP时钟粒度），因此这两个值相等</li>
<li>接收端变量<code>LastACK</code>记录上一个发送<code>ACK</code>的序列号，此时是1。当序列号为1的报文段到达时，将<code>TsRecent</code>变量更新为新接收分组的<code>TSV</code>，即127；序列号为1401的报文段到达时，由于该序列号与<code>LastACK</code>记录的值不同，因此不更新<code>TsRecent</code>变量。接收端返回<code>ACK</code>时，需要在<code>TSER</code>部分包含<code>TsRecent</code>变量的值，同时更新<code>LastACK</code>的值为2801</li>
<li>当序列号为2801的<code>ACK</code>到达发送端时，TCP就可以进行第二个<code>RTT</code>样本的测量。首先获得当前TCP时钟值，减去已接收<code>ACK</code>包含的<code>TSER</code>，即样本值<code>m = 233 - 127 = 96</code>，Linux按如下步骤更新变量
<ul>
<li>
$mdev = mdev(\frac{3}{4}) + |m - srtt|(\frac{1}{4}) = 8(\frac{3}{4}) + |80|(\frac{1}{4}) = 26ms$
</li>
<li>
$mdev\_max = max(mdev\_max, mdev) = max(50, 26) = 50ms$
</li>
<li>
$srtt = srtt(\frac{7}{8}) + m(\frac{1}{8}) = 16(\frac{7}{8}) + 96(\frac{1}{8}) = 14 + 12 = 26ms$
</li>
<li>
$rttvar = mdev\_max = 50ms$
</li>
<li>
$RTO = srtt + 4(rttvar) = 26 + 4(50) = 226ms$
</li>
</ul>
</li>
</ul>
<ol>
<li>若每个窗口只测量一个<code>RTT</code>样本，<code>rttvar</code>相对变动则较小。利用时间戳和对每个包的测量就可以得到更多的样本值。但同时，短时间内得到的大量样本值可能导致平均偏差变小（接近0，基于大数定理）。为了解决这个问题，Linux维护瞬时平均偏差估计值<code>mdev</code>，但设置<code>RTO</code>时则基于<code>rttvar</code>（在一个窗口数据期间记录的最大<code>mdev</code>，且最小值为50ms）。仅当进入下一个窗口时，<code>rttvar</code>才可能减小</li>
<li>标准方法中，<code>rttvar</code>所占权重较大（系数为4），因此即使当<code>RTT</code>减小时，也会导致<code>RTO</code>增长。在时钟粒度较粗时，这种情况不会造成很大影响，因为<code>RTO</code>可用值很少。若时钟粒度较细，如Linux的1ms，就可能出现问题。针对<code>RTT</code>减小的情况，若新样本值小于<code>RTT</code>估计范围的下界（<code>srtt - mdev</code>），则减小新样本的权重，完整的关系如下</li>
</ol>
$$\begin{split}
&if (m < (srtt - mdev)) \\
&\;\;\;\;mdev = (\frac{31}{32})mdev + (\frac{1}{32})|srtt-m| \\
&else \\
&\;\;\;\;mdev = (\frac{3}{4})mdev + (\frac{1}{4})|srtt-m|
\end{split}$$
<h3 id="1034-rtt估计器行为"><a class="markdownIt-Anchor" href="#1034-rtt估计器行为"></a> 10.3.4 RTT估计器行为</h3>
<ol>
<li>Linux的<code>RTO</code>始终保持在200ms以上，且避免了所有不必要的重传（尽管可能由于<code>RTO</code>较大，计时器未超时，导致丢包时性能降低）</li>
<li>标准方法可能出现<code>伪重传</code>的问题</li>
</ol>
<h3 id="1035-rttm对丢包和失序的鲁棒性"><a class="markdownIt-Anchor" href="#1035-rttm对丢包和失序的鲁棒性"></a> 10.3.5 RTTM对丢包和失序的鲁棒性</h3>
<ol>
<li>当没有丢包情况时，不论接收端是否延迟发送<code>ACK</code>，<code>TSOPT</code>可以很好地工作。该算法在以下几种情况下都能正确运行
<ul>
<li>失序报文段：当接收端收到失序报文段时，通常是由于在此之前出现了丢包，应当立即返回<code>ACK</code>以启动快速重传算法。<strong>该<code>ACK</code>的<code>TSER</code>部分包含了<code>TSV</code>值为接收端收到最近的有序报文段的时刻（即最新的使窗口前进的报文段，通常不会是失序报文段）</strong>。这会使得发送端<code>RTT</code>样本增大，由此导致相应的<code>RTO</code>增大。这在一定程度上是有利的，即当包失序时，发送端有更多的时间去发现是出现了失序而非丢包，由此可避免不必要的重传</li>
<li>成功重传：当收到接收端缓存中缺失的报文段时（如成功接收重传报文段），窗口通常会前移。此时对应<code>ACK</code>中的<code>TSV</code>值来自最新到达的报文段，这是比较有利的。若采用原来报文段中的<code>TSV</code>，可能对应的是前一个<code>RTO</code>，导致发送端<code>RTT</code>估算的偏离</li>
</ul>
</li>
</ol>
<p><img src="/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/14-3-2.jpg" alt="fig" /></p>
<ul>
<li>第一个<code>ACK</code>，序号为1025，时间戳为1（正常的数据确认）</li>
<li>第二个<code>ACK</code>，序号为1025，时间戳为1（失序的数据确认）</li>
<li>第三个<code>ACK</code>，序号为3073，时间戳为2，该时间戳是报文2而非报文3的时间戳</li>
<li>当分组失序（或丢失）时，<code>RTT</code>会被过高估算。较大的<code>RTT</code>估计值使得<code>RTO</code>也更大，由此发送端也不会急于重传。在失序的情况下这是很有利的，因为过分积极的重传可能导致伪重传</li>
</ul>
<h2 id="104-基于计时器的重传"><a class="markdownIt-Anchor" href="#104-基于计时器的重传"></a> 10.4 基于计时器的重传</h2>
<ol>
<li>在设定计时器之前，需要记录被计时的报文段序列号，若计时收到了该报文段的<code>ACK</code>，那么计时器被取消。之后发送端发送一个新的数据包时，需设定一个新的计时器，并记录新的序列号。因此每个TCP连接的发送端不断地设定和取消一个重传计时器；如果没有数据丢失，则不会出现计时器超时</li>
<li>若在连接设定的<code>RTO</code>内，TCP没有收到被计时的报文段的<code>ACK</code>，将会触发超时重传。当发送重传时，它通过降低当前数据发送率率对此进行快速响应，实现它有两种方法：
<ul>
<li>第一种方法：基于拥塞控制机制减小发送窗口大小</li>
<li>第二种方法：重传时，增大<code>RTO</code>的退避因子<code>RTO = γRTO</code>。通常情况下，<code>γ</code>为1，随着多次重传<code>γ</code>呈加倍增长，同时<code>γ</code>不能超过最大的退避因子，通常是120s。一旦收到<code>ACK</code>，<code>γ</code>会重置为1</li>
</ul>
</li>
</ol>
<h2 id="105-快速重传"><a class="markdownIt-Anchor" href="#105-快速重传"></a> 10.5 快速重传</h2>
<ol>
<li>快速重传机制[RFC5681]，基于接收端的反馈信息来引发重传，而非重传计时器的超时。因此与超时重传相比，快速重传能更加及时有效地修复丢包情况。典型的TCP同时实现了两者</li>
<li>当接收到失序报文段时，TCP需要立即生成确认信息（重复<code>ACK</code>），并且失序情况表明在后续数据到达前出现了丢段，即接收端缓存出现了空缺。<strong>当采用<code>SACK</code>时，重复<code>ACK</code>通常也包含<code>SACK</code>信息，利用该信息可以获知多个空缺</strong></li>
<li>重复<code>ACK</code>（不论是否包含<code>SACK</code>信息）到达发送端表明先前发送的某个分组已丢失。但是重复<code>ACK</code>也可能在另一种情况出现，即当网络中出现失序分组时—若接收端收到当前期盼序列号的后续分组时，当前期盼的包可能丢失，也可能仅为延迟到达。<strong>通常我们无法得知是哪种情况，因此TCP等待一定数据的重复<code>ACK</code>（称为重复<code>ACK</code>阈值或dupthresh，通常为常量值3），来决定数据是否丢失并触发快速重传</strong></li>
<li>快速重传算法概括如下：TCP发送端在观测到至少dupthresh个重复<code>ACK</code>后，即重传可能丢失的数据分组，而不必等到重传计时器超时。当然也可以同时发送新的数据。根据重复<code>ACK</code>推断的包通常与网络拥塞有关，因此伴随快速重传应触发拥塞控制机制。不采用<code>SACK</code>时，接收到有效<code>ACK</code>前之多只能重传一个报文段。采用<code>SACK</code>，<code>ACK</code>可包含额外信息，是的发送端在每个<code>RTT</code>时间内可以填补多个空缺</li>
</ol>
<h2 id="106-带选择确认的重传"><a class="markdownIt-Anchor" href="#106-带选择确认的重传"></a> 10.6 带选择确认的重传</h2>
<ol>
<li>TCP接收端可提供<code>SACK</code>功能，通过TCP头部的累积<code>ACK</code>号字段来描述其接收到的数据。之前提到过，<code>ACK</code>号与接收端缓存中的其他数据之间的间隔称为空缺。序列号高于空缺的数据称为失序数据，因为这些数据和之前接收的序列号不连续</li>
<li>TCP发送端的任务是通过重传丢失的数据来填补接收端缓存中的空缺，但同时也要尽可能保证不重传已正确接收到的数据。在很多环境下，合理采用<code>SACK</code>信息能更快地实现空缺填补，且能减少不必要的重传，原因在于其在一个<code>RTT</code>内能获知多个空缺。当采用<code>SACK</code>选项时，一个<code>ACK</code>可包含三四个告知失序数据的<code>SACK</code>信息。每个<code>SACK</code>信息包含32位的序列号，代表接收端存储的失序数据的起始至最后一个序列号</li>
<li><code>SACK</code>选项指定n个块的长度为<code>8n + 2</code>字节，因此40字节可能包含最多4个块。通常<code>SACK</code>会与<code>TSOPT</code>一同使用，因此需要额外的10个字节，这意味着<code>SACK</code>在每个<code>ACK</code>中只能包含3个块
<ul>
<li>每个<code>SACK</code>块包含8个字节，指明了一个序列号空间（左闭右开），<code>[leftSeqNum, rightSeqNum)</code>，这个序列号空间中的数据已被接收端接收</li>
</ul>
</li>
<li>包含一个或多个<code>SACK</code>块的<code>ACK</code>有时也简单称为<code>SACK</code></li>
</ol>
<h3 id="1061-sack接收端行为"><a class="markdownIt-Anchor" href="#1061-sack接收端行为"></a> 10.6.1 SACK接收端行为</h3>
<ol>
<li>接收端在TCP连接建立时期收到<code>SACK</code>许可选项即可生成<code>SACK</code></li>
<li>通常来说，每当缓存中存在失序数据时，接收端就可生成<code>SACK</code></li>
<li><strong>在一个<code>SACK</code>中，第一个<code>SACK</code>块内包含的是<code>最近接收到的（most recently received）</code>报文段的序列号范围。其余的<code>SACK</code>块包含的内容也按照接收的先后依次排列。也就是说，<code>SACK</code>除了包含最近接收的序列号信息之外，还需重复之前的<code>SACK</code>块</strong></li>
<li>一个<code>SACK</code>选项中包含多个<code>SACK</code>块，并且在多个<code>SACK</code>中重复这些块信息的目的在于，为了防止<code>SACK</code>丢失提供一些备份。若<code>SACK</code>不丢失，那么每个<code>SACK</code>包含一个<code>SACK</code>块即可实现<code>SACK</code>的全部功能。不幸的是，<code>SACK</code>和普通的<code>ACK</code>有时会丢失，且不会被重传（没有数据）</li>
</ol>
<h3 id="1062-sack发送端行为"><a class="markdownIt-Anchor" href="#1062-sack发送端行为"></a> 10.6.2 SACK发送端行为</h3>
<ol>
<li>发送端也应提供<code>SACK</code>功能，并且合理地利用接收到的<code>SACK</code>块来进行丢失重传，该过程也称为<code>选择性重传（selective retransmission）</code>或<code>选择性重发（selective repeat）</code></li>
<li>发送端记录接收到的累积<code>ACK</code>信息（像大多数TCP发送端一样），还需记录接收到的<code>SACK</code>信息，并利用该信息来避免重传正确接收的数据。一种方法是当接收到相应序列号范围的<code>ACK</code>时，则在其重传缓存中标记该报文段的选择重传成功</li>
<li>当<code>SACK</code>发送端执行重传时，通常是由于其收到了<code>SACK</code>或重复<code>ACK</code>，它可以选择发送新数据或重传旧数据。<code>SACK</code>信息提供接收端数据的序列号范围，因此发送端可据此推断需要重传的空缺数据。最简单的方法是使发送方首先填补接收端的空缺，然后再继续发送新数据，这也是最常用的方法</li>
<li>在[RFC2018]中，<code>SACK</code>选项和<code>SACK</code>块的当前规范是<code>建议性的（advisory）</code>。这意味着，接收端可能提供一个<code>SACK</code>告诉发送端已成功接收一定序列号范围的数据，而之后作出变更（食言）。<strong>由于这个原因，<code>SACK</code>发送端不能在收到一个<code>SACK</code>后立即清空其重传缓存中的数据；只有当接收端的普通TCP <code>ACK</code>号大于其最大序列号值时才可清除</strong>。这一规则同样影响重传计时器的行为，当TCP发送端启用基于计时器的重传时，应忽略<code>SACK</code>显示的任何关于接收端失序的信息。如果接收端仍存在失序数据，那么重传报文的<code>ACK</code>就包含附加的<code>SACK</code>块，以便发送者使用</li>
</ol>
<h2 id="107-伪超时与重传"><a class="markdownIt-Anchor" href="#107-伪超时与重传"></a> 10.7 伪超时与重传</h2>
<ol>
<li>在很多情况下，即使数据没有出现丢失也可能引发重传。这种不必要的重传称为<code>伪重传（spurious retransmission）</code>，其主要原因是<code>伪超时（spurious timeout）</code>，其他因素如包失序、包重复，或<code>ACK</code>丢失也可能导致该现象。在实际<code>RTT</code>显著增长，超过当前<code>RTO</code>时，可能出现伪超时</li>
<li>为处理伪超时问题提出了许多方法，这些方法通常包含<code>检测（detection）算法</code>与<code>响应（response）算法</code>
<ul>
<li>检测算法用于判断某个超时或基于计时器的重传是否真实，一旦认定出现伪超时则执行响应算法，用于撤销或减轻该超时带来的影响</li>
</ul>
</li>
</ol>
<h3 id="1071-重复sackdsack扩展"><a class="markdownIt-Anchor" href="#1071-重复sackdsack扩展"></a> 10.7.1 重复SACK（DSACK）扩展</h3>
<ol>
<li>在非<code>SACK</code>的TCP中，<code>ACK</code>只能向发送端告知最大的有序报文段。采用<code>SACK</code>则可告知其他的（失序）报文段。基本的<code>SACK</code>机制对接收端收到重复数据段时怎样运作没有规定</li>
<li><strong>在<code>SACK</code>接收端采用<code>DSACK</code>（或称作<code>D-SACK</code>），及重复<code>SACK</code>，并结合通常的<code>SACK</code>发送端，可在第一个<code>SACK</code>块中告知接收端收到的重复报文段序列号</strong>。<code>DSACK</code>的主要目的是判断何时的重传是不必要的，并了解网络中的其他事项。因此发送端至少可以推断是否发生了包失序、<code>ACK</code>丢失、包重复或伪重传</li>
<li><code>DSACK</code>相比于传统<code>SACK</code>并不需要额外的协商过程。为使其正常工作，接收端返回的<code>SACK</code>的内容会有所改变，对应的发送端的响应也会随之变化</li>
<li><strong><code>DSACK</code>相比于传统<code>SACK</code>，其接收端的变化在于：第一个<code>SACK</code>块允许包含序列号小于（或等于）累积<code>ACK</code>号字段的<code>SACK</code></strong>
<ul>
<li>如果第一个<code>SACK</code>块允许包含序列号小于累积<code>ACK</code>，则表明第一个<code>SACK</code>块的数据空间被至少接收了两次</li>
<li>如果第一个<code>SACK</code>块允许包含序列号大于累积<code>ACK</code>，则需要比较第一个<code>SACK</code>块的序列号空间与第二个<code>SACK</code>块的序列号空间是否有重复（如果有第二个<code>SACK</code>块的话）</li>
</ul>
</li>
<li><code>DSACK</code>信息不会再多个<code>SACK</code>中重复。因此<code>DSACK</code>较通常的<code>SACK</code>鲁棒性低</li>
</ol>
<h3 id="1072-eifel检测算法"><a class="markdownIt-Anchor" href="#1072-eifel检测算法"></a> 10.7.2 Eifel检测算法</h3>
<ol>
<li>实验性的<code>Eifel检测算法</code>[RFC3522]利用了TCP的<code>TSOPT</code>来检测伪重传。在发生超时重传后，<code>Eifel</code>算法等待接收下一个<code>ACK</code>，若为针对第一次传输（即原始传输）的确认，则判定该重传为伪重传</li>
<li>利用<code>Eifel</code>检测算法能比仅采用<code>DSACK</code>更早检测到伪重传行为，因为它判断伪重传的<code>ACK</code>是在启动丢失恢复之前生成的。相反，<code>DSACK</code>只有在重复报文段到达接收端后才能发送，并且在<code>DSACK</code>返回至发送端才能有所响应</li>
<li><code>Eifel</code>检测算法的机制很简单，他需要使用TCP的<code>TSOPT</code>，当发送一个重传（不论是基于计时器的重传还是快速重传）后，保存其<code>TSV</code>值。当接收到相应分组的<code>ACK</code>后，检查该<code>ACK</code>的<code>TSER</code>部分：若<code>TSER</code>值小于之前存储的<code>TSV</code>值，则可判断该<code>ACK</code>对应的是原始传输分组，即该重传是伪重传</li>
<li><code>Eifel</code>检测算法可与<code>DSACK</code>结合使用，这样可以解决整个窗口的<code>ACK</code>信息均丢失，但原始传输和重传分组都成功到达接收端的情况。在这种特殊情况下，重传分组的到达会生成一个<code>DSACK</code>。<code>Eifel</code>检测算法会理所当然地认定出现了伪重传。然而，在出现了如此多的的<code>ACK</code>丢失的情况下，使得TCP相信该重传不是伪重传是有用的（例如，使其减慢发送速率–采用拥塞控制的后果）。因此，<code>DSACK</code>的到达会使得<code>Eifel</code>检测算法认定相应的重传不是伪重传</li>
</ol>
<h3 id="1073-前移rto恢复f-rto"><a class="markdownIt-Anchor" href="#1073-前移rto恢复f-rto"></a> 10.7.3 前移RTO恢复（F-RTO）</h3>
<ol>
<li><code>前移RTO恢复（Forward-RTO Recovery，F-RTO）</code>是检测伪重传的标准算法。它不需要任何TCP选项，因此只要在发送端实现该方法后，即使针对不支持<code>TSOPT</code>的接收端也能有效工作。该算法只检测由重传计时器引发的伪重传；对之前提到的其他原因引起的伪重传则无法判断</li>
<li>在一次基于计时器的重传之后，<code>F-RTO</code>会对TCP的常用行为作出一定修改。由于这类重传针对的是没有收到<code>ACK</code>信息的最小序列号，通常情况下，TCP会继续按序发送相邻的分组，这就是前面描述的“回退N”行为</li>
<li><strong><code>F-RTO</code>会修改TCP的行为，基本思路是：在超时之后发送新数据（非重传数据），并观察之后的两个<code>ACK</code>，若两个<code>ACK</code>都不是重复<code>ACK</code>（是否与超时之前收到的<code>ACK</code>序列号相同），那么就认为是伪重传</strong>
<ul>
<li>可能情况1：数据包并未丢失而只是delay了，接收端在收到该delay数据包后，回复相应的<code>ACK</code>，使得窗口前移（该<code>ACK</code>肯定不是重复<code>ACK</code>）</li>
<li>可能情况2：数据包正常接收，只是<code>ACK</code>丢失了，那么接收端在收到新的数据后（计时器超时后发送的新数据），回复相应的<code>ACK</code>，使得窗口前移（该<code>ACK</code>肯定不是冗余重复<code>ACK</code>）</li>
</ul>
</li>
</ol>
<h3 id="1074-eifel响应算法"><a class="markdownIt-Anchor" href="#1074-eifel响应算法"></a> 10.7.4 Eifel响应算法</h3>
<ol>
<li>一旦判断出现伪重传，则会引发一套标准操作，即<code>Eifel响应算法</code>[RFC4015]</li>
<li>响应算法逻辑上与<code>Eifel</code>检测算法分离，所以它可以与我们前面讨论的任何一种检测方法结合使用。原则上超时重传和快速重传都可使用<code>Eifel</code>响应算法，单目前只针对超时重传做了相关规定</li>
<li>尽管<code>Eifel</code>响应算法可结合其他检测算法使用，但根据是否能尽早（如<code>Eifel</code>检测算法或<code>F-RTO</code>）或较迟（如<code>DSACK</code>）检测出伪超时的不同而有所区别
<ul>
<li>前者称为<code>伪超时</code>，通过检查<code>ACK</code>或原始传输来实现</li>
<li>后者称为<code>迟伪超时</code>，基于由（伪）超时而引发的重传所返回的<code>ACK</code>来判定</li>
</ul>
</li>
<li>响应算法只针对第一种重传事件。若在恢复阶段完成之前再次发生超时，则不会执行响应算法。在重传计时器超时后，它会查看<code>srtt</code>和<code>rttvar</code>的值，并按如下方式记录新的变量<code>srtt_prev</code>和<code>rttvar_prev</code>
<ul>
<li>在任何一次计时器超时后，都会指定这两个变量，但只有在判定出现伪超时时才会使用它们，用于设定新的<code>RTO</code></li>
<li><code>G</code>代表时钟粒度。$srtt\_prev$设置为<code>srtt</code>加上两倍的时钟粒度是由于：<code>srtt</code>的值过小，可能出现伪超时。如果<code>srtt</code>稍大，就可能不会发生超时</li>
</ul>
</li>
</ol>
$$\begin{split}
srtt\_prev &= srtt + 2(G) \\
rttvar\_prev &= rttvar
\end{split}$$
<ol>
<li>完成$srtt\_prev$和$rttvar\_prev$的存储后，就要触发某种检测算法。运行检测算法后可得到一个特殊的值，称为<code>伪恢复（SpuriousRecovery）</code>。如果检测到一次<code>伪超时</code>，则将<code>伪恢复</code>设置为<code>SPUR_TO</code>。如果检测到<code>迟伪超时</code>，则将其设置为<code>LATE_SPUR_TO</code>。否则，该次超时为正常超时，TCP继续执行正常的响应行为</li>
<li>若<code>伪恢复</code>为<code>SPUR_TO</code>，TCP可在恢复阶段完成之前进行操作，通过将下一个要发送的报文段（称为<code>SND.NXT</code>）的序列号修改为最新的未发送过的报文段（称为<code>SND.MAX</code>），这样就可在首次重传后避免不必要的“回退N”行为。若<code>伪恢复</code>为<code>LATE_SPUR_TO</code>，此时已收到首次重传的<code>ACK</code>，则<code>SND.NXT</code>不改变。以上两种情况中，都要重新设置拥塞控制状态，并且一旦接收到重传计时器超时后发送的报文段的<code>ACK</code>，就要按如下方式更新<code>srtt</code>、<code>rttvar</code>和<code>RTO</code>
<ul>
<li><code>m</code>是一个<code>RTT</code>样本值，它是基于超时后收个发送数据收到的<code>ACK</code>而计算得到的</li>
<li>进行这些变量更新的目的在于：实际的<code>RTT</code>值可能发生了很大变化，<code>RTT</code>当前估计值已不适用于设置<code>RTO</code>。若路径上的实际<code>RTT</code>突然增大，当前的<code>srtt</code>和<code>rttvar</code>就显得过小，应重新设置；而另一方面，<code>RTT</code>的增大可能只是暂时的，这时重新设置<code>srtt</code>和<code>rttvar</code>就不那么明智了，因为它们原先的值可能更为精确</li>
</ul>
</li>
</ol>
$$\begin{split}
srtt &= max(srtt\_prev, m) \\
rttvar &= max(rttvar\_prev, \frac{m}{2}) \\
RTO &= srtt + max(G, 4(rttvar))
\end{split}$$
<ol>
<li>在新<code>RTT</code>样本值较大的情况下，上述等式尽力获得上述两种情况的平衡。这样做可以有效地抛弃之前的<code>RTT</code>历史值（和<code>RTT</code>的历史变化情况）。只有在响应算法中<code>srtt</code>和<code>rttvar</code>的值才会增大。若<code>RTT</code>不会增大，则维持估计值不变，这本质上是忽略超时情况发生。两种情况中，<code>RTO</code>还是按正常方式进行鞥新，并针对此次超时设置新的重传计时器值</li>
</ol>
<h2 id="108-包失序与包重复"><a class="markdownIt-Anchor" href="#108-包失序与包重复"></a> 10.8 包失序与包重复</h2>
<h3 id="1081-失序"><a class="markdownIt-Anchor" href="#1081-失序"></a> 10.8.1 失序</h3>
<ol>
<li>在IP网络中出现包失序的原因在于IP层不能保证包传输是有序进行的。对IP层来说，这样做是有利的，因为IP可以选择另一条传输链路（例如传输速度更快的路径），而不用担心新发送的分组会先于旧数据到达，这就导致数据的接收顺序与发送顺序不一致。此外，在硬件方面一些高性能路由器会采用多个并行数据链路，不同的处理延时也会导致包的离开顺序与到达顺序不匹配</li>
<li>失序问题也可能存在于TCP连接的正向或反向链路中。数据段的失序与<code>ACK</code>包的失序对TCP的影响有一定差别
<ul>
<li>如果失序发生在反向（<code>ACK</code>）链路，就会使得TCP发送端窗口快速前移，接着有可能收到一些显然重复而应被丢弃的<code>ACK</code>。由于TCP的拥塞控制行为，这种情况会导致发送端出现不必要的流量突发（瞬时高速发送）行为，影响可用网络带宽</li>
<li>如果失序发生在正向链路，TCP可能无法正确识别失序和丢包。数据的丢失和失序都会导致接收端收到无序的包，造成数据之间的空缺。当失序程度不是很大（如两个相邻的包交换顺序），这种情况可以迅速得到处理。反之，当出现严重失序时，TCP会误认为数据包已经丢失，这种情况会造成伪重传，主要来自快速重传算法</li>
</ul>
</li>
<li>区分丢包与失序不是一个很重要的问题。要解决它要判断发送端是否已经等待了足够长的时间来填补空缺。幸运的是，互联网中严重的失序并不常见，因此将<code>dupthresh</code>（快速重传的<code>ACK</code>重复次数）设置为相对较小的值（默认是3）就能处理绝大部分情况。其他严重的情况可以通过调整<code>dupthresh</code>来应对</li>
</ol>
<h3 id="1082-重复"><a class="markdownIt-Anchor" href="#1082-重复"></a> 10.8.2 重复</h3>
<ol>
<li>尽管出现的比较少，IP协议也可能出现将单个包传输多次的情况。例如，当链路层网络协议执行一次重传，并生成同一个包的两个副本。当重复生成时，TCP可能出现混淆</li>
<li>包的多次重复会使得接收端生成一系列重复<code>ACK</code>，有可能触发伪快速重传，对于非<code>SACK</code>的发送端就会产生误解。利用<code>SACK</code>（特别是<code>DSACK</code>）可以简单地忽略这个问题</li>
</ol>
<h2 id="109-目的度量"><a class="markdownIt-Anchor" href="#109-目的度量"></a> 10.9 目的度量</h2>
<ol>
<li>TCP能不断“学习”发送端与接收端之间的链路特征。学习的结果显示为发送端记录一些状态变量，如<code>srtt</code>和<code>rttvar</code>。一些TCP实现也记录一段时间内已出现的失序包的估计值。一般来说，一旦该连接关闭，这些学习结果也会丢失。即与一个接收端建立一个新的TCP连接后，他必须从头开始获得状态变量值</li>
<li>较新的TCP实现维护了这些度量值，即使在连接断开后，也能保存之前存在的路由或转发表项，或其他的一些系统数据结构。当创立一个新的连接时，首先查看数据结构中是否存在于该目的端的先前通信信息。如果存在，则选择较近的信息，据此为<code>srtt</code>和<code>rttvar</code>以及其他变量设初值。在Linux中可以通过命令<code>ip route show cache 1.1.1.1</code>查看这些变量值</li>
</ol>
<h2 id="1010-重新组包"><a class="markdownIt-Anchor" href="#1010-重新组包"></a> 10.10 重新组包</h2>
<ol>
<li>当TCP超时重传，他并不需要完全重传相同的报文段。TCP允许执行<code>重新组包（repacketization）</code>，发送一个更大的报文段来提高性能（通常该更大的报文段不能超过接收端通告的<code>MSS</code>，也不能大于路径MTU）</li>
<li>TCP能重传一个与元报文段不同大小的报文段，这从一定意义上解决了重传二义性的问题。STODER[TZZ05]就是基于该思想，采用重新组包的方法来检测伪超时</li>
</ol>
<h2 id="1011-与tcp重传相关的攻击"><a class="markdownIt-Anchor" href="#1011-与tcp重传相关的攻击"></a> 10.11 与TCP重传相关的攻击</h2>
<ol>
<li>有一类DoS攻击称为低速率DoS攻击[KK03]。在这类攻击中，攻击者向网关或主机发送大量数据，使得受害系统持续处于重传超时的状态。由于攻击者可预知受害者TCP何时启动重传，并在每次重传时生成并发送大量数据。因此，受害TCP总能感知到拥塞的存在，根据Karn算法不断减小发送速率并退避发送，导致无法正常使用网络带宽。针对此类攻击的预防方法就是随机选择<code>RTO</code>，使得攻击者无法预知确切的重传时间</li>
<li>与DoS相关但不同的一种攻击为减慢受害者TCP的发送，使得<code>RTT</code>估计值过大。这样受害者在丢包后不会立即重传。相反的攻击也是有可能的：攻击者在数据发送完成但还未到达接收端时伪造<code>ACK</code>。这样攻击者就能使受害者TCP认为连接的<code>RTT</code>远小于实际值，导致过分发送，造成大量的无效传输</li>
</ol>
<h1 id="11-tcp数据流与窗口管理"><a class="markdownIt-Anchor" href="#11-tcp数据流与窗口管理"></a> 11 TCP数据流与窗口管理</h1>
<h2 id="111-引言"><a class="markdownIt-Anchor" href="#111-引言"></a> 11.1 引言</h2>
<ol>
<li>本章探讨TCP的动态数据传输，首先关注交互式连接，接着介绍流量控制以及窗口管理规范</li>
<li>“交互式”TCP连接是指，该连接需要在客户端和服务器之间传输用户输入信息，如按键操作、短消息、操作杆或鼠标的动作等。如采用较小的报文段来承载这些用户信息，那么传输协议需要耗费很高的代价，因为每个交换分组中包含的有效负载字节较少。反之，报文段较大则会引入更大的延时，对延迟敏感类应用（如在线游戏、协同工具等）造成负面影响。因此需要权衡相关因素，找到折中方法</li>
</ol>
<h2 id="112-交互式通信"><a class="markdownIt-Anchor" href="#112-交互式通信"></a> 11.2 交互式通信</h2>
<ol>
<li>按照TCP数据段大小的不同，大致可以分为两类，<code>大批量数据</code>和<code>交互式数据</code>。批量数据段通常较大（1500字节或更大），而交互式数据段则会比较小（几十字节的用户数据）</li>
<li>对于ssh这一应用，许多TCP/IP的初学者会惊奇地发现，每个交互按键都通常会生成一个单独的数据包。也就是说，每个按键是独立传输的。另外，ssh会在远程系统（服务器端）调用一个shell（命令解释器），对客户端的输入字符作出回显。因此，每个输入的字符会生成4个TCP数据段
<ol>
<li>客户端的交互击键输入</li>
<li>服务器端对击键的确认</li>
<li>服务器端生成的回显</li>
<li>客户端对该回显的确认</li>
</ol>
<ul>
<li>通常，第2段和第3段可以合并</li>
</ul>
</li>
</ol>
<h1 id="12-其他"><a class="markdownIt-Anchor" href="#12-其他"></a> 12 其他</h1>
<h2 id="121-流量控制"><a class="markdownIt-Anchor" href="#121-流量控制"></a> 12.1 流量控制</h2>
<p><img src="/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/flow_control.jpeg" alt="flow_control" /></p>
<p><strong>流量控制，是利用灵活可变的滑动窗口控制流量，是为了解决发送数据扩快导致接收方来不及接收的问题</strong></p>
<p><strong>发送方缓存中的数据可以分成如下4类</strong></p>
<ol>
<li>已发送，并且收到ack</li>
<li>已发送，未收到ack</li>
<li>未发送，允许发送</li>
<li>未发送，不允许发送</li>
</ol>
<ul>
<li>其中<code>2</code>和<code>3</code>这两类属于滑动窗口的范围</li>
</ul>
<h2 id="122-拥塞控制"><a class="markdownIt-Anchor" href="#122-拥塞控制"></a> 12.2 拥塞控制</h2>
<p><img src="/images/TCP-IP%E8%AF%A6%E8%A7%A3-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/cwnd.png" alt="cwnd" /></p>
<p><strong>拥塞控制，是为了避免过多的流量注入网络使得网络过载。具体方法包括：慢开始、拥塞避免、快重传和快恢复</strong></p>
<ul>
<li><strong>慢开始</strong>：拥塞窗口从一个较小的值开始，指数增长</li>
<li><strong>拥塞避免</strong>：拥塞窗口增长到指定阈值后，线性增长</li>
<li><strong>快重传</strong>：同一个ack重复发3次，触发发送端的快速重传，避免等待超时浪费时间</li>
<li><strong>快恢复</strong>：当触发快速重传时，可能仅发生了乱序，而网络实际上还是正常的，因此没必要将拥塞窗口调成最小值，而是将拥塞窗口调整到阈值附近</li>
</ul>
<h1 id="13-参考"><a class="markdownIt-Anchor" href="#13-参考"></a> 13 参考</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/shenwansangz/article/details/38400919">传输层学习之五（TCP的SACK，F-RTO）</a></li>
<li><a target="_blank" rel="noopener" href="http://www.2cto.com/net/201310/251896.html">TCP/IP协议三次握手与四次握手流程解析</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/zhushuai1221/article/details/51008950">TCP/IP为什么要进行三次握手？</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/a987073381/article/details/52206215">计算机网络——TCP协议中的三次握手四次挥手以及11种状态转换</a></li>
<li><a target="_blank" rel="noopener" href="https://my.oschina.net/woyaoxue/blog/510669?p=1">TIME_WAIT状态作用!</a></li>
<li><a target="_blank" rel="noopener" href="https://www.huaweicloud.com/articles/ba31660f82bbdd3a3e8615ec68d85bc3.html">TCP流量控制和拥塞控制简述</a></li>
<li><a target="_blank" rel="noopener" href="https://www.huaweicloud.com/articles/912cb7c3b49f2a5bc792a140bb4d7a87.html">TCP的拥塞控制（详解）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/32255109/answer/898371009">TCP协议的滑动窗口具体是怎样控制流量的？</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102382380">TCP的拥塞避免</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%91%98%E5%BD%95/" rel="tag"># 摘录</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/10/27/Linux-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" rel="prev" title="Linux-性能分析">
      <i class="fa fa-chevron-left"></i> Linux-性能分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/11/20/Kubernetes-%E9%98%BF%E9%87%8C%E4%BA%91%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="Kubernetes-阿里云公开课学习笔记">
      Kubernetes-阿里云公开课学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-livere">livere</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzY0My8xMDE5OA=="></div>
  </div>
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-text"> 1 概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-text"> 2 链路层</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE"><span class="nav-text"> 3 网际协议</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-arp-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE"><span class="nav-text"> 4 ARP: 地址解析协议</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-rarp-%E9%80%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE"><span class="nav-text"> 5 RARP: 逆地址解析协议</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-icmp-internet%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE"><span class="nav-text"> 6 ICMP: Internet控制报文协议</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E9%98%B2%E7%81%AB%E5%A2%99%E5%92%8C%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="nav-text"> 7 防火墙和网络地址转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#71-%E9%98%B2%E7%81%AB%E5%A2%99"><span class="nav-text"> 7.1 防火墙</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#711-%E5%8C%85%E8%BF%87%E6%BB%A4%E9%98%B2%E7%81%AB%E5%A2%99"><span class="nav-text"> 7.1.1 包过滤防火墙</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#712-%E4%BB%A3%E7%90%86%E9%98%B2%E7%81%AB%E5%A2%99"><span class="nav-text"> 7.1.2 代理防火墙</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-tcp-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%E5%88%9D%E6%AD%A5"><span class="nav-text"> 8 TCP: 传输控制协议（初步）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-tcp%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-text"> 9 TCP连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#91-tcp%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E7%BB%88%E6%AD%A2"><span class="nav-text"> 9.1 TCP连接的建立与终止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#92-tcp%E9%80%89%E9%A1%B9"><span class="nav-text"> 9.2 TCP选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#921-%E6%9C%80%E5%A4%A7%E6%AE%B5%E5%A4%A7%E5%B0%8F%E9%80%89%E9%A1%B9"><span class="nav-text"> 9.2.1 最大段大小选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#922-%E9%80%89%E6%8B%A9%E7%A1%AE%E8%AE%A4%E9%80%89%E9%A1%B9"><span class="nav-text"> 9.2.2 选择确认选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#923-%E7%AA%97%E5%8F%A3%E7%BC%A9%E6%94%BE%E5%9B%A0%E5%AD%90"><span class="nav-text"> 9.2.3 窗口缩放因子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#924-%E6%97%B6%E9%97%B4%E6%88%B3%E9%80%89%E9%A1%B9%E4%B8%8E%E9%98%B2%E5%9B%9E%E7%BB%95%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="nav-text"> 9.2.4 时间戳选项与防回绕序列号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#925-%E7%94%A8%E6%88%B7%E8%B6%85%E6%97%B6%E9%80%89%E9%A1%B9"><span class="nav-text"> 9.2.5 用户超时选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#926-%E8%AE%A4%E8%AF%81%E9%80%89%E9%A1%B9"><span class="nav-text"> 9.2.6 认证选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#93-tcp%E7%9A%84%E8%B7%AF%E5%BE%84%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83%E5%8F%91%E7%8E%B0"><span class="nav-text"> 9.3 TCP的路径最大传输单元发现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#94-tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-text"> 9.4 TCP状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#941-time_wait%E7%8A%B6%E6%80%81"><span class="nav-text"> 9.4.1 TIME_WAIT状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#942-close_wait%E7%8A%B6%E6%80%81"><span class="nav-text"> 9.4.2 CLOSE_WAIT状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#943-%E9%9D%99%E9%BB%98%E6%97%B6%E9%97%B4%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text"> 9.4.3 静默时间的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#944-fin_wait_2%E7%8A%B6%E6%80%81"><span class="nav-text"> 9.4.4 FIN_WAIT_2状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#945-%E5%90%8C%E6%97%B6%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text"> 9.4.5 同时打开与关闭的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#95-%E9%87%8D%E7%BD%AE%E6%8A%A5%E6%96%87%E6%AE%B5rst"><span class="nav-text"> 9.5 重置报文段RST</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#951-%E9%92%88%E5%AF%B9%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82"><span class="nav-text"> 9.5.1 针对不存在端口的连接请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#952-%E7%BB%88%E6%AD%A2%E4%B8%80%E6%9D%A1%E8%BF%9E%E6%8E%A5"><span class="nav-text"> 9.5.2 终止一条连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#953-%E5%8D%8A%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="nav-text"> 9.5.3 半开连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#954-%E6%97%B6%E9%97%B4%E7%AD%89%E5%BE%85%E9%94%99%E8%AF%AF"><span class="nav-text"> 9.5.4 时间等待错误</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#96-%E4%B8%8Etcp%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%94%BB%E5%87%BB"><span class="nav-text"> 9.6 与TCP连接管理相关的攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#961-syn%E6%B3%9B%E6%B4%AA"><span class="nav-text"> 9.6.1 SYN泛洪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#962-%E5%8A%AB%E6%8C%81"><span class="nav-text"> 9.6.2 劫持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#963-%E6%AC%BA%E9%AA%97%E6%94%BB%E5%87%BB"><span class="nav-text"> 9.6.3 欺骗攻击</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-tcp%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0"><span class="nav-text"> 10 TCP超时与重传</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#101-%E6%A6%82%E8%A6%81"><span class="nav-text"> 10.1 概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#102-%E7%AE%80%E5%8D%95%E7%9A%84%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0"><span class="nav-text"> 10.2 简单的超时与重传</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#103-%E8%AE%BE%E7%BD%AE%E9%87%8D%E4%BC%A0%E8%B6%85%E6%97%B6"><span class="nav-text"> 10.3 设置重传超时</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1031-%E7%BB%8F%E5%85%B8%E6%96%B9%E6%B3%95"><span class="nav-text"> 10.3.1 经典方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1032-%E6%A0%87%E5%87%86%E6%96%B9%E6%B3%95"><span class="nav-text"> 10.3.2 标准方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10321-%E6%97%B6%E9%92%9F%E7%B2%92%E5%BA%A6%E4%B8%8Erto%E8%BE%B9%E7%95%8C"><span class="nav-text"> 10.3.2.1 时钟粒度与RTO边界</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10322-%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="nav-text"> 10.3.2.2 初始值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10323-%E9%87%8D%E4%BC%A0%E4%BA%8C%E4%B9%89%E6%80%A7%E4%B8%8Ekarn%E7%AE%97%E6%B3%95"><span class="nav-text"> 10.3.2.3 重传二义性与Karn算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10324-%E5%B8%A6%E6%97%B6%E9%97%B4%E6%88%B3%E9%80%89%E9%A1%B9%E7%9A%84rtt%E6%B5%8B%E9%87%8F"><span class="nav-text"> 10.3.2.4 带时间戳选项的RTT测量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1033-linux%E9%87%87%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text"> 10.3.3 Linux采用的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1034-rtt%E4%BC%B0%E8%AE%A1%E5%99%A8%E8%A1%8C%E4%B8%BA"><span class="nav-text"> 10.3.4 RTT估计器行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1035-rttm%E5%AF%B9%E4%B8%A2%E5%8C%85%E5%92%8C%E5%A4%B1%E5%BA%8F%E7%9A%84%E9%B2%81%E6%A3%92%E6%80%A7"><span class="nav-text"> 10.3.5 RTTM对丢包和失序的鲁棒性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#104-%E5%9F%BA%E4%BA%8E%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9A%84%E9%87%8D%E4%BC%A0"><span class="nav-text"> 10.4 基于计时器的重传</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#105-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="nav-text"> 10.5 快速重传</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#106-%E5%B8%A6%E9%80%89%E6%8B%A9%E7%A1%AE%E8%AE%A4%E7%9A%84%E9%87%8D%E4%BC%A0"><span class="nav-text"> 10.6 带选择确认的重传</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1061-sack%E6%8E%A5%E6%94%B6%E7%AB%AF%E8%A1%8C%E4%B8%BA"><span class="nav-text"> 10.6.1 SACK接收端行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1062-sack%E5%8F%91%E9%80%81%E7%AB%AF%E8%A1%8C%E4%B8%BA"><span class="nav-text"> 10.6.2 SACK发送端行为</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#107-%E4%BC%AA%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0"><span class="nav-text"> 10.7 伪超时与重传</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1071-%E9%87%8D%E5%A4%8Dsackdsack%E6%89%A9%E5%B1%95"><span class="nav-text"> 10.7.1 重复SACK（DSACK）扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1072-eifel%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95"><span class="nav-text"> 10.7.2 Eifel检测算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1073-%E5%89%8D%E7%A7%BBrto%E6%81%A2%E5%A4%8Df-rto"><span class="nav-text"> 10.7.3 前移RTO恢复（F-RTO）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1074-eifel%E5%93%8D%E5%BA%94%E7%AE%97%E6%B3%95"><span class="nav-text"> 10.7.4 Eifel响应算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#108-%E5%8C%85%E5%A4%B1%E5%BA%8F%E4%B8%8E%E5%8C%85%E9%87%8D%E5%A4%8D"><span class="nav-text"> 10.8 包失序与包重复</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1081-%E5%A4%B1%E5%BA%8F"><span class="nav-text"> 10.8.1 失序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1082-%E9%87%8D%E5%A4%8D"><span class="nav-text"> 10.8.2 重复</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#109-%E7%9B%AE%E7%9A%84%E5%BA%A6%E9%87%8F"><span class="nav-text"> 10.9 目的度量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1010-%E9%87%8D%E6%96%B0%E7%BB%84%E5%8C%85"><span class="nav-text"> 10.10 重新组包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1011-%E4%B8%8Etcp%E9%87%8D%E4%BC%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E6%94%BB%E5%87%BB"><span class="nav-text"> 10.11 与TCP重传相关的攻击</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-tcp%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86"><span class="nav-text"> 11 TCP数据流与窗口管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#111-%E5%BC%95%E8%A8%80"><span class="nav-text"> 11.1 引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#112-%E4%BA%A4%E4%BA%92%E5%BC%8F%E9%80%9A%E4%BF%A1"><span class="nav-text"> 11.2 交互式通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E5%85%B6%E4%BB%96"><span class="nav-text"> 12 其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#121-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-text"> 12.1 流量控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text"> 12.2 拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-%E5%8F%82%E8%80%83"><span class="nav-text"> 13 参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liuyehcf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Liuyehcf</p>
  <div class="site-description" itemprop="description">大音希声，大象无形</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">279</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">102</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liuyehcf</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qhEhLuMeMOy1zgcBhkqUS6P8-gzGzoHsz',
      appKey     : 'uhkruDLNLNdL5rQjRBY2X9Ke',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
