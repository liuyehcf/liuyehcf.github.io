<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="阅读更多">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp-相关知识点">
<meta property="og:url" content="http://example.com/2021/08/19/Cpp-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="Liuye Blog">
<meta property="og:description" content="阅读更多">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-19T01:38:42.000Z">
<meta property="article:modified_time" content="2021-09-05T03:48:08.171Z">
<meta property="article:author" content="Liuyehcf">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/08/19/Cpp-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Cpp-相关知识点 | Liuye Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Liuye Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-explore">

    <a href="/explore/" rel="section"><i class="fa fa-sitemap fa-fw"></i>发现</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/19/Cpp-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Liuyehcf">
      <meta itemprop="description" content="大音希声，大象无形">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liuye Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Cpp-相关知识点
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-19 09:38:42" itemprop="dateCreated datePublished" datetime="2021-08-19T09:38:42+08:00">2021-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-05 11:48:08" itemprop="dateModified" datetime="2021-09-05T11:48:08+08:00">2021-09-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          
            <span id="/2021/08/19/Cpp-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-meta-item leancloud_visitors" data-flag-title="Cpp-相关知识点" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/08/19/Cpp-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/08/19/Cpp-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>阅读更多</strong></p>
<a id="more"></a>
<h1 id="1-语法"><a class="markdownIt-Anchor" href="#1-语法"></a> 1 语法</h1>
<h2 id="11-c11新特性"><a class="markdownIt-Anchor" href="#11-c11新特性"></a> 1.1 c++11新特性</h2>
<ol>
<li><code>auto</code>与<code>decltype</code>类型推导</li>
<li><code>default</code>与<code>delete</code>函数</li>
<li><code>final</code>与<code>override</code></li>
<li>尾置返回类型</li>
<li>右值引用</li>
<li>移动构造函数与移动赋值运算符</li>
<li>有作⽤域的枚举</li>
<li><code>constexpr</code>与字⾯类型</li>
<li>扩展「初始化列表」的适⽤范围</li>
<li>委托与继承的构造函数</li>
<li>花括号或等号初始化器</li>
<li>空指针<code>nullptr</code></li>
<li><code>long long</code></li>
<li><code>char16_t</code>与<code>char32_t</code></li>
<li><code>using</code>定义类型别名</li>
<li>变长参数模板</li>
<li>推⼴的（⾮平凡）联合体</li>
<li>推⼴的<code>POD</code>（平凡类型与标准布局类型）</li>
<li><code>Unicode</code>字符串字⾯量</li>
<li>⽤户定义字⾯量</li>
<li>属性，用于提供额外信息</li>
<li><code>Lambda</code>表达式</li>
<li><code>noexcept</code>说明符与<code>noexcept</code>运算符</li>
<li><code>alignof</code>与<code>alignas</code></li>
<li>多线程内存模型</li>
<li>线程局部存储，<code>thread_local</code>关键词</li>
<li><code>GC</code>接口，<code>declare_reachable</code>与<code>undeclare_reachable</code>（并未实现）</li>
<li>基于范围的for循环</li>
<li><code>static_assert</code></li>
<li>智能指针</li>
</ol>
<h2 id="12-c14新特性"><a class="markdownIt-Anchor" href="#12-c14新特性"></a> 1.2 c++14新特性</h2>
<ol>
<li>变量模板</li>
<li>泛型<code>Lambda</code></li>
<li><code>Lambda</code>初始化捕获右值对象</li>
<li><code>new/delete</code>消除</li>
<li><code>constexpr</code>函数上放松的限制</li>
<li>⼆进制字⾯量，<code>0b101010</code></li>
<li>数字分隔符，<code>100'0000</code></li>
<li>函数的返回类型推导</li>
<li>带默认成员初始化器的聚合类</li>
<li><code>decltype(auto)</code></li>
</ol>
<h2 id="13-c17新特性"><a class="markdownIt-Anchor" href="#13-c17新特性"></a> 1.3 c++17新特性</h2>
<ol>
<li>折叠表达式</li>
<li>类模板实参推导</li>
<li><code>auto</code>占位的⾮类型模板形参</li>
<li>编译期的<code>constexpr if</code>语句</li>
<li>内联变量，<code>inline</code>变量</li>
<li>结构化绑定</li>
<li><code>if/switch</code>语句的变量初始化</li>
<li><code>u8-char</code></li>
<li>简化的嵌套命名空间</li>
<li><code>using</code>声明语句可以声明多个名称</li>
<li>将<code>noexcept</code>作为类型系统的一部分</li>
<li>新的求值顺序规则</li>
<li>强制的复制消除</li>
<li><code>Lambda</code>表达式捕获<code>*this</code></li>
<li><code>constexpr</code>的<code>Lambda</code>表达式</li>
<li>属性命名空间不必重复</li>
<li>新属性<code>[[fallthrough]]</code>、<code>[[nodiscard]]</code>和<code>[[maybe_unused]]</code></li>
<li><code>__has_include</code></li>
</ol>
<h2 id="14-c20新特性"><a class="markdownIt-Anchor" href="#14-c20新特性"></a> 1.4 C++20新特性</h2>
<ol>
<li>特性测试宏</li>
<li>三路比较运算符<code>&lt;=&gt;</code></li>
<li>范围<code>for</code>中的初始化语句和初始化器</li>
<li><code>char8_t</code></li>
<li><code>[[no_unique_address]]</code></li>
<li><code>[[likely]]</code>与<code>[[unlikely]]</code></li>
<li><code>Lambda</code>初始化捕获中的包展开</li>
<li>移除了在多种上下文语境中，使用<code>typename</code>关键字以消除类型歧义的要求</li>
<li><code>consteval</code>、<code>constinit</code></li>
<li>更为宽松的<code>constexpr</code>要求</li>
<li>规定有符号整数以补码实现</li>
<li>使用圆括号的聚合初始化</li>
<li>协程</li>
<li>模块</li>
<li>限定与概念(concepts)</li>
<li>缩略函数模板</li>
<li>数组长度推导</li>
</ol>
<h2 id="15-throw与异常"><a class="markdownIt-Anchor" href="#15-throw与异常"></a> 1.5 throw与异常</h2>
<p>throw关键字可以抛出任何对象，例如可以抛出一个整数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">int</span> &amp;i) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 保护代码</span></span><br><span class="line">&#125; <span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line">    <span class="comment">// 能处理任何异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="16-类型转换"><a class="markdownIt-Anchor" href="#16-类型转换"></a> 1.6 类型转换</h2>
<h3 id="161-static_cast"><a class="markdownIt-Anchor" href="#161-static_cast"></a> 1.6.1 static_cast</h3>
<p><strong>用法：<code>static_cast&lt;type&gt; (expr)</code></strong></p>
<p><code>static_cast</code>运算符执行非动态转换，没有运行时类检查来保证转换的安全性。例如，它可以用来把一个基类指针转换为派生类指针。任何具有明确意义的类型转换，只要不包含底层<code>const</code>，都可以使用<code>static_cast</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cc = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> s = <span class="keyword">static_cast</span>&lt;std::string&gt;(cc);</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compile error</span></span><br><span class="line">    <span class="comment">// auto i = static_cast&lt;int&gt;(cc);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="162-dynamic_cast"><a class="markdownIt-Anchor" href="#162-dynamic_cast"></a> 1.6.2 dynamic_cast</h3>
<p><strong>用法：<code>dynamic_cast&lt;type&gt; (expr)</code></strong></p>
<p><code>dynamic_cast</code>通常用于在继承结构之间进行转换，在运行时执行转换，验证转换的有效性。<code>type</code>必须是类的指针、类的引用或者<code>void*</code>。若指针转换失败，则得到的是<code>nullptr</code>；若引用转换失败，那么会抛出<code>std::bad_cast</code>类型的异常</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base&#x27;s func&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive&#x27;s func&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Base &amp;b = Derive&#123;&#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;d = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Derive &amp;&gt;(b);</span><br><span class="line">        d.<span class="built_in">func</span>();</span><br><span class="line">        <span class="keyword">auto</span> &amp;s = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> std::string &amp;&gt;(b); <span class="comment">// error case</span></span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (std::bad_cast &amp;err) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;err=&quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Base *pb = &amp;b;</span><br><span class="line">    <span class="keyword">auto</span> *pd = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Derive *&gt;(pb);</span><br><span class="line">    pd-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">auto</span> *ps = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> std::string *&gt;(pb); <span class="comment">// error case</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ps=&quot;</span> &lt;&lt; ps &lt;&lt; std::endl; <span class="comment">// print nullptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="163-const_cast"><a class="markdownIt-Anchor" href="#163-const_cast"></a> 1.6.3 const_cast</h3>
<p><strong>用法：<code>const_cast&lt;type&gt; (expr)</code></strong></p>
<p>这种类型的转换主要是用来操作所传对象的<code>const</code>属性，可以加上<code>const</code>属性，也可以去掉<code>const</code>属性（顶层底层均可）。其中，<code>type</code>只能是如下几类（必须是引用或者指针类型）</p>
<ul>
<li><code>T &amp;</code></li>
<li><code>const T &amp;</code></li>
<li><code>T &amp;&amp;</code></li>
<li><code>T *</code></li>
<li><code>const T *</code></li>
<li><code>T *const</code></li>
<li><code>const T *const</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;const T &amp; -&gt; T &amp;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;v1 = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v1&#x27;s address=&quot;</span> &lt;&lt; &amp;v1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span> &amp;v2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> &amp;&gt;(v1);</span><br><span class="line">    v2 = <span class="number">200</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v2&#x27;s address=&quot;</span> &lt;&lt; &amp;v2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nT &amp; -&gt; T &amp;&amp;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;v3 = <span class="keyword">const_cast</span>&lt; <span class="keyword">int</span> &amp;&amp;&gt;(v2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v3&#x27;s address=&quot;</span> &lt;&lt; &amp;v3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nT * -&gt; const T *const&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;v2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1=&quot;</span> &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p2 = <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> &gt;(p1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2=&quot;</span> &lt;&lt; p2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="164-reinterpret_cast"><a class="markdownIt-Anchor" href="#164-reinterpret_cast"></a> 1.6.4 reinterpret_cast</h3>
<p><strong>用法：<code>reinterpret_cast&lt;type&gt; (expr)</code></strong></p>
<p><code>reinterpret_cast</code>是最危险的类型转换，它能够直接将一种类型的指针转换为另一种类型的指针，应该非常谨慎地使用。在很大程度上，使用<code>reinterpret_cast</code>获得的唯一保证是，通常如果你将结果转换回原始类型，您将获得完全相同的值（但如果中间类型小于原始类型，则不会）。也有许多<code>reinterpret_cast</code>不能做的转换。它主要用于特别奇怪的转换和位操作，例如将原始数据流转换为实际数据，或将数据存储在指向对齐数据的指针的低位中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> i = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> *pi = &amp;i;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> *pl = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int64_t</span> *&gt; (pi);</span><br><span class="line">        std::cout &lt;&lt; *pl &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">auto</span> *rebuild_pi = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int32_t</span> *&gt; (pl);</span><br><span class="line">        std::cout &lt;&lt; *rebuild_pi &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-如何在类中定义常量"><a class="markdownIt-Anchor" href="#17-如何在类中定义常量"></a> 1.7 如何在类中定义常量</h2>
<h2 id="18-初始化"><a class="markdownIt-Anchor" href="#18-初始化"></a> 1.8 初始化</h2>
<h3 id="181-初始化列表"><a class="markdownIt-Anchor" href="#181-初始化列表"></a> 1.8.1 初始化列表</h3>
<ol>
<li>对于内置类型，直接进行值拷贝。使用初始化列表还是在构造函数体中进行初始化没有差别</li>
<li>对于类类型
<ul>
<li>在初始化列表中初始化：调用的是拷贝构造函数或者移动构造函数</li>
<li>在构造函数体中初始化：虽然在初始化列表中没有显式指定，但是仍然会用默认的构造函数来进行初始化，然后在构造函数体中使用拷贝或者移动赋值运算符</li>
</ul>
</li>
<li>哪些东西必须放在初始化列表中
<ul>
<li>常量成员</li>
<li>引用类型</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝或者移动构造函数初始化</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s default constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a) : _a(a), _b(<span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s (int) constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : _a(a), _b(b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s (int, int) constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A &amp;a) : _a(a._a), _b(a._b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(A &amp;&amp;a) : _a(a._a), _b(a._b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s move constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;a) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s copy assign operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = a._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(A &amp;&amp;a) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s move assign operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = a._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(A &amp;a) : _a(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(A &amp;a, std::<span class="keyword">nullptr_t</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(A &amp;&amp;a) : _a(std::<span class="built_in">move</span>(a)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(A &amp;&amp;a, std::<span class="keyword">nullptr_t</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = std::<span class="built_in">move</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;============(create a)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(create b1)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(a)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(create b2)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(a, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(create b3)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">B <span class="title">b3</span><span class="params">(<span class="keyword">static_cast</span>&lt;A &amp;&amp;&gt;(a))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(create b4)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">B <span class="title">b4</span><span class="params">(<span class="keyword">static_cast</span>&lt;A &amp;&amp;&gt;(a), <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">============(create a)============</span><br><span class="line">A&#x27;s (int, int) constructor</span><br><span class="line"></span><br><span class="line">============(create b1)============</span><br><span class="line">A&#x27;s copy constructor</span><br><span class="line"></span><br><span class="line">============(create b2)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line">A&#x27;s copy assign operator</span><br><span class="line"></span><br><span class="line">============(create b3)============</span><br><span class="line">A&#x27;s move constructor</span><br><span class="line"></span><br><span class="line">============(create b4)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line">A&#x27;s move assign operator</span><br></pre></td></tr></table></figure>
<h3 id="182-各种初始化类型"><a class="markdownIt-Anchor" href="#182-各种初始化类型"></a> 1.8.2 各种初始化类型</h3>
<ol>
<li>默认初始化：<code>type variableName;</code></li>
<li>直接初始化/构造初始化（至少有1个参数）：<code>type variableName(args);</code></li>
<li>列表初始化：<code>type variableName&#123;args&#125;;</code>
<ul>
<li>本质上列表初始化会调用相应的构造函数（匹配参数类型以及参数数量）来进行初始化</li>
<li>它的好处之一是可以简化<code>return</code>语句，可以直接<code>return &#123;args&#125;;</code></li>
</ul>
</li>
<li>拷贝初始化：
<ul>
<li><code>type variableName = otherVariableName</code>，本质上调用了拷贝构造函数</li>
<li><code>type variableName = &lt;type (args)&gt;</code>，其中<code>&lt;type (args)&gt;</code>指的是返回类型为<code>type</code>的函数。看起来会调用拷贝构造函数，但是编译器会对这种形式的初始化进行优化，也就是只有函数内部调用了构造函数（如果有的话），而<code>=</code>并未调用任何构造函数</li>
</ul>
</li>
<li>值初始化：<code>type variableName()</code>
<ul>
<li>对于内置类型，初始化为<code>0</code>或者<code>nullptr</code></li>
<li>对于类类型，等同于默认初始化。测试发现并未调用任何构造函数</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s default constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a) : _a(a), _b(<span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s (int) constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : _a(a), _b(b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s (int, int) constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A &amp;a) : _a(a._a), _b(a._b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(A &amp;&amp;a) : _a(a._a), _b(a._b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s move constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;a) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s copy assign operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = a._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(A &amp;&amp;a) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s move assign operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = a._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">createA</span><span class="params">(<span class="keyword">int</span> argNum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argNum == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argNum == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;============(默认初始化 a1)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(直接初始化 a2)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(直接初始化 a3)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">A <span class="title">a3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(列表初始化 a4)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a4 = &#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(列表初始化 a5)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a5 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(列表初始化 a6)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a6 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(拷贝初始化 a7)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a7 = a6;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(拷贝初始化 a8)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a8 = <span class="built_in">createA</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(拷贝初始化 a9)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a9 = <span class="built_in">createA</span>(<span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(拷贝初始化 a10)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a10 = <span class="built_in">createA</span>(<span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(值初始化 a11)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">A <span class="title">a11</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">============(默认初始化 a1)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line"></span><br><span class="line">============(直接初始化 a2)============</span><br><span class="line">A&#x27;s (int) constructor</span><br><span class="line"></span><br><span class="line">============(直接初始化 a3)============</span><br><span class="line">A&#x27;s (int, int) constructor</span><br><span class="line"></span><br><span class="line">============(列表初始化 a4)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line"></span><br><span class="line">============(列表初始化 a5)============</span><br><span class="line">A&#x27;s (int) constructor</span><br><span class="line"></span><br><span class="line">============(列表初始化 a6)============</span><br><span class="line">A&#x27;s (int, int) constructor</span><br><span class="line"></span><br><span class="line">============(拷贝初始化 a7)============</span><br><span class="line">A&#x27;s copy constructor</span><br><span class="line"></span><br><span class="line">============(拷贝初始化 a8)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line"></span><br><span class="line">============(拷贝初始化 a9)============</span><br><span class="line">A&#x27;s (int) constructor</span><br><span class="line"></span><br><span class="line">============(拷贝初始化 a10)============</span><br><span class="line">A&#x27;s (int, int) constructor</span><br><span class="line"></span><br><span class="line">============(值初始化 a11)============</span><br></pre></td></tr></table></figure>
<h2 id="19-const"><a class="markdownIt-Anchor" href="#19-const"></a> 1.9 const</h2>
<p>默认状态下，<code>const</code>对象仅在文件内有效。编译器将在编译过程中把用到该变量的地方都替代成对应的值，也就是说，编译器会找到代码中所有用到该<code>const</code>变量的地方，然后将其替换成定义的值</p>
<p>为了执行上述替换，编译器必须知道变量的初始值，如果程序包含多个文件，则每个用了<code>const</code>对象的文件都必须能访问到它的初始值才行。要做到这一点，就必须在每一个用到该变量的文件中都对它有定义（将定义该<code>const</code>变量的语句放在头文件中，然后用到该变量的源文件包含头文件即可），为了支持这一用法，同时避免对同一变量的重复定义，默认情况下<code>const</code>被设定为尽在文件内有效（<code>const</code>的全局变量，其实只是在每个文件中都定义了一边而已）</p>
<p>有时候出现这样的情况：<code>const</code>变量的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件生成独立的变量，相反，我们想让这类<code>const</code>对象像其他对象一样工作。<strong>即：在一个文件中定义<code>const</code>，在多个文件中声明并使用它，无论声明还是定 义都添加<code>extern</code>关键字</strong></p>
<ul>
<li><code>.h</code>文件中：<code>extern const int a;</code></li>
<li><code>.cpp</code>文件中：<code>extern const int a=f();</code></li>
</ul>
<h3 id="191-顶层底层const"><a class="markdownIt-Anchor" href="#191-顶层底层const"></a> 1.9.1 顶层/底层const</h3>
<p>顶层的<code>const</code>可以表示任意的对象是常量（包括指针，不包括引用，因为引用本身不是对象，没法指定顶层的<code>const</code>属性）</p>
<p>只有指针的<code>const</code>属性既可以是顶层又可以是底层，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> pi = &amp;i;</span><br></pre></td></tr></table></figure>
<h3 id="192-const实参和形参"><a class="markdownIt-Anchor" href="#192-const实参和形参"></a> 1.9.2 const实参和形参</h3>
<p>实参初始化形参时会自动忽略掉顶层<code>const</code>属性</p>
<p>顶层<code>const</code>不影响形参的类型，例如下面的代码，编译会失败，错误信息是函数重定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> value)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="193-const成员"><a class="markdownIt-Anchor" href="#193-const成员"></a> 1.9.3 const成员</h3>
<p>构造函数中显式初始化：在初始化部分进行初始化，而不能在函数体内初始化；如果没有显式初始化，就调用定义时的初始值进行初始化</p>
<h3 id="194-const成员函数"><a class="markdownIt-Anchor" href="#194-const成员函数"></a> 1.9.4 const成员函数</h3>
<p><code>const</code>关键词修饰的成员函数，不能修改当前类的任何字段的值，如果字段是对象类型，也不能调用非const修饰的成员方法</p>
<p>常量对象以及常量对象的引用或指针都只能调用常量成员函数</p>
<p>常量对象以及常量对象的引用或指针都可以调用常量成员函数以及非常量成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello world, const version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello world, non const version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Demo d;</span><br><span class="line">    d.<span class="built_in">sayHello1</span>();</span><br><span class="line">    d.<span class="built_in">sayHello2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Demo cd;</span><br><span class="line">    cd.<span class="built_in">sayHello1</span>();</span><br><span class="line">    <span class="comment">// the following statement will lead to compile error</span></span><br><span class="line">    <span class="comment">// cd.sayHello2();</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="110-placement-new"><a class="markdownIt-Anchor" href="#110-placement-new"></a> 1.10 placement new</h2>
<p><code>placement new</code>的功能就是在一个已经分配好的空间上，调用构造函数，创建一个对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *buf = <span class="comment">// 在这里为buf分配内存</span></span><br><span class="line">Class *pc = <span class="built_in"><span class="keyword">new</span></span> (buf) <span class="built_in">Class</span>();  </span><br></pre></td></tr></table></figure>
<h2 id="111-模板"><a class="markdownIt-Anchor" href="#111-模板"></a> 1.11 模板</h2>
<p>模板形参可以是一个类型或者枚举</p>
<p><strong>模板形参是枚举的示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BasicType</span> &#123;</span></span><br><span class="line">    INT,</span><br><span class="line">    DOUBLE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;BasicType BT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RuntimeTypeTraits</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RuntimeTypeTraits</span>&lt;</span>INT&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RuntimeTypeTraits</span>&lt;</span>DOUBLE&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">double</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译期类型推断，value的类型是int</span></span><br><span class="line">    RuntimeTypeTraits&lt;INT&gt;::Type value = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="112-宏"><a class="markdownIt-Anchor" href="#112-宏"></a> 1.12 宏</h2>
<h3 id="1121-do-while0-in-macros"><a class="markdownIt-Anchor" href="#1121-do-while0-in-macros"></a> 1.12.1 do while(0) in macros</h3>
<p>考虑下面的宏定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foo(x) bar(x); baz(x)</span></span><br></pre></td></tr></table></figure>
<p>然后我们调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foo</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>会被展开为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bar</span>(wolf); <span class="built_in">baz</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>看起来没有问题，我们接着考虑另一个情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) </span><br><span class="line">    <span class="built_in">foo</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>会被展开为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) </span><br><span class="line">    <span class="built_in">bar</span>(wolf);</span><br><span class="line"><span class="built_in">baz</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>这并不符合我们的预期，为了避免出现这种问题，需要用一个作用域将宏包围起来，避免语句的作用域发生偏移，于是我们进一步将宏表示为如下形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foo(x) &#123; bar(x); baz(x); &#125;</span></span><br></pre></td></tr></table></figure>
<p>然后我们调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    <span class="built_in">foo</span>(wolf);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">bin</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>会被展开为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">bar</span>(wolf);</span><br><span class="line">    <span class="built_in">baz</span>(wolf);</span><br><span class="line">&#125;; <span class="comment">// syntax error</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">bin</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>最终，我们将宏优化成如下形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foo(x) do &#123; bar(x); baz(x); &#125; while (0)</span></span><br></pre></td></tr></table></figure>
<h2 id="113-mock-class"><a class="markdownIt-Anchor" href="#113-mock-class"></a> 1.13 mock class</h2>
<p>有时在测试的时候，我们需要mock一个类的实现，我们可以在测试的cpp文件中实现这个类的所有方法（<strong>注意，必须是所有方法</strong>），就能够覆盖原有库文件中的实现。下面以一个例子来说明</p>
<p><strong>目录结构如下</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── lib</span><br><span class="line">│   ├── libperson.a</span><br><span class="line">│   ├── person.cpp</span><br><span class="line">│   ├── person.h</span><br><span class="line">│   └── person.o</span><br><span class="line">└── main.cpp</span><br></pre></td></tr></table></figure>
<p><strong><code>lib/person.h</code>内容如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><code>lib/person.cpp</code>内容如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;work&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sleep&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;eat&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译<code>person.cpp</code>生成链接文件，并生成<code>.a</code>归档文件</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定-c参数，只生成目标文件（person.o），不进行链接</span></span><br><span class="line">g++ person.cpp -c -std=gnu++11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成归档文件</span></span><br><span class="line">ar crv libperson.a person.o</span><br></pre></td></tr></table></figure>
<p><strong><code>main.cpp</code>内容如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lib/person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.<span class="built_in">work</span>();</span><br><span class="line">    person.<span class="built_in">sleep</span>();</span><br><span class="line">    person.<span class="built_in">eat</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>编译<code>main.cpp</code>并执行</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="comment"># -L参数将lib目录加入到库文件的扫描路径</span></span><br><span class="line"><span class="comment"># -l参数指定需要链接的库文件</span></span><br><span class="line">g++ -o main main.cpp -std=gnu++11 -L lib -lperson</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行，输出如下</span></span><br><span class="line">./main</span><br><span class="line"></span><br><span class="line">work</span><br><span class="line">sleep</span><br><span class="line">eat</span><br></pre></td></tr></table></figure>
<p><strong>接下来，我们修改<code>main.cpp</code>，覆盖原有的<code>work</code>、<code>sleep</code>、<code>eat</code>方法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lib/person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock work&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock sleep&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock eat&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.<span class="built_in">work</span>();</span><br><span class="line">    person.<span class="built_in">sleep</span>();</span><br><span class="line">    person.<span class="built_in">eat</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>编译<code>main.cpp</code>并执行</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="comment"># -L参数将lib目录加入到库文件的扫描路径</span></span><br><span class="line"><span class="comment"># -l参数指定需要链接的库文件</span></span><br><span class="line">g++ -o main main.cpp -std=gnu++11 -L lib -lperson</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行，输出如下，可以发现，都变成了mock版本</span></span><br><span class="line">./main</span><br><span class="line"></span><br><span class="line">mock work</span><br><span class="line">mock sleep</span><br><span class="line">mock eat</span><br></pre></td></tr></table></figure>
<p><strong>然后，我们继续修改<code>main.cpp</code>，删去其中一个方法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;lib/person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock work&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock sleep&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void Person::eat() &#123;</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; &quot;mock eat&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.<span class="built_in">work</span>();</span><br><span class="line">    person.<span class="built_in">sleep</span>();</span><br><span class="line">    person.<span class="built_in">eat</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>编译<code>main.cpp</code>（编译会失败）</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="comment"># -L参数将lib目录加入到库文件的扫描路径</span></span><br><span class="line"><span class="comment"># -l参数指定需要链接的库文件</span></span><br><span class="line">g++ -o main main.cpp -std=gnu++11 -L lib -lperson</span><br><span class="line"></span><br><span class="line">lib/libperson.a(person.o)：在函数‘Person::work()’中：</span><br><span class="line">person.cpp:(.text+0x0): Person::work() 的多重定义</span><br><span class="line">/tmp/ccfhnlz4.o:main.cpp:(.text+0x0)：第一次在此定义</span><br><span class="line">lib/libperson.a(person.o)：在函数‘Person::sleep()’中：</span><br><span class="line">person.cpp:(.text+0x2a): Person::sleep() 的多重定义</span><br><span class="line">/tmp/ccfhnlz4.o:main.cpp:(.text+0x2a)：第一次在此定义</span><br><span class="line">collect2: 错误：ld 返回 1</span><br></pre></td></tr></table></figure>
<h3 id="1131-demo-using-cmake"><a class="markdownIt-Anchor" href="#1131-demo-using-cmake"></a> 1.13.1 demo using cmake</h3>
<h2 id="114-参考"><a class="markdownIt-Anchor" href="#114-参考"></a> 1.14 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8c4952e9edec">C++11\14\17\20 特性介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://www.codenong.com/1563897/">关于C++：静态常量字符串(类成员)</a></li>
<li><a target="_blank" rel="noopener" href="https://hownot2code.com/2016/12/05/do-while-0-in-macros/">do {…} while (0) in macros</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/c/PRE10-C.+Wrap+multistatement+macros+in+a+do-while+loop">PRE10-C. Wrap multistatement macros in a do-while loop</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-const-keyword.html">C++ const 关键字小结</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-casting-operators.html">C++ 强制转换运算符</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used">When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?</a></li>
</ul>
<h1 id="2-标准库"><a class="markdownIt-Anchor" href="#2-标准库"></a> 2 标准库</h1>
<h2 id="21-utility"><a class="markdownIt-Anchor" href="#21-utility"></a> 2.1 utility</h2>
<h3 id="211-stdmove"><a class="markdownIt-Anchor" href="#211-stdmove"></a> 2.1.1 std::move</h3>
<p>标准库的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>本质上，就是做了一次类型转换，返回的一定是个右值。其中，<code>remove_reference</code>是个<code>traits</code>，用于萃取出原始类型（不带任何引用）</p>
<h3 id="212-stdforward"><a class="markdownIt-Anchor" href="#212-stdforward"></a> 2.1.2 std::forward</h3>
<p><code>std::forward</code>主要用于实现模板的完美转发：因为对于一个变量而言，无论该变量的类型是左值引用还是右值引用，变量本身都是左值，如果直接将变量传递到下一个方法中，那么一定是按照左值来匹配重载函数的，而<code>std::forward</code>就是为了解决这个问题。请看下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;left reference version, value=&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;&amp;value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;right reference version, value=&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_without_forward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_with_forward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dispatch_without_forward</span>(value); <span class="comment">// left reference version, value=0</span></span><br><span class="line">    <span class="built_in">dispatch_without_forward</span>(<span class="number">1</span>); <span class="comment">// left reference version, value=1</span></span><br><span class="line"></span><br><span class="line">    value = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">dispatch_with_forward</span>(value); <span class="comment">// left reference version, value=2</span></span><br><span class="line">    <span class="built_in">dispatch_with_forward</span>(<span class="number">3</span>); <span class="comment">// right reference version, value=3</span></span><br><span class="line"></span><br><span class="line">    value = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;<span class="keyword">int</span>&gt;(value)); <span class="comment">// right reference version, value=4 (!!! very strange !!!)</span></span><br><span class="line">    value = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;<span class="keyword">int</span> &amp;&gt;(value)); <span class="comment">// left reference version, value=5</span></span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;<span class="keyword">int</span> &amp;&amp;&gt;(<span class="number">6</span>)); <span class="comment">// right reference version, value=6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准库的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">                  <span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>在使用<code>std::forward</code>时，模板实参都是需要显式指定的，而不是推断出来的</strong></p>
<ul>
<li>如果模板实参是左值、左值引用或右值引用，那么匹配第一个方法
<ul>
<li>左值：<code>_Tp&amp;&amp;</code>得到的是个右值（很奇怪吧，因为一般都不是这么用的）</li>
<li><strong>左值引用：<code>_Tp&amp;&amp;</code>得到的是个左值引用（完美转发会用到）</strong></li>
<li><strong>右值应用：<code>_Tp&amp;&amp;</code>得到的是个右值引用（完美转发会用到）</strong></li>
</ul>
</li>
<li>如果模板实参是左值或右值，那么匹配的是第二个方法
<ul>
<li>右值：<code>_Tp&amp;&amp;</code>得到的是个右值</li>
</ul>
</li>
</ul>
<h2 id="22-stdpromisestdfuture"><a class="markdownIt-Anchor" href="#22-stdpromisestdfuture"></a> 2.2 std::promise/std::future</h2>
<h2 id="23-stdstring"><a class="markdownIt-Anchor" href="#23-stdstring"></a> 2.3 std::string</h2>
<p>字符串比较函数：<code>strcmp</code></p>
<h2 id="24-stdthread"><a class="markdownIt-Anchor" href="#24-stdthread"></a> 2.4 std::thread</h2>
<h2 id="25-stdchrono"><a class="markdownIt-Anchor" href="#25-stdchrono"></a> 2.5 std::chrono</h2>
<h2 id="26-stdshared_ptr"><a class="markdownIt-Anchor" href="#26-stdshared_ptr"></a> 2.6 std::shared_ptr</h2>
<p><strong>只在函数使用指针，但并不保存对象内容</strong></p>
<p>假如我们只需要在函数中，用这个对象处理一些事情，但不打算涉及其生命周期的管理，也不打算通过函数传参延长<code>shared_ptr</code>的生命周期。对于这种情况，可以使用<code>raw pointer</code>或者<code>const shared_ptr&amp;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Widget*)</span></span>;</span><br><span class="line"><span class="comment">// 不发生拷贝，引用计数未增加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> shared_ptr&lt;Widget&gt;&amp;)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>在函数中保存智能指针</strong></p>
<p>假如我们需要在函数中把这个智能指针保存起来，这个时候建议直接传值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传参时发生拷贝，引用计数增加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(std::shared_ptr&lt;Widget&gt; ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样的话，外部传过来值的时候，可以选择<code>move</code>或者赋值。函数内部直接把这个对象通过<code>move</code>的方式保存起来</p>
<h2 id="27-stdfunction"><a class="markdownIt-Anchor" href="#27-stdfunction"></a> 2.7 std::function</h2>
<p>其功能类似于函数指针，在需要函数指针的地方，可以传入<code>std::function</code>类型的对象（不是指针）</p>
<h2 id="28-stdbind"><a class="markdownIt-Anchor" href="#28-stdbind"></a> 2.8 std::bind</h2>
<h2 id="29-stdlock_guard"><a class="markdownIt-Anchor" href="#29-stdlock_guard"></a> 2.9 std::lock_guard</h2>
<p>一般的使用方法，如果getVar方法抛出异常了，那么就会导致<code>m.unlock()</code>方法无法执行，可能会造成死锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mutex m;</span><br><span class="line">m.<span class="built_in">lock</span>();</span><br><span class="line">sharedVariable= <span class="built_in">getVar</span>();</span><br><span class="line">m.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>
<p>一种优雅的方式是使用<code>std::lock_guard</code>，该对象的析构方法中会进行锁的释放，需要将串行部分放到一个<code>&#123;&#125;</code>中，当退出该作用域时，<code>std::lock_guard</code>对象会析构，并释放锁，在任何正常或异常情况下都能够释放锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  std::mutex m,</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockGuard</span><span class="params">(m)</span></span>;</span><br><span class="line">  sharedVariable= <span class="built_in">getVar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="210-stdcondition_variable"><a class="markdownIt-Anchor" href="#210-stdcondition_variable"></a> 2.10 std::condition_variable</h2>
<p>调用<code>wait</code>方法时，必须获取监视器。而调用<code>notify</code>方法时，无需获取监视器</p>
<h2 id="211-stdatomic"><a class="markdownIt-Anchor" href="#211-stdatomic"></a> 2.11 std::atomic</h2>
<p><code>compare_exchange_strong(T&amp; expected_value, T new_value)</code>方法的第一个参数是个左值</p>
<ul>
<li>当前值与期望值<code>expected_value</code>相等时，修改当前值为设定值<code>new_value</code>，返回true</li>
<li>当前值与期望值<code>expected_value</code>不等时，将期望值修改为当前值，返回false（搞不懂为什么要这样设计，啥脑回路）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="keyword">atomic_bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> expected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="literal">true</span>)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, flag: &quot;</span> &lt;&lt; flag &lt;&lt; <span class="string">&quot;, expected: &quot;</span> &lt;&lt; expected &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="literal">true</span>)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, flag: &quot;</span> &lt;&lt; flag &lt;&lt; <span class="string">&quot;, expected: &quot;</span> &lt;&lt; expected &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result: 1, flag: 1, expected: 0</span><br><span class="line">result: 0, flag: 1, expected: 1</span><br></pre></td></tr></table></figure>
<h2 id="212-stdmem_fn"><a class="markdownIt-Anchor" href="#212-stdmem_fn"></a> 2.12 std::mem_fn</h2>
<h2 id="213-stdany_cast"><a class="markdownIt-Anchor" href="#213-stdany_cast"></a> 2.13 std::any_cast</h2>
<h2 id="214-stdconditional_t"><a class="markdownIt-Anchor" href="#214-stdconditional_t"></a> 2.14 std::conditional_t</h2>
<h2 id="215-参考"><a class="markdownIt-Anchor" href="#215-参考"></a> 2.15 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f191e88dcc80">C++11 中的std::function和std::bind</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17101922/do-i-have-to-acquire-lock-before-calling-condition-variable-notify-one">Do I have to acquire lock before calling condition_variable.notify_one()?</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cyhone.com/articles/right-way-to-use-cpp-smart-pointer/">C++ 智能指针的正确使用方式</a></li>
</ul>
<h1 id="3-编程范式"><a class="markdownIt-Anchor" href="#3-编程范式"></a> 3 编程范式</h1>
<h2 id="31-形参类型是否需要左右值引用"><a class="markdownIt-Anchor" href="#31-形参类型是否需要左右值引用"></a> 3.1 形参类型是否需要左右值引用</h2>
<h2 id="32-返回类型是否需要左右值引用"><a class="markdownIt-Anchor" href="#32-返回类型是否需要左右值引用"></a> 3.2 返回类型是否需要左右值引用</h2>
<h2 id="33-traits编译期萃取类型信息"><a class="markdownIt-Anchor" href="#33-traits编译期萃取类型信息"></a> 3.3 traits编译期萃取类型信息</h2>
<h3 id="331-示例1"><a class="markdownIt-Anchor" href="#331-示例1"></a> 3.3.1 示例1</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> isVoid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> isVoid&lt;<span class="keyword">void</span>&gt; = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;isVoid&lt;void&gt;=&quot;</span> &lt;&lt; isVoid&lt;<span class="keyword">void</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;isVoid&lt;int&gt;=&quot;</span> &lt;&lt; isVoid&lt;<span class="keyword">int</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="332-示例2"><a class="markdownIt-Anchor" href="#332-示例2"></a> 3.3.2 示例2</h3>
<p>用<code>std::conditional_t</code></p>
<h1 id="4-gdb"><a class="markdownIt-Anchor" href="#4-gdb"></a> 4 GDB</h1>
<h2 id="41-gdb能够做什么"><a class="markdownIt-Anchor" href="#41-gdb能够做什么"></a> 4.1 GDB能够做什么？</h2>
<ol>
<li>一个支持包括<code>c</code>以及<code>c++</code>等众多语言的<code>debugger</code>工具</li>
<li>它允许您检查程序在执行期间的某个时刻正在做什么</li>
<li>能够定位诸如<code>segmentation faults</code>等错误的具体原因</li>
<li></li>
</ol>
<p>对<code>c/c++</code>程序的调试，需要在编译前就加上<code>-g</code>选项：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g hello.c -o hello</span><br><span class="line">g++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure>
<h2 id="42-如何进入gdb-shell"><a class="markdownIt-Anchor" href="#42-如何进入gdb-shell"></a> 4.2 如何进入GDB shell</h2>
<p><code>gdb</code>提供了一个交互式的<code>shell</code>，能够通过<code>↑</code>查询历史命令，可以通过<code>tab</code>进行命令行补全，可以通过<code>help [command]</code>查询帮助文档</p>
<p><strong>进入gdb交互界面的几种方式：</strong></p>
<ul>
<li><code>gdb &lt;binary_with_-g&gt;</code>：调试可执行文件</li>
<li><code>gdb &lt;binary_with_-g&gt; core.xxx</code>：分析coredump</li>
<li><code>gdb &lt;binary_with_-g&gt; &lt;pid_without_-g&gt;</code>：以可执行文件为元数据，调试指定进程
<ul>
<li><code>&lt;binary&gt;</code>需要用<code>-g</code>参数编译出来，否则指定该文件没有意义</li>
<li><code>&lt;pid&gt;</code>对应的进程可以是不带<code>-g</code>参数编译出来的版本，只要保证源码一样即可</li>
</ul>
</li>
<li><code>gdb -p &lt;pid_with_-g&gt;</code>：调试指定进程
<ul>
<li>若<code>&lt;pid&gt;</code>对应的进程如果是用<code>-g</code>参数编译出来，那么等效于<code>gdb &lt;binary_with_-g&gt;</code> + <code>run</code></li>
</ul>
</li>
</ul>
<p><strong>下面演示一下使用<code>gdb &lt;binary_with_-g&gt; &lt;pid_without_-g&gt;</code>这种方式进入gdb shell</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码</span></span><br><span class="line">cat &gt; main.cpp &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;thread&gt;</span></span><br><span class="line"><span class="comment">#include&lt;chrono&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello, world!&quot;</span> &lt;&lt;<span class="string">std::endl;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int cnt = 0;</span></span><br><span class="line"><span class="string">    while(true) &#123;</span></span><br><span class="line"><span class="string">        ++cnt;</span></span><br><span class="line"><span class="string">        std</span>::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;cnt=&quot;</span> &lt;&lt; <span class="string">cnt &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 编译两个版本，一个带-g参数，一个不带</span></span><br><span class="line"><span class="string">g++ -o main_without_debug main.cpp -std=gnu++11</span></span><br><span class="line"><span class="string">g++ -o main_with_debug main.cpp -std=gnu++11 -g</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行非debug版本</span></span><br><span class="line">./main_without_debug</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询进程id</span></span><br><span class="line">pid=$(ps -ef | grep main_without_debug | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入gdb shell</span></span><br><span class="line">gdb main_with_debug <span class="variable">$&#123;pid&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="43-command"><a class="markdownIt-Anchor" href="#43-command"></a> 4.3 command</h2>
<h3 id="431-运行程序"><a class="markdownIt-Anchor" href="#431-运行程序"></a> 4.3.1 运行程序</h3>
<p>当我们通过<code>gdb &lt;binary&gt;</code>这种方式进入<code>gdb shell</code>后，程序不会立即执行，需要通过<code>run</code>或者<code>start</code>命令触发程序的执行</p>
<ul>
<li><code>run</code>：开始执行程序，直到碰到第一个断点或者程序结束</li>
<li><code>start</code>：开始执行程序，在main函数第一行停下来</li>
</ul>
<p>如果程序有异常（比如包含段错误），那么我们将会得到一些有用的信息，包括：程序出错的行号，函数的参数等等信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># c++源文件</span></span><br><span class="line">$ cat &gt; segment_fault.cpp &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    int *num = nullptr;</span><br><span class="line">    *num = 100;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译（可以试下不加-g参数）</span></span><br><span class="line">$ g++ -o segment_fault segment_fault.cpp -std=gnu++11 -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入gdb shell</span></span><br><span class="line">$ gdb segment_fault</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行程序，程序会出现段错误而退出，并输出相关的错误信息</span></span><br><span class="line"><span class="comment"># 如果编译时没有加-g参数，输出的信息就会少很多（比如行号和具体的代码就没有了）</span></span><br><span class="line">(gdb) run</span><br><span class="line"></span><br><span class="line">Starting program: xxx/segment_fault</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x000000000040051d <span class="keyword">in</span> main () at segment_fault.cpp:3</span><br><span class="line">3	    *num = 100;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="432-gdb与程序关联"><a class="markdownIt-Anchor" href="#432-gdb与程序关联"></a> 4.3.2 GDB与程序关联</h3>
<h3 id="433-断点设置"><a class="markdownIt-Anchor" href="#433-断点设置"></a> 4.3.3 断点设置</h3>
<ul>
<li><code>break</code>：用于设置断点
<ul>
<li><code>break &lt;line_num&gt;</code></li>
<li><code>break &lt;func_name&gt;</code></li>
<li><code>break &lt;file_name&gt;:&lt;line_num&gt;</code></li>
<li><code>break &lt;file_name&gt;:&lt;func_name&gt;</code></li>
</ul>
</li>
<li><code>info break</code>：用于查看断点</li>
<li><code>delete</code>：用于删除断点
<ul>
<li><code>delete &lt;break_id&gt;</code>：删除指定断点</li>
<li><code>delete</code>：删除所有断点</li>
</ul>
</li>
<li><code>enable</code>：用于启用断点
<ul>
<li><code>enable &lt;break_id&gt;</code></li>
</ul>
</li>
<li><code>disable</code>：用于停用断点
<ul>
<li><code>disable &lt;break_id&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="4331-demo"><a class="markdownIt-Anchor" href="#4331-demo"></a> 4.3.3.1 demo</h4>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># c++源文件</span></span><br><span class="line">$ cat &gt; set_break.cpp &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">funcA</span></span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;invoke funcA()&quot;</span> &lt;&lt; <span class="string">std::endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main() &#123;</span></span><br><span class="line"><span class="string">    std</span>::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; <span class="string">std::endl;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int num = 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int *num_ptr = &amp;num;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    funcA();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for(int i=0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="string">        ++(*num_ptr);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    std</span>::cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; *num_ptr &lt;&lt; <span class="string">std::endl;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 编译（可以试下不加-g参数）</span></span><br><span class="line"><span class="string">$ g++ -o set_break set_break.cpp -std</span>=gnu++11 -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入gdb shell</span></span><br><span class="line">$ gdb set_break</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过list查看源码</span></span><br><span class="line">$ (gdb) list 0</span><br><span class="line">1	<span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">2</span><br><span class="line">3	void <span class="function"><span class="title">funcA</span></span>() &#123;</span><br><span class="line">4	    std::cout &lt;&lt; <span class="string">&quot;invoke funcA()&quot;</span> &lt;&lt; <span class="string">std::endl;</span></span><br><span class="line"><span class="string">5	&#125;</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">7	int main() &#123;</span></span><br><span class="line"><span class="string">8	    std</span>::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; <span class="string">std::endl;</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">10	    int num = 0;</span></span><br><span class="line"><span class="string"># 回车，继续输出下10行</span></span><br><span class="line"><span class="string">$ (gdb)</span></span><br><span class="line"><span class="string">11</span></span><br><span class="line"><span class="string">12	    int *num_ptr = &amp;num;</span></span><br><span class="line"><span class="string">13</span></span><br><span class="line"><span class="string">14	    funcA();</span></span><br><span class="line"><span class="string">15</span></span><br><span class="line"><span class="string">16	    for(int i=0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="string">17	        ++(*num_ptr);</span></span><br><span class="line"><span class="string">18	    &#125;</span></span><br><span class="line"><span class="string">19</span></span><br><span class="line"><span class="string">20	    std</span>::cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; *num_ptr &lt;&lt; <span class="string">std::endl;</span></span><br><span class="line"><span class="string"># 回车，继续输出下10行</span></span><br><span class="line"><span class="string">$ (gdb)</span></span><br><span class="line"><span class="string">21</span></span><br><span class="line"><span class="string">22	    return 0;</span></span><br><span class="line"><span class="string">23	&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在行号为8的位置打断点</span></span><br><span class="line">$ (gdb) <span class="built_in">break</span> 8</span><br><span class="line">Breakpoint 1 at 0x400848: file set_break.cpp, line 8.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在行号为10的位置打断点</span></span><br><span class="line">$ (gdb) <span class="built_in">break</span> set_break.cpp:10</span><br><span class="line">Breakpoint 2 at 0x400864: file set_break.cpp, line 10.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在行号为12的位置打断点</span></span><br><span class="line">$ (gdb) <span class="built_in">break</span> 12</span><br><span class="line">Breakpoint 3 at 0x40086b: file set_break.cpp, line 12.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在行号为4的位置打断点</span></span><br><span class="line">$ (gdb) <span class="built_in">break</span> 4</span><br><span class="line">Breakpoint 4 at 0x400821: file set_break.cpp, line 4.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在行号为17的位置打断点</span></span><br><span class="line">$ (gdb) <span class="built_in">break</span> 17</span><br><span class="line">Breakpoint 5 at 0x400881: file set_break.cpp, line 17.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在行号为20的位置打断点</span></span><br><span class="line">$ (gdb) <span class="built_in">break</span> 20</span><br><span class="line">Breakpoint 6 at 0x40089a: file set_break.cpp, line 20.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在函数funcA处打断点，发现该断点已经重复了</span></span><br><span class="line">$ (gdb) <span class="built_in">break</span> funcA</span><br><span class="line">Note: breakpoint 4 also <span class="built_in">set</span> at pc 0x400821.</span><br><span class="line">Breakpoint 7 at 0x400821: file set_break.cpp, line 4.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有断点</span></span><br><span class="line">(gdb) info <span class="built_in">break</span></span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000400848 <span class="keyword">in</span> main() at set_break.cpp:8</span><br><span class="line">2       breakpoint     keep y   0x0000000000400864 <span class="keyword">in</span> main() at set_break.cpp:10</span><br><span class="line">3       breakpoint     keep y   0x000000000040086b <span class="keyword">in</span> main() at set_break.cpp:12</span><br><span class="line">4       breakpoint     keep y   0x0000000000400821 <span class="keyword">in</span> funcA() at set_break.cpp:4</span><br><span class="line">5       breakpoint     keep y   0x0000000000400881 <span class="keyword">in</span> main() at set_break.cpp:17</span><br><span class="line">6       breakpoint     keep y   0x000000000040089a <span class="keyword">in</span> main() at set_break.cpp:20</span><br><span class="line">7       breakpoint     keep y   0x0000000000400821 <span class="keyword">in</span> funcA() at set_break.cpp:4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令run开始运行程序，发现现在程序卡在了行号为8的位置</span></span><br><span class="line">$ (gdb) run</span><br><span class="line">Starting program: xxx/set_break</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at set_break.cpp:8</span><br><span class="line">8	    std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; <span class="string">std::endl;</span></span><br></pre></td></tr></table></figure>
<h3 id="434-调试"><a class="markdownIt-Anchor" href="#434-调试"></a> 4.3.4 调试</h3>
<ul>
<li><code>continue</code>：继续运行直至程序结束或者遇到下一个断点</li>
<li><code>step</code>：源码级别的单步调试，会进入方法，另一种说法是<code>step into</code></li>
<li><code>next</code>：源码级别的单步调试，不会进入方法，将方法调用视为一步，另一种说法是<code>step over</code></li>
<li><code>stepi</code>：指令级别的单步调试，会进入方法，另一种说法是<code>step into</code></li>
<li><code>nexti</code>：指令级别的单步调试，不会进入方法，将方法调用视为一步，另一种说法是<code>step over</code></li>
<li><code>until</code>：退出循环</li>
<li><code>finish</code>：结束当前函数的执行</li>
<li><code>display &lt;variable&gt;</code>：跟踪查看某个变量，每次停下来都显示它的值</li>
<li><code>undisplay &lt;display_id&gt;</code>：取消跟踪</li>
<li><code>watch</code>：设置观察点。当被设置观察点的变量发生修改时，打印显示</li>
<li><code>thread &lt;id&gt;</code>：切换调试的线程为指定线程</li>
</ul>
<h3 id="435-查看调试相关信息"><a class="markdownIt-Anchor" href="#435-查看调试相关信息"></a> 4.3.5 查看调试相关信息</h3>
<ul>
<li><code>bt</code>、<code>backtrace</code>、<code>where</code>：查看当前调用堆栈
<ul>
<li><code>bt 3</code>：最上面3层</li>
<li><code>bt -3</code>：最下面3层</li>
</ul>
</li>
<li><code>disassemble</code>：查看当前的汇编指令
<ul>
<li><code>disassemble</code>：当前函数的汇编指令</li>
<li><code>disassemble &lt;function&gt;</code>：指定函数的汇编指令</li>
</ul>
</li>
<li><code>list</code>：查看源码
<ul>
<li><code>list</code>：紧接着上一次的输出，继续输出10行源码</li>
<li><code>list &lt;linenumber&gt;</code>：输出当前文件指定行号开始的10行源码</li>
<li><code>list &lt;function&gt;</code>：输出指定函数的10行源码</li>
<li><code>list &lt;filename:linenum&gt;</code>：输出指定文件指定行号开始的10行源码</li>
<li><code>list &lt;filename:function&gt;</code>：输出指定文件指定函数的10行源码</li>
</ul>
</li>
<li><code>info</code>用于查看各种调试相关的信息
<ul>
<li><code>info break</code>：查看断点</li>
<li><code>info reg</code>：查看寄存器</li>
<li><code>info stack</code>：查看堆栈</li>
<li><code>info thread</code>：查看线程</li>
<li><code>info locals</code>：查看本地变量</li>
<li><code>info args</code>：查看参数</li>
<li><code>info symbol &lt;address&gt;</code>：查看指定内存地址所对应的符号信息（如果有的话）</li>
</ul>
</li>
<li><code>print</code>：用于查看变量
<ul>
<li><code>print &lt;variable&gt;</code></li>
<li><code>print &lt;variable&gt;.&lt;field&gt;</code></li>
<li><code>p *((std::vector&lt;uint32_t&gt;*) &lt;address&gt;)</code>：查看智能指针</li>
</ul>
</li>
<li><code>x/&lt;n/f/u&gt; &lt;addr&gt;</code>：以指定格式打印内存信息
<ul>
<li><code>n</code>：正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容，一个内存单元的大小由第三个参数<code>u</code>定义</li>
<li><code>f</code>：表示<code>addr</code>指向的内存内容的输出格式
<ul>
<li><code>s</code>：对应输出字符串</li>
<li><code>x</code>：按十六进制格式显示变量</li>
<li><code>d</code>：按十进制格式显示变量</li>
<li><code>u</code>：按十进制格式显示无符号整型</li>
<li><code>o</code>：按八进制格式显示变量</li>
<li><code>t</code>：按二进制格式显示变量</li>
<li><code>a</code>：按十六进制格式显示变量</li>
<li><code>c</code>：按字符格式显示变量</li>
<li><code>f</code>：按浮点数格式显示变量</li>
</ul>
</li>
<li><code>u</code>：就是指以多少个字节作为一个内存单元-unit，默认为4。<code>u</code>还可以用被一些字符表示:
<ul>
<li><code>b</code>：1 byte</li>
<li><code>h</code>：2 bytes</li>
<li><code>w</code>：4 bytes</li>
<li><code>g</code>：8 bytes</li>
</ul>
</li>
<li>示例：
<ul>
<li><code>x /1ug $rbp-0x4</code>：查看寄存器<code>rbp</code>存储的内容减去<code>0x4</code>得到的地址中所存储的内容</li>
<li><code>x /1xg $rsp</code>：查看寄存器<code>rsp</code>存储的地址中所存储的内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><code>info reg</code>会显示所有寄存器的内容，其中内容会打印两列，第一列是以16进制的形式输出（<code>raw format</code>），另一列是以原始形式输出（<code>natural format</code>），下面显式了所有寄存器的大小以及类型</strong></p>
<ul>
<li>类型为<code>int64</code>的寄存器，<code>natural format</code>用十进制表示</li>
<li>类型为<code>data_ptr</code>以及<code>code_ptr</code>的寄存器，<code>natural format</code>仍然以十六进制表示，所以你会看到两列完全一样的值</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;rax&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int64&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;rbx&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int64&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;rcx&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int64&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;rdx&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int64&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;rsi&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int64&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;rdi&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int64&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;rbp&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;data_ptr&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;rsp&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;data_ptr&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;r8&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int64&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;r9&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int64&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;r10&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int64&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;r11&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int64&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;r12&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int64&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;r13&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int64&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;r14&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int64&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;r15&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int64&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;rip&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;64&quot;</span> <span class="attr">type</span>=<span class="string">&quot;code_ptr&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;eflags&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;32&quot;</span> <span class="attr">type</span>=<span class="string">&quot;i386_eflags&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;cs&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;32&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int32&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;ss&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;32&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int32&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;ds&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;32&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int32&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;es&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;32&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int32&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;fs&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;32&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int32&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reg</span> <span class="attr">name</span>=<span class="string">&quot;gs&quot;</span> <span class="attr">bitsize</span>=<span class="string">&quot;32&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int32&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="4351-demo-of-print"><a class="markdownIt-Anchor" href="#4351-demo-of-print"></a> 4.3.5.1 demo of print</h4>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># c++源文件</span></span><br><span class="line">$ cat &gt; print.cpp &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">struct Person &#123;</span><br><span class="line">    const char* name;</span><br><span class="line">    const char* phone_num;</span><br><span class="line">    const int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    Person p &#123;<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;123456789&quot;</span>, 18&#125;;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译（可以试下不加-g参数）</span></span><br><span class="line">$ g++ -o <span class="built_in">print</span> print.cpp -std=gnu++11 -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入gdb shell</span></span><br><span class="line">$ gdb <span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看源码</span></span><br><span class="line">$ list</span><br><span class="line">(gdb) list</span><br><span class="line">1	struct Person &#123;</span><br><span class="line">2	    const char* name;</span><br><span class="line">3	    const char* phone_num;</span><br><span class="line">4	    const int age;</span><br><span class="line">5	&#125;;</span><br><span class="line">6</span><br><span class="line">7	int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">8	    Person p &#123;<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;123456789&quot;</span>, 18&#125;;</span><br><span class="line">9	    <span class="built_in">return</span> 0;</span><br><span class="line">10	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置断点</span></span><br><span class="line">$ (gdb) <span class="built_in">break</span> 9</span><br><span class="line">Breakpoint 1 at 0x400528: file print.cpp, line 9.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行程序，会停在断点处</span></span><br><span class="line">$ (gdb) run</span><br><span class="line">Starting program: xxx/<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at print.cpp:9</span><br><span class="line">9	    <span class="built_in">return</span> 0;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看相关信息</span></span><br><span class="line">$ (gdb) <span class="built_in">print</span> p</span><br><span class="line"><span class="variable">$1</span> = &#123;name = 0x4005c0 <span class="string">&quot;张三&quot;</span>, phone_num = 0x4005c7 <span class="string">&quot;123456789&quot;</span>, age = 18&#125;</span><br><span class="line">$ (gdb) <span class="built_in">print</span> p.name</span><br><span class="line"><span class="variable">$2</span> = 0x4005c0 <span class="string">&quot;张三&quot;</span></span><br><span class="line">$ (gdb) <span class="built_in">print</span> p.phone_num</span><br><span class="line"><span class="variable">$3</span> = 0x4005c7 <span class="string">&quot;123456789&quot;</span></span><br><span class="line">$ (gdb) <span class="built_in">print</span> p.age</span><br><span class="line"><span class="variable">$4</span> = 18</span><br><span class="line">$ (gdb) <span class="built_in">print</span> &amp;p</span><br><span class="line"><span class="variable">$5</span> = (Person *) 0x7fffffffe0c0</span><br></pre></td></tr></table></figure>
<h3 id="436-执行外部命令"><a class="markdownIt-Anchor" href="#436-执行外部命令"></a> 4.3.6 <code>!</code>执行外部命令</h3>
<p>格式：<code>!&lt;command&gt; [params]</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) !<span class="built_in">pwd</span></span><br><span class="line">xxx/gdb_tutorial</span><br></pre></td></tr></table></figure>
<h2 id="44-asan"><a class="markdownIt-Anchor" href="#44-asan"></a> 4.4 ASAN</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/google/sanitizers">google/sanitizers</a></p>
<h2 id="45-参考"><a class="markdownIt-Anchor" href="#45-参考"></a> 4.5 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cs.umd.edu/~srhuang/teaching/cmsc212/gdb-tutorial-handout.pdf">GDB Tutorial - A Walkthrough with Examples</a></li>
<li><a target="_blank" rel="noopener" href="https://visualgdb.com/gdbreference/commands/">GDB Command Reference</a></li>
<li><a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/break-on-linenum.html">《100个gdb小技巧》</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/muclenerd/article/details/48005171">gdb 调试coredump文件中烂掉的栈帧的方法</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9809810/gdb-corrupted-stack-frame-how-to-debug">GDB corrupted stack frame - How to debug?</a></li>
<li><a target="_blank" rel="noopener" href="https://izualzhy.cn/why-the-code-stack-is-overflow">追core笔记之五：如何查看一个corrupt stack的core</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/muclenerd/article/details/48005171">gdb 调试coredump文件中烂掉的栈帧的方法</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/10005982/how-do-you-set-gdb-debug-flag-with-cmake">How do you set GDB debug flag with cmake?</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31026000/gdb-info-registers-command-second-column-of-output">GDB info registers command - Second column of output</a></li>
</ul>
<h1 id="5-make"><a class="markdownIt-Anchor" href="#5-make"></a> 5 Make</h1>
<p><strong>代码变成可执行文件，叫做编译<code>compile</code>；先编译这个，还是先编译那个（即编译的安排），叫做构建<code>build</code></strong></p>
<h2 id="51-makefile文件的格式"><a class="markdownIt-Anchor" href="#51-makefile文件的格式"></a> 5.1 Makefile文件的格式</h2>
<p><strong><code>Makefile</code>文件由一系列规则<code>rules</code>构成。每条规则的形式如下：</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>target</code>：目标，是必须的</li>
<li><code>prerequisites</code>：前置条件，不是必须的，但是<code>prerequisites</code>与<code>commands</code>至少有一个是必须的</li>
<li><code>commands</code>：即完成目标需要执行的命令，不是必须的，但是<code>prerequisites</code>与<code>commands</code>至少有一个是必须的</li>
</ul>
<h3 id="511-target"><a class="markdownIt-Anchor" href="#511-target"></a> 5.1.1 target</h3>
<p>一个目标<code>target</code>就构成一条规则。<strong>目标通常是文件名</strong>，指明<code>make</code>命令所要构建的对象。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔</p>
<p><strong>除了文件名，目标还可以是某个操作的名字，这称为「伪目标」<code>phony target</code>，例如</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o</span><br></pre></td></tr></table></figure>
<p>但是，项目中可能有名为<code>clean</code>的文件名，<code>make</code>发现<code>clean</code>文件已经存在，就认为没有必要重新构建了，因此可以明确声明「伪目标」</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure>
<p><strong>如果<code>make</code>命令运行时没有指定目标，默认会执行<code>Makefile</code>文件的第一个目标</strong></p>
<h3 id="512-prerequisites"><a class="markdownIt-Anchor" href="#512-prerequisites"></a> 5.1.2 prerequisites</h3>
<p>前置条件通常是一组文件名，之间用空格分隔。它指定了目标是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的<code>last-modification</code>时间戳比目标的时间戳新），目标就需要重新构建</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">result.txt: source.txt</span></span><br><span class="line">    cp source.txt result.txt</span><br></pre></td></tr></table></figure>
<p>上面代码中，构建<code>result.txt</code>的前置条件是<code>source.txt</code>。如果当前目录中，<code>source.txt</code>已经存在，那么<code>make result.txt</code>可以正常运行，否则必须再写一条规则，来生成<code>source.txt</code></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">source.txt:</span></span><br><span class="line">    echo <span class="string">&quot;this is the source&quot;</span> &gt; source.txt</span><br></pre></td></tr></table></figure>
<p>连续执行两次<code>make result.txt</code>。第一次执行会先新建<code>source.txt</code>，然后再新建<code>result.txt</code>。第二次执行，<code>make</code>发现<code>source.txt</code>没有变动（时间戳晚于<code>result.txt</code>），就不会执行任何操作，<code>result.txt</code>也不会重新生成</p>
<p>如果需要生成多个文件，往往采用下面的写法</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">source: file1 file2 file3</span></span><br></pre></td></tr></table></figure>
<p>这样仅需要执行<code>make source</code>便可生成3个文件，而无需执行<code>make file1</code>、<code>make file2</code>、<code>make file3</code></p>
<h3 id="513-commands"><a class="markdownIt-Anchor" href="#513-commands"></a> 5.1.3 commands</h3>
<p>命令<code>commands</code>表示如何更新目标文件，由一行或多行的<code>shell</code>命令组成。它是构建目标的具体指令，它的运行结果通常就是生成目标文件</p>
<p>每行命令之前必须有一个<code>tab</code>键。如果想用其他键，可以用内置变量<code>.RECIPEPREFIX</code>声明</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">&gt; echo Hello, world</span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是，每行命令在一个单独的<code>shell</code>中执行。这些<code>shell</code>之间没有继承关系</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var-lost:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar</span><br><span class="line">    echo <span class="string">&quot;foo=[$$foo]&quot;</span></span><br></pre></td></tr></table></figure>
<p>一个解决办法是将两行命令写在一行，中间用分号分隔</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; echo <span class="string">&quot;foo=[$$foo]&quot;</span></span><br></pre></td></tr></table></figure>
<p>另一个解决办法是在换行符前加反斜杠转义</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; \</span><br><span class="line">    echo <span class="string">&quot;foo=[$$foo]&quot;</span></span><br></pre></td></tr></table></figure>
<p>更好的方法是加上<code>.ONESHELL:</code>命令</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.ONESHELL:</span></span><br><span class="line"><span class="section">var-kept:</span></span><br><span class="line">    <span class="keyword">export</span> foo=bar; </span><br><span class="line">    echo <span class="string">&quot;foo=[$$foo]&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="52-makefile文件的语法"><a class="markdownIt-Anchor" href="#52-makefile文件的语法"></a> 5.2 Makefile文件的语法</h2>
<h3 id="521-注释"><a class="markdownIt-Anchor" href="#521-注释"></a> 5.2.1 注释</h3>
<p>井号<code>#</code>在<code>Makefile</code>中表示注释</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line"><span class="section">result.txt: source.txt</span></span><br><span class="line">    <span class="comment"># 这是注释</span></span><br><span class="line">    cp source.txt result.txt <span class="comment"># 这也是注释</span></span><br></pre></td></tr></table></figure>
<h3 id="522-回声echoing"><a class="markdownIt-Anchor" href="#522-回声echoing"></a> 5.2.2 回声（echoing）</h3>
<p>正常情况下，<code>make</code>会打印每条命令，然后再执行，这就叫做回声<code>echoing</code></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:</span></span><br><span class="line">    <span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure>
<p>执行上面的规则，会得到下面的结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure>
<p>在命令的前面加上<code>@</code>，就可以关闭回声</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:</span></span><br><span class="line">    @<span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure>
<h3 id="523-通配符"><a class="markdownIt-Anchor" href="#523-通配符"></a> 5.2.3 通配符</h3>
<p>通配符<code>wildcard</code>用来指定一组符合条件的文件名。<code>Makefile</code>的通配符与 <code>Bash</code>一致，主要有星号<code>*</code>、问号<code>？</code>和<code>...</code>。比如，<code>*.o</code>表示所有后缀名为<code>o</code>的文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -f *.o</span><br></pre></td></tr></table></figure>
<h3 id="524-模式匹配"><a class="markdownIt-Anchor" href="#524-模式匹配"></a> 5.2.4 模式匹配</h3>
<p><code>make</code>命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是<code>%</code>。比如，假定当前目录下有<code>f1.c</code>和<code>f2.c</code>两个源码文件，需要将它们编译为对应的对象文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br></pre></td></tr></table></figure>
<p>等同于下面的写法</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">f1.o: f1.c</span></span><br><span class="line"><span class="section">f2.o: f2.c</span></span><br></pre></td></tr></table></figure>
<p><strong>使用匹配符<code>%</code>，可以将大量同类型的文件，只用一条规则就完成构建</strong></p>
<h3 id="525-变量和赋值符"><a class="markdownIt-Anchor" href="#525-变量和赋值符"></a> 5.2.5 变量和赋值符</h3>
<p><code>Makefile</code>允许使用等号自定义变量</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">txt = Hello World</span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    @echo <span class="variable">$(txt)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>txt</code>等于<code>Hello World</code>。<strong>调用时，变量需要放在<code>$()</code>之中</strong></p>
<p><strong>调用<code>shell</code>变量，需要在<code>$</code>前，再加一个<code>$</code>，这是因为<code>make</code>命令会对<code>$</code>转义</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test:</span></span><br><span class="line">    @echo $$HOME</span><br></pre></td></tr></table></figure>
<h3 id="526-内置变量implicit-variables"><a class="markdownIt-Anchor" href="#526-内置变量implicit-variables"></a> 5.2.6 内置变量（Implicit Variables）</h3>
<p><code>make</code>命令提供一系列内置变量，比如，<code>$(CC)</code>指向当前使用的编译器，<code>$(MAKE)</code>指向当前使用的<code>make</code>工具。这主要是为了跨平台的兼容性，详细的内置变量清单见<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">手册</a></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">output:</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o output input.c</span><br></pre></td></tr></table></figure>
<h3 id="527-自动变量automatic-variables"><a class="markdownIt-Anchor" href="#527-自动变量automatic-variables"></a> 5.2.7 自动变量（Automatic Variables）</h3>
<p><code>make</code>命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个，可以参考<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">手册</a></p>
<h4 id="5271"><a class="markdownIt-Anchor" href="#5271"></a> 5.2.7.1 <code>$@</code></h4>
<p><code>$@</code>指代当前目标，就是<code>make</code>命令当前构建的那个目标。比如，<code>make foo</code>的<code>$@</code>就指代<code>foo</code></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt b.txt: </span><br><span class="line">    touch <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>等同于下面的写法</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.txt:</span></span><br><span class="line">    touch a.txt</span><br><span class="line"><span class="section">b.txt:</span></span><br><span class="line">    touch b.txt</span><br></pre></td></tr></table></figure>
<h4 id="5272"><a class="markdownIt-Anchor" href="#5272"></a> 5.2.7.2 <code>$&lt;</code></h4>
<p><code>$&lt;</code>指代第一个前置条件。比如，规则为<code>t: p1 p2</code>，那么<code>$&lt;</code>就指代<code>p1</code></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.txt: b.txt c.txt</span></span><br><span class="line">    cp <span class="variable">$&lt;</span> <span class="variable">$@</span> </span><br></pre></td></tr></table></figure>
<p>等同于下面的写法</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.txt: b.txt c.txt</span></span><br><span class="line">    cp b.txt a.txt </span><br></pre></td></tr></table></figure>
<h4 id="5273"><a class="markdownIt-Anchor" href="#5273"></a> 5.2.7.3 <code>$?</code></h4>
<p><code>$?</code>指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为<code>t: p1 p2</code>，其中<code>p2</code>的时间戳比<code>t</code>新，<code>$?</code>就指代<code>p2</code></p>
<h4 id="5274"><a class="markdownIt-Anchor" href="#5274"></a> 5.2.7.4 <code>$^</code></h4>
<p><code>$^</code>指代所有前置条件，之间以空格分隔。比如，规则为<code>t: p1 p2</code>，那么<code>$^</code>就指代<code>p1 p2</code></p>
<h4 id="5275"><a class="markdownIt-Anchor" href="#5275"></a> 5.2.7.5 <code>$*</code></h4>
<p><code>$*</code>指代匹配符<code>%</code>匹配的部分，比如<code>%.txt</code>匹配<code>f1.txt</code>中的<code>f1</code>，<code>$*</code>就表示<code>f1</code></p>
<h4 id="5276-df"><a class="markdownIt-Anchor" href="#5276-df"></a> 5.2.7.6 <code>$(@D)/$(@F)</code></h4>
<p><code>$(@D)</code>和<code>$(@F)</code>分别指向<code>$@</code>的目录名和文件名。比如，<code>$@</code>是<code>src/input.c</code>，那么<code>$(@D)</code>的值为<code>src</code>，<code>$(@F)</code>的值为<code>input.c</code></p>
<h4 id="5277-df"><a class="markdownIt-Anchor" href="#5277-df"></a> 5.2.7.7 <code>$(&lt;D)/$(&lt;F)</code></h4>
<p><code>$(&lt;D)</code>和<code>$(&lt;F)</code>分别指向<code>$&lt;</code>的目录名和文件名</p>
<h4 id="5278-例子"><a class="markdownIt-Anchor" href="#5278-例子"></a> 5.2.7.8 例子</h4>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">dest/%.txt: src/%.txt</span></span><br><span class="line">    @[ -d dest ] || mkdir dest</span><br><span class="line">    cp <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>上面代码将<code>src</code>目录下的<code>txt</code>文件，拷贝到<code>dest</code>目录下。首先判断<code>dest</code>目录是否存在，如果不存在就新建，然后，<code>$&lt;</code>指代前置文件<code>src/%.txt</code>，<code>$@</code>指代目标文件<code>dest/%.txt</code></p>
<h3 id="528-判断和循环"><a class="markdownIt-Anchor" href="#528-判断和循环"></a> 5.2.8 判断和循环</h3>
<p><code>Makefile</code>使用<code>Bash</code>语法，完成判断和循环</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">  libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LIST = one two three</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    for i in <span class="variable">$(LIST)</span>; do \</span><br><span class="line">        echo $$i; \</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    for i in one two three; do \</span><br><span class="line">        echo $$i; \</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>
<h3 id="529-函数"><a class="markdownIt-Anchor" href="#529-函数"></a> 5.2.9 函数</h3>
<p><code>Makefile</code>还可以使用函数，格式如下</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(function arguments)</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$&#123;function arguments&#125;</span><br></pre></td></tr></table></figure>
<p><code>Makefile</code>提供了许多<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Functions.html">内置函数</a>，可供调用</p>
<h2 id="53-参考"><a class="markdownIt-Anchor" href="#53-参考"></a> 5.3 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/02/make.html">Make 命令教程</a></li>
</ul>
<h1 id="6-cmake"><a class="markdownIt-Anchor" href="#6-cmake"></a> 6 CMake</h1>
<h2 id="61-tutorial"><a class="markdownIt-Anchor" href="#61-tutorial"></a> 6.1 tutorial</h2>
<h3 id="611-step1-a-basic-starting-point"><a class="markdownIt-Anchor" href="#611-step1-a-basic-starting-point"></a> 6.1.1 step1: A Basic Starting Point</h3>
<p><code>tutorial.cxx</code>内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; number&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// convert input to double</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> inputValue = <span class="built_in">atof</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// calculate square root</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The square root of &quot;</span> &lt;&lt; inputValue &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; outputValue</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CMakeLists.txt</code>内容如下：</p>
<ul>
<li><code>cmake_minimum_required</code>：用于指定<code>cmake</code>的最小版本，避免出现兼容性问题（包含了高级版本的特性，但是实际的<code>cmake</code>版本较小）</li>
<li><code>project</code>：用于设置项目名称，并存储到<code>CMAKE_PROJECT_NAME</code>变量中，<code>cmake</code>中的一些环境变量会以这里指定的项目名称作为前缀，例如
<ul>
<li><code>PROJECT_SOURCE_DIR</code>、<code>&lt;PROJECT-NAME&gt;_SOURCE_DIR</code></li>
<li><code>PROJECT_BINARY_DIR</code>、<code>&lt;PROJECT-NAME&gt;_BINARY_DIR</code></li>
</ul>
</li>
<li><code>set</code>：用于设置一些变量</li>
<li><code>add_executable</code>：添加目标可执行文件</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name and version</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br></pre></td></tr></table></figure>
<p>此时文件结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── tutorial.cxx</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./Tutorial 256</span><br></pre></td></tr></table></figure>
<h3 id="612-step2-adding-a-library-and-adding-usage-requirements-for-a-library"><a class="markdownIt-Anchor" href="#612-step2-adding-a-library-and-adding-usage-requirements-for-a-library"></a> 6.1.2 step2: Adding a Library and Adding Usage Requirements for a Library</h3>
<p>接下来，我们用自己实现的求开方的函数替换标准库中的实现。创建<code>MathFunctions</code>子目录，并在该子目录添加<code>MathFunctions.h</code>以及<code>mysqrt.cxx</code>、<code>CMakeLists.txt</code>三个文件</p>
<p><code>MathFunctions/MathFunctions.h</code>内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>MathFunctions/mysqrt.cxx</code>内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a hack square root calculation using simple operations</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> result = x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do ten iterations</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      result = <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> delta = x - (result * result);</span><br><span class="line">    result = result + <span class="number">0.5</span> * delta / result;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Computing sqrt of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; to be &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MathFunctions/CMakeLists.txt</code>内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(MathFunctions mysqrt.cxx)</span><br></pre></td></tr></table></figure>
<p>添加<code>TutorialConfig.h.in</code>文件，内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#cmakedefine USE_MYMATH</span></span><br></pre></td></tr></table></figure>
<p>修改<code>tutorial.cxx</code>文件，内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TutorialConfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">include</span> <span class="meta-string">&quot;MathFunctions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; number&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// convert input to double</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> inputValue = <span class="built_in">atof</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// calculate square root</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">mysqrt</span>(inputValue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The square root of &quot;</span> &lt;&lt; inputValue &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; outputValue</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>CMakeLists.txt</code>文件，内容如下：</p>
<ul>
<li><code>option</code>：用于添加<code>cmake</code>选项，可以通过<code>-D&lt;OPTION-NAME&gt;=ON/OFF</code>参数来选择打开或者关闭该选项
<ul>
<li>例如<code>cmake .. -DUSE_MYMATH=OFF</code></li>
</ul>
</li>
<li><code>configure_file</code>：一般用于根据cmake选项动态生成头文件</li>
<li><code>if statement</code>：控制流</li>
<li><code>add_subdirectory</code>：用于将子目录添加到构建任务中</li>
<li><code>list</code>：容器相关的操作</li>
<li><code>target_link_libraries</code>：指定库文件</li>
<li><code>target_include_directories</code>：指定头文件搜索路径</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name and version</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify the C++ standard</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">&quot;Use tutorial provided math implementation&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># configure a header file to pass some of the CMake settings</span></span><br><span class="line"><span class="comment"># to the source code</span></span><br><span class="line"><span class="keyword">configure_file</span>(TutorialConfig.h.in TutorialConfig.h)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(USE_MYMATH)</span><br><span class="line">  <span class="keyword">add_subdirectory</span>(MathFunctions)</span><br><span class="line">  <span class="keyword">list</span>(APPEND EXTRA_LIBS MathFunctions)</span><br><span class="line">  <span class="keyword">list</span>(APPEND EXTRA_INCLUDES <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Tutorial PUBLIC <span class="variable">$&#123;EXTRA_LIBS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(Tutorial PUBLIC</span><br><span class="line">                           <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span></span><br><span class="line">                           <span class="variable">$&#123;EXTRA_INCLUDES&#125;</span></span><br><span class="line">                           )</span><br></pre></td></tr></table></figure>
<p>此时目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── MathFunctions</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── MathFunctions.h</span><br><span class="line">│   └── mysqrt.cxx</span><br><span class="line">├── TutorialConfig.h.in</span><br><span class="line">└── tutorial.cxx</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用的是自定义的sqrt函数</span></span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./Tutorial 256</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用的是标准库的sqrt函数</span></span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DUSE_MYMATH=OFF</span><br><span class="line">make</span><br><span class="line">./Tutorial 256</span><br></pre></td></tr></table></figure>
<h3 id="613-step3-installing"><a class="markdownIt-Anchor" href="#613-step3-installing"></a> 6.1.3 step3: Installing</h3>
<p>现在，我们要安装<code>make</code>后产生的二进制、库文件、头文件</p>
<p>在<code>step2</code>的基础上，修改<code>MathFunctions/CMakeLists.txt</code>文件，追加如下内容：</p>
<ul>
<li>其中这里指定了两个相对路径<code>lib</code>、<code>include</code>。前缀由<code>cmake</code>变量<code>CMAKE_INSTALL_PREFIX</code>确定，默认值为<code>/usr/local</code></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add the install targets</span></span><br><span class="line"><span class="keyword">install</span> (TARGETS MathFunctions DESTINATION bin)</span><br><span class="line"><span class="keyword">install</span>(FILES MathFunctions.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>在<code>step2</code>的基础上，修改<code>CMakeLists.txt</code>文件，追加如下内容：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add the install targets</span></span><br><span class="line"><span class="keyword">install</span> (TARGETS Tutorial DESTINATION bin)</span><br><span class="line"><span class="keyword">install</span> (FILES <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h&quot;</span> DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用默认的安装路径</span></span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定安装路径</span></span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DCMAKE_INSTALL_PREFIX=/tmp/mydir</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h3 id="614-step4-testing"><a class="markdownIt-Anchor" href="#614-step4-testing"></a> 6.1.4 step4: Testing</h3>
<p>接下来，增加测试功能。在<code>step2</code>的基础上，修改<code>CMakeLists.txt</code>文件，追加如下内容：</p>
<ul>
<li><code>add_test</code>：用于增加测试，其中<code>NAME</code>指定的是测试用例的名称，<code>RUN</code>指定的是测试的命令</li>
<li><code>function</code>：用于定义一个方法</li>
<li><code>set_tests_properties</code>：用于设置测试项的属性，这里指定了测试结果的通配符</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># does the application run</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Runs <span class="keyword">COMMAND</span> Tutorial <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># does the usage message work?</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME Usage <span class="keyword">COMMAND</span> Tutorial)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(Usage</span><br><span class="line">  PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">&quot;Usage:.*number&quot;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment"># define a function to simplify adding tests</span></span><br><span class="line"><span class="keyword">function</span>(do_test <span class="keyword">target</span> arg result)</span><br><span class="line">  <span class="keyword">add_test</span>(NAME Comp_<span class="variable">$&#123;arg&#125;</span> <span class="keyword">COMMAND</span> <span class="variable">$&#123;target&#125;</span> <span class="variable">$&#123;arg&#125;</span>)</span><br><span class="line">  <span class="keyword">set_tests_properties</span>(Comp_<span class="variable">$&#123;arg&#125;</span></span><br><span class="line">    PROPERTIES PASS_REGULAR_EXPRESSION <span class="variable">$&#123;result&#125;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endfunction</span>(do_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># do a bunch of result based tests</span></span><br><span class="line">do_test(Tutorial <span class="number">4</span> <span class="string">&quot;4 is 2&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">9</span> <span class="string">&quot;9 is 3&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">5</span> <span class="string">&quot;5 is 2.236&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">7</span> <span class="string">&quot;7 is 2.645&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">25</span> <span class="string">&quot;25 is 5&quot;</span>)</span><br><span class="line">do_test(Tutorial -<span class="number">25</span> <span class="string">&quot;-25 is [-nan|nan|0]&quot;</span>)</span><br><span class="line">do_test(Tutorial <span class="number">0.0001</span> <span class="string">&quot;0.0001 is 0.01&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">make test</span><br></pre></td></tr></table></figure>
<h3 id="615-step5-adding-system-introspection"><a class="markdownIt-Anchor" href="#615-step5-adding-system-introspection"></a> 6.1.5 step5: Adding System Introspection</h3>
<p>同一个库，在不同平台上的实现可能不同，例如A平台有方法<code>funcA</code>，而B平台没有<code>funcA</code>，因此我们需要有一种机制来检测这种差异</p>
<p>接下来，增加测试功能。在<code>step2</code>的基础上，修改<code>MathFunctions/CMakeLists.txt</code>文件，追加如下内容：</p>
<ul>
<li><code>include</code>：加载<code>cmake</code>模块，这里加载了<code>CheckSymbolExists</code>模块，该模块用于检测指定文件中的指定符号是否存在</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(CheckSymbolExists)</span><br><span class="line">check_symbol_exists(log <span class="string">&quot;math.h&quot;</span> HAVE_LOG)</span><br><span class="line">check_symbol_exists(exp <span class="string">&quot;math.h&quot;</span> HAVE_EXP)</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> (HAVE_LOG <span class="keyword">AND</span> HAVE_EXP))</span><br><span class="line">  <span class="keyword">unset</span>(HAVE_LOG CACHE)</span><br><span class="line">  <span class="keyword">unset</span>(HAVE_EXP CACHE)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_REQUIRED_LIBRARIES <span class="string">&quot;m&quot;</span>)</span><br><span class="line">  check_symbol_exists(log <span class="string">&quot;math.h&quot;</span> HAVE_LOG)</span><br><span class="line">  check_symbol_exists(exp <span class="string">&quot;math.h&quot;</span> HAVE_EXP)</span><br><span class="line">  <span class="keyword">if</span>(HAVE_LOG <span class="keyword">AND</span> HAVE_EXP)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(MathFunctions PRIVATE m)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(HAVE_LOG <span class="keyword">AND</span> HAVE_EXP)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(MathFunctions</span><br><span class="line">                             PRIVATE <span class="string">&quot;HAVE_LOG&quot;</span> <span class="string">&quot;HAVE_EXP&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<p>修改<code>MathFunctions/mysqrt.cxx</code>文件，内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a hack square root calculation using simple operations</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mysqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_LOG) &amp;&amp; defined(HAVE_EXP)</span></span><br><span class="line">  <span class="keyword">double</span> result = <span class="built_in">exp</span>(<span class="built_in">log</span>(x) * <span class="number">0.5</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Computing sqrt of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; to be &quot;</span> &lt;&lt; result</span><br><span class="line">            &lt;&lt; <span class="string">&quot; using log and exp&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">double</span> result = x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do ten iterations</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      result = <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> delta = x - (result * result);</span><br><span class="line">    result = result + <span class="number">0.5</span> * delta / result;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Computing sqrt of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; to be &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./Tutorial 25</span><br></pre></td></tr></table></figure>
<h2 id="62-target"><a class="markdownIt-Anchor" href="#62-target"></a> 6.2 target</h2>
<p><code>cmake</code>可以使用<code>add_executable</code>、<code>add_library</code>或<code>add_custom_target</code>等命令来定义目标<code>target</code>。与变量不同，目标在每个作用域都可见，且可以使用<code>get_property</code>和<code>set_property</code>获取或设置其属性</p>
<h2 id="63-property"><a class="markdownIt-Anchor" href="#63-property"></a> 6.3 property</h2>
<h3 id="631-include_directories"><a class="markdownIt-Anchor" href="#631-include_directories"></a> 6.3.1 INCLUDE_DIRECTORIES</h3>
<p><strong>去哪找头文件<code>.h</code>，<code>-I（GCC）</code></strong></p>
<ol>
<li><code>include_directories</code>：该方法会在全局维度添加<code>include</code>的搜索路径。这些搜索路径会被添加到所有<code>target</code>中去（包括所有<code>sub target</code>），会追加到所有<code>target</code>的<code>INCLUDE_DIRECTORIES</code>属性中去</li>
<li><code>target_include_directories</code>：该方法为指定<code>target</code>添加<code>include</code>的搜索路径，会追加到该<code>target</code>的<code>INCLUDE_DIRECTORIES</code>属性中去</li>
</ol>
<p>如何查看全局维度以及target维度的<code>INCLUDE_DIRECTORIES</code>属性值</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get_property</span>(dirs DIRECTORY <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span> PROPERTY <span class="keyword">INCLUDE_DIRECTORIES</span>)</span><br><span class="line"><span class="keyword">foreach</span>(dir <span class="variable">$&#123;dirs&#125;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;dir of include_directories=&#x27;$&#123;dir&#125;&#x27;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">get_target_property</span>(target_dirs &lt;<span class="keyword">TARGET</span>-NAME&gt; <span class="keyword">INCLUDE_DIRECTORIES</span>)</span><br><span class="line"><span class="keyword">foreach</span>(target_dir <span class="variable">$&#123;target_dirs&#125;</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;dir of target_include_directories=&#x27;$&#123;target_dir&#125;&#x27;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<h3 id="632-link_directories"><a class="markdownIt-Anchor" href="#632-link_directories"></a> 6.3.2 LINK_DIRECTORIES</h3>
<p><strong>去哪找库文件<code>.so/.dll/.lib/.dylib/...</code>，<code>-L（GCC）</code></strong></p>
<h3 id="633-link_libraries"><a class="markdownIt-Anchor" href="#633-link_libraries"></a> 6.3.3 LINK_LIBRARIES</h3>
<p><strong>需要链接的库文件的名字：<code>-l（GCC）</code></strong></p>
<h2 id="64-command"><a class="markdownIt-Anchor" href="#64-command"></a> 6.4 command</h2>
<h3 id="641-message"><a class="markdownIt-Anchor" href="#641-message"></a> 6.4.1 message</h3>
<p>用于打印信息</p>
<p>格式：<code>message([&lt;mode&gt;] &quot;message text&quot; ...)</code></p>
<p>合法的<code>mode</code>包括</p>
<ul>
<li><code>FATAL_ERROR</code>：致命错误，终止构建</li>
<li><code>SEND_ERROR</code>：继续构建，终止<code>generation</code></li>
<li><code>WARNING</code>：告警信息，继续构建</li>
<li><code>AUTHOR_WARNING</code>：告警信息，继续构建</li>
<li><code>DEPRECATION</code>：当<code>CMAKE_ERROR_DEPRECATED</code>或<code>CMAKE_WARN_DEPRECATED</code>参数启用时，若使用了<code>deprecated</code>的特性，会打印<code>error</code>或者<code>warn</code>信息</li>
<li><code>NOTICE</code>：通过<code>stderr</code>打印的信息</li>
<li><strong><code>STATUS</code>：用户最应该关注的信息</strong></li>
<li><code>VERBOSE</code>：项目构建者需要关注的信息</li>
<li><code>DEBUG</code>：项目调试需要关注的信息</li>
<li><code>TRACE</code>：最低级别的信息</li>
</ul>
<h3 id="642-set"><a class="markdownIt-Anchor" href="#642-set"></a> 6.4.2 set</h3>
<p><code>set</code>用于设置：<code>cmake</code>变量或环境变量</p>
<p>格式：</p>
<ul>
<li><code>cmake</code>变量：<code>set(&lt;variable&gt; &lt;value&gt;... [PARENT_SCOPE])</code></li>
<li>环境变量：<code>set(ENV&#123;&lt;variable&gt;&#125; [&lt;value&gt;]</code></li>
</ul>
<p>变量如何引用：</p>
<ul>
<li><code>cmake</code>变量：<code>$&#123;&lt;variable&gt;&#125;</code></li>
<li>环境变量：<code>$ENV&#123;&lt;variable&gt;&#125;</code></li>
</ul>
<h3 id="643-option"><a class="markdownIt-Anchor" href="#643-option"></a> 6.4.3 option</h3>
<p><code>option</code>用于设置构建选项</p>
<p>格式：<code>option(&lt;variable&gt; &quot;&lt;help_text&gt;&quot; [value])</code></p>
<ul>
<li>其中<code>value</code>的可选值就是<code>ON</code>和<code>OFF</code>，其中<code>OFF</code>是默认值</li>
</ul>
<h3 id="644-file"><a class="markdownIt-Anchor" href="#644-file"></a> 6.4.4 file</h3>
<p><code>file</code>用于文件操作</p>
<p>格式：</p>
<ul>
<li><code>file(READ &lt;filename&gt; &lt;out-var&gt; [...])</code></li>
<li><code>file(&#123;WRITE | APPEND&#125; &lt;filename&gt; &lt;content&gt;...)</code></li>
</ul>
<p>操作类型说明：</p>
<ul>
<li><code>READ</code>：读取文件到变量中</li>
<li><code>WRITE</code>：覆盖写，文件不存在就创建</li>
<li><code>APPEND</code>：追加写，文件不存在就创建</li>
</ul>
<h3 id="645-add_executable"><a class="markdownIt-Anchor" href="#645-add_executable"></a> 6.4.5 add_executable</h3>
<p><code>add_executable</code>用于添加可执行文件</p>
<h3 id="646-add_library"><a class="markdownIt-Anchor" href="#646-add_library"></a> 6.4.6 add_library</h3>
<p><code>add_library</code>用于添加链接文件</p>
<h3 id="647-target_link_libraries"><a class="markdownIt-Anchor" href="#647-target_link_libraries"></a> 6.4.7 target_link_libraries</h3>
<p><code>target_link_libraries</code>指定链接给定目标时要使用的库或标志</p>
<h3 id="648-include_directories"><a class="markdownIt-Anchor" href="#648-include_directories"></a> 6.4.8 include_directories</h3>
<p><code>include_directories</code>：该方法会在全局维度添加<code>include</code>的搜索路径。这些搜索路径会被添加到所有<code>target</code>中去（包括所有<code>sub target</code>），会追加到所有<code>target</code>的<code>INCLUDE_DIRECTORIES</code>属性中去</p>
<h3 id="649-target_include_directories"><a class="markdownIt-Anchor" href="#649-target_include_directories"></a> 6.4.9 target_include_directories</h3>
<p><code>target_include_directories</code>：该方法为指定<code>target</code>添加<code>include</code>的搜索路径，会追加到该<code>target</code>的<code>INCLUDE_DIRECTORIES</code>属性中去</p>
<h3 id="6410-include"><a class="markdownIt-Anchor" href="#6410-include"></a> 6.4.10 include</h3>
<p><code>include</code>用于加载模块</p>
<h3 id="6411-find_package"><a class="markdownIt-Anchor" href="#6411-find_package"></a> 6.4.11 find_package</h3>
<p><strong>本小节转载摘录自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97369704">Cmake之深入理解find_package()的用法</a></strong></p>
<p>为了方便我们在项目中引入外部依赖包，<code>cmake</code>官方为我们预定义了许多寻找依赖包的<code>Module</code>，他们存储在<code>path_to_your_cmake/share/cmake-&lt;version&gt;/Modules</code>目录下。每个以<code>Find&lt;LibaryName&gt;.cmake</code>命名的文件都可以帮我们找到一个包。<strong>注意，<code>find_package(&lt;LibaryName&gt;)</code>与<code>Find&lt;LibaryName&gt;.cmake</code>中的<code>&lt;LibaryName&gt;</code>部分，大小写必须完全一致</strong></p>
<p>我们以<code>curl</code>库为例，假设我们项目需要引入这个库，从网站中请求网页到本地，我们看到官方已经定义好了<code>FindCURL.cmake</code>。所以我们在<code>CMakeLists.txt</code>中可以直接用<code>find_pakcage</code>进行引用</p>
<p>对于系统预定义的<code>Find&lt;LibaryName&gt;.cmake</code>模块，使用方法如下，每一个模块都会定义以下几个变量（这些信息会在<code>Find&lt;LibaryName&gt;.cmake</code>文件的最上方注释中说明）。<strong>注意，这些变量命名只是规范，命名中<code>&lt;LibaryName&gt;</code>部分是全部大写还是包含大小写完全由<code>Find&lt;LibaryName&gt;.cmake</code>文件决定。一般来说是大写的，例如<code>FindDemo.cmake</code>中定义的变量名为<code>DEMO_FOUND</code></strong></p>
<ul>
<li><code>&lt;LibaryName&gt;_FOUND</code></li>
<li><code>&lt;LibaryName&gt;_INCLUDE_DIR</code></li>
<li><code>&lt;LibaryName&gt;_LIBRARY</code>：该模块通过<code>add_library</code>定义的名称</li>
<li><code>&lt;LibaryName&gt;_STATIC_LIB</code></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(CURL)</span><br><span class="line"><span class="keyword">add_executable</span>(curltest curltest.cc)</span><br><span class="line"><span class="keyword">if</span>(CURL_FOUND)</span><br><span class="line">    <span class="keyword">target_include_directories</span>(clib PRIVATE <span class="variable">$&#123;CURL_INCLUDE_DIR&#125;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(curltest <span class="variable">$&#123;CURL_LIBRARY&#125;</span>)</span><br><span class="line"><span class="keyword">else</span>(CURL_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR ”CURL library <span class="keyword">not</span> found”)</span><br><span class="line"><span class="keyword">endif</span>(CURL_FOUND)</span><br></pre></td></tr></table></figure>
<p>你可以通过<code>&lt;LibaryName&gt;_FOUND</code>来判断模块是否被找到，如果没有找到，按照工程的需要关闭某些特性、给出提醒或者中止编译，上面的例子就是报出致命错误并终止构建。如果<code>&lt;LibaryName&gt;_FOUND</code>为真，则将<code>&lt;LibaryName&gt;_INCLUDE_DIR</code>加入<code>INCLUDE_DIRECTORIES</code></p>
<h4 id="64111-引入非官方的库"><a class="markdownIt-Anchor" href="#64111-引入非官方的库"></a> 6.4.11.1 引入非官方的库</h4>
<p><strong>通过<code>find_package</code>引入非官方的库，该方式只对支持cmake编译安装的库有效</strong></p>
<p>假设此时我们需要引入<code>glog</code>库来进行日志的记录，我们在<code>Module</code>目录下并没有找到<code>FindGlog.cmake</code>。所以我们需要自行安装<code>glog</code>库，再进行引用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clone该项目</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/google/glog.git </span><br><span class="line"><span class="comment"># 切换到需要的版本 </span></span><br><span class="line"><span class="built_in">cd</span> glog</span><br><span class="line">git checkout v0.40  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据官网的指南进行安装</span></span><br><span class="line">cmake -H. -Bbuild -G <span class="string">&quot;Unix Makefiles&quot;</span></span><br><span class="line">cmake --build build</span><br><span class="line">cmake --build build --target install</span><br></pre></td></tr></table></figure>
<p>此时我们便可以通过与引入<code>curl</code>库一样的方式引入<code>glog</code>库了</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(GLOG)</span><br><span class="line"><span class="keyword">add_executable</span>(glogtest glogtest.cc)</span><br><span class="line"><span class="keyword">if</span>(GLOG_FOUND)</span><br><span class="line">    <span class="comment"># 由于glog在连接时将头文件直接链接到了库里面，所以这里不用显示调用target_include_directories</span></span><br><span class="line">    <span class="keyword">target_link_libraries</span>(glogtest glog::glog)</span><br><span class="line"><span class="keyword">else</span>(GLOG_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR ”GLOG library <span class="keyword">not</span> found”)</span><br><span class="line"><span class="keyword">endif</span>(GLOG_FOUND)</span><br></pre></td></tr></table></figure>
<h4 id="64112-module模式与config模式"><a class="markdownIt-Anchor" href="#64112-module模式与config模式"></a> 6.4.11.2 Module模式与Config模式</h4>
<p>通过上文我们了解了通过<code>cmake</code>引入依赖库的基本用法。知其然也要知其所以然，<code>find_package</code>对我们来说是一个黑盒子，那么它是具体通过什么方式来查找到我们依赖的库文件的路径的呢。到这里我们就不得不聊到<code>find_package</code>的两种模式，一种是<code>Module</code>模式，也就是我们引入<code>curl</code>库的方式。另一种叫做<code>Config</code>模式，也就是引入<code>glog</code>库的模式。下面我们来详细介绍着两种方式的运行机制</p>
<p>在<code>Module</code>模式中，<code>cmake</code>需要找到一个叫做<code>Find&lt;LibraryName&gt;.cmake</code>的文件。这个文件负责找到库所在的路径，为我们的项目引入头文件路径和库文件路径。<code>cmake</code>搜索这个文件的路径有两个，一个是上文提到的<code>cmake</code>安装目录下的<code>share/cmake-&lt;version&gt;/Modules</code>目录，另一个使我们指定的<code>CMAKE_MODULE_PATH</code>的所在目录</p>
<p>如果<code>Module</code>模式搜索失败，没有找到对应的<code>Find&lt;LibraryName&gt;.cmake</code>文件，则转入<code>Config</code>模式进行搜索。它主要通过<code>&lt;LibraryName&gt;Config.cmake</code>或<code>&lt;lower-case-package-name&gt;-config.cmake</code>这两个文件来引入我们需要的库。以我们刚刚安装的<code>glog</code>库为例，在我们安装之后，它在<code>/usr/local/lib/cmake/glog/</code>目录下生成了<code>glog-config.cmake</code>文件，而<code>/usr/local/lib/cmake/&lt;LibraryName&gt;/</code>正是<code>find_package</code>函数的搜索路径之一</p>
<h4 id="64113-编写自己的findlibrarynamecmake模块"><a class="markdownIt-Anchor" href="#64113-编写自己的findlibrarynamecmake模块"></a> 6.4.11.3 编写自己的<code>Find&lt;LibraryName&gt;.cmake</code>模块</h4>
<p>假设我们编写了一个新的函数库，我们希望别的项目可以通过<code>find_package</code>对它进行引用我们应该怎么办呢。</p>
<p>我们在当前目录下新建一个<code>ModuleMode</code>的文件夹，在里面我们编写一个计算两个整数之和的一个简单的函数库。库函数以手工编写<code>Makefile</code>的方式进行安装，库文件安装在<code>/usr/lib</code>目录下，头文件放在<code>/usr/include</code>目录下。其中的Makefile文件如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、准备工作，编译方式、目标文件名、依赖库路径的定义。</span></span><br><span class="line">CC = g++</span><br><span class="line">CFLAGS  := -Wall -O3 -std=c++11 </span><br><span class="line"></span><br><span class="line">OBJS = libadd.o <span class="comment">#.o文件与.cpp文件同名</span></span><br><span class="line">LIB = libadd.so <span class="comment"># 目标文件名</span></span><br><span class="line">INCLUDE = ./ <span class="comment"># 头文件目录</span></span><br><span class="line">HEADER = libadd.h <span class="comment"># 头文件</span></span><br><span class="line"></span><br><span class="line">all : <span class="variable">$(LIB)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 生成.o文件 </span></span><br><span class="line"><span class="variable">$(OBJS)</span> : libadd.cc</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -I ./ -fpic -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 生成动态库文件</span></span><br><span class="line"><span class="variable">$(LIB)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">    rm -f <span class="variable">$@</span></span><br><span class="line">    g++ <span class="variable">$(OBJS)</span> -shared -o <span class="variable">$@</span> </span><br><span class="line">    rm -f <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 删除中间过程生成的文件 </span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span> <span class="variable">$(LIB)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.安装文件</span></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">    cp <span class="variable">$(LIB)</span> /usr/lib</span><br><span class="line">    cp <span class="variable">$(HEADER)</span> /usr/<span class="keyword">include</span></span><br></pre></td></tr></table></figure>
<p>编译安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>接下来我们回到我们的<code>cmake</code>项目中来，在<code>cmake</code>文件夹下新建一个<code>FindAdd.cmake</code>的文件。我们的目标是找到库的头文件所在目录和共享库文件的所在位置</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在指定目录下寻找头文件和动态库文件的位置，可以指定多个目标路径</span></span><br><span class="line"><span class="keyword">find_path</span>(ADD_INCLUDE_DIR libadd.h /usr/<span class="keyword">include</span>/ /usr/local/<span class="keyword">include</span> <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/ModuleMode)</span><br><span class="line"><span class="keyword">find_library</span>(<span class="keyword">ADD_LIBRARY</span> NAMES add PATHS /usr/lib/add /usr/local/lib/add <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/ModuleMode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ADD_INCLUDE_DIR <span class="keyword">AND</span> <span class="keyword">ADD_LIBRARY</span>)</span><br><span class="line">    <span class="keyword">set</span>(ADD_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">endif</span> (ADD_INCLUDE_DIR <span class="keyword">AND</span> <span class="keyword">ADD_LIBRARY</span>)</span><br></pre></td></tr></table></figure>
<p>这时我们便可以像引用<code>curl</code>一样引入我们自定义的库了，在<code>CMakeLists.txt</code>添加</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将项目目录下的cmake文件夹加入到CMAKE_MODULE_PATH中，让find_pakcage能够找到我们自定义的函数库</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/cmake;$&#123;CMAKE_MODULE_PATH&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(addtest addtest.cc)</span><br><span class="line"><span class="keyword">find_package</span>(ADD)</span><br><span class="line"><span class="keyword">if</span>(ADD_FOUND)</span><br><span class="line">    <span class="keyword">target_include_directories</span>(addtest PRIVATE <span class="variable">$&#123;ADD_INCLUDE_DIR&#125;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(addtest <span class="variable">$&#123;ADD_LIBRARY&#125;</span>)</span><br><span class="line"><span class="keyword">else</span>(ADD_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;ADD library not found&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>(ADD_FOUND)</span><br></pre></td></tr></table></figure>
<h3 id="6412-aux_source_directory"><a class="markdownIt-Anchor" href="#6412-aux_source_directory"></a> 6.4.12 aux_source_directory</h3>
<p>Find all source files in a directory</p>
<h2 id="65-tips"><a class="markdownIt-Anchor" href="#65-tips"></a> 6.5 Tips</h2>
<h3 id="651-打印cmake中所有的变量"><a class="markdownIt-Anchor" href="#651-打印cmake中所有的变量"></a> 6.5.1 打印cmake中所有的变量</h3>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get_cmake_property</span>(_variableNames VARIABLES)</span><br><span class="line"><span class="keyword">foreach</span> (_variableName <span class="variable">$&#123;_variableNames&#125;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;$&#123;_variableName&#125;=$&#123;$&#123;_variableName&#125;&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<h3 id="652-打印cmake中所有环境变量"><a class="markdownIt-Anchor" href="#652-打印cmake中所有环境变量"></a> 6.5.2 打印cmake中所有环境变量</h3>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> <span class="string">&quot;$&#123;CMAKE_COMMAND&#125;&quot;</span> <span class="string">&quot;-E&quot;</span> <span class="string">&quot;environment&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="653-开启debug模式"><a class="markdownIt-Anchor" href="#653-开启debug模式"></a> 6.5.3 开启debug模式</h3>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If you want to build for debug (including source information, i.e. -g) when compiling, use</span></span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug &lt;path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo &lt;path&gt;</span></span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo &lt;path&gt;</span><br></pre></td></tr></table></figure>
<h3 id="654-同一目录多个源文件"><a class="markdownIt-Anchor" href="#654-同一目录多个源文件"></a> 6.5.4 同一目录，多个源文件</h3>
<p>如果同一个目录下有多个源文件，那么在使用<code>add_executable</code>命令的时候，如果要一个个填写，那么将会非常麻烦，并且后续维护的代价也很大</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_executable(Demo main.cxx opt1.cxx opt2.cxx)</span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</code>）命令，该命令可以扫描一个目录下得所有源文件，并将文件列表赋值给一个变量</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line">add_executable(Demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="66-参考"><a class="markdownIt-Anchor" href="#66-参考"></a> 6.6 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">CMake Tutorial</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Kitware/CMake/tree/master/Help/guide/tutorial">CMake Tutorial对应的source code</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6df3857462cd">CMake Tutorial 翻译</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.hahack.com/codes/cmake/">CMake 入门实战</a></li>
<li><a target="_blank" rel="noopener" href="https://leehao.me/cmake-%E8%AF%AD%E8%A8%80-15-%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">CMake 语言 15 分钟入门教程</a></li>
<li><a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#manual:cmake-buildsystem(7)">CMake Table of Contents</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/31969547/what-is-the-difference-between-include-directories-and-target-include-directorie/40244458">What is the difference between include_directories and target_include_directories in CMake?</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97369704">Cmake之深入理解find_package()的用法</a></li>
</ul>
<h1 id="7-三方库"><a class="markdownIt-Anchor" href="#7-三方库"></a> 7 三方库</h1>
<h2 id="71-gtest"><a class="markdownIt-Anchor" href="#71-gtest"></a> 7.1 gtest</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/google/googletest">github-googletest</a></p>
<p>单元测试框架</p>
<h2 id="72-phmap"><a class="markdownIt-Anchor" href="#72-phmap"></a> 7.2 phmap</h2>
<p>全称：<code>parallel-hashmap</code>，提供了一组高性能、并发安全的map，用于替换<code>std</code>以及<code>boost</code>中的map</p>
<h1 id="8-其他"><a class="markdownIt-Anchor" href="#8-其他"></a> 8 其他</h1>
<h2 id="81-格式化"><a class="markdownIt-Anchor" href="#81-格式化"></a> 8.1 格式化</h2>
<p><code>.clang-format</code></p>
<p><strong>如何安装<code>clang-format</code></strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g clang-format</span><br></pre></td></tr></table></figure>
<h2 id="82-头文件搜索路径"><a class="markdownIt-Anchor" href="#82-头文件搜索路径"></a> 8.2 头文件搜索路径</h2>
<p><strong>头文件<code>#include &quot;xxx.h&quot;</code>的搜索顺序</strong></p>
<ol>
<li>先搜索当前目录</li>
<li>然后搜索<code>-I</code>参数指定的目录</li>
<li>再搜索gcc的环境变量<code>CPLUS_INCLUDE_PATH</code>（C程序使用的是<code>C_INCLUDE_PATH</code>）</li>
<li>最后搜索gcc的内定目录，包括：
<ul>
<li><code>/usr/include</code></li>
<li><code>/usr/local/include</code></li>
<li><code>/usr/lib/gcc/x86_64-redhat-linux/&lt;gcc version&gt;/include</code>（C头文件）或者<code>/usr/include/c++/&lt;gcc version&gt;</code>（C++头文件）</li>
</ul>
</li>
</ol>
<p><strong>头文件<code>#include &lt;xxx.h&gt;</code>的搜索顺序</strong></p>
<ol>
<li>先搜索<code>-I</code>参数指定的目录</li>
<li>再搜索gcc的环境变量<code>CPLUS_INCLUDE_PATH</code>（C程序使用的是<code>C_INCLUDE_PATH</code>）</li>
<li>最后搜索gcc的内定目录，包括：
<ul>
<li><code>/usr/include</code></li>
<li><code>/usr/local/include</code></li>
<li><code>/usr/lib/gcc/x86_64-redhat-linux/&lt;gcc version&gt;/include</code>（C头文件）或者<code>/usr/include/c++/&lt;gcc version&gt;</code>（C++头文件）</li>
</ul>
</li>
</ol>
<h2 id="83-参考"><a class="markdownIt-Anchor" href="#83-参考"></a> 8.3 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/crylearner/article/details/17013187">C/C++ 头文件以及库的搜索路径</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag"># 原创</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/02/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91-The-Design-and-Implementation-of-Modern-Column-Oriented-Database-Systems/" rel="prev" title="论文翻译-The-Design-and-Implementation-of-Modern-Column-Oriented-Database-Systems">
      <i class="fa fa-chevron-left"></i> 论文翻译-The-Design-and-Implementation-of-Modern-Column-Oriented-Database-Systems
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-livere">livere</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzY0My8xMDE5OA=="></div>
  </div>
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E8%AF%AD%E6%B3%95"><span class="nav-text"> 1 语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-c11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text"> 1.1 c++11新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-c14%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text"> 1.2 c++14新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-c17%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text"> 1.3 c++17新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-c20%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text"> 1.4 C++20新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-throw%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="nav-text"> 1.5 throw与异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text"> 1.6 类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#161-static_cast"><span class="nav-text"> 1.6.1 static_cast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#162-dynamic_cast"><span class="nav-text"> 1.6.2 dynamic_cast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#163-const_cast"><span class="nav-text"> 1.6.3 const_cast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#164-reinterpret_cast"><span class="nav-text"> 1.6.4 reinterpret_cast</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E5%A6%82%E4%BD%95%E5%9C%A8%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="nav-text"> 1.7 如何在类中定义常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text"> 1.8 初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#181-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-text"> 1.8.1 初始化列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#182-%E5%90%84%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 1.8.2 各种初始化类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-const"><span class="nav-text"> 1.9 const</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#191-%E9%A1%B6%E5%B1%82%E5%BA%95%E5%B1%82const"><span class="nav-text"> 1.9.1 顶层&#x2F;底层const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#192-const%E5%AE%9E%E5%8F%82%E5%92%8C%E5%BD%A2%E5%8F%82"><span class="nav-text"> 1.9.2 const实参和形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#193-const%E6%88%90%E5%91%98"><span class="nav-text"> 1.9.3 const成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#194-const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text"> 1.9.4 const成员函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#110-placement-new"><span class="nav-text"> 1.10 placement new</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#111-%E6%A8%A1%E6%9D%BF"><span class="nav-text"> 1.11 模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#112-%E5%AE%8F"><span class="nav-text"> 1.12 宏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1121-do-while0-in-macros"><span class="nav-text"> 1.12.1 do while(0) in macros</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#113-mock-class"><span class="nav-text"> 1.13 mock class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1131-demo-using-cmake"><span class="nav-text"> 1.13.1 demo using cmake</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#114-%E5%8F%82%E8%80%83"><span class="nav-text"> 1.14 参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text"> 2 标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#21-utility"><span class="nav-text"> 2.1 utility</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#211-stdmove"><span class="nav-text"> 2.1.1 std::move</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#212-stdforward"><span class="nav-text"> 2.1.2 std::forward</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-stdpromisestdfuture"><span class="nav-text"> 2.2 std::promise&#x2F;std::future</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-stdstring"><span class="nav-text"> 2.3 std::string</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-stdthread"><span class="nav-text"> 2.4 std::thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-stdchrono"><span class="nav-text"> 2.5 std::chrono</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-stdshared_ptr"><span class="nav-text"> 2.6 std::shared_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-stdfunction"><span class="nav-text"> 2.7 std::function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-stdbind"><span class="nav-text"> 2.8 std::bind</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-stdlock_guard"><span class="nav-text"> 2.9 std::lock_guard</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#210-stdcondition_variable"><span class="nav-text"> 2.10 std::condition_variable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#211-stdatomic"><span class="nav-text"> 2.11 std::atomic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#212-stdmem_fn"><span class="nav-text"> 2.12 std::mem_fn</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#213-stdany_cast"><span class="nav-text"> 2.13 std::any_cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#214-stdconditional_t"><span class="nav-text"> 2.14 std::conditional_t</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#215-%E5%8F%82%E8%80%83"><span class="nav-text"> 2.15 参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F"><span class="nav-text"> 3 编程范式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E5%BD%A2%E5%8F%82%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text"> 3.1 形参类型是否需要左右值引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text"> 3.2 返回类型是否需要左右值引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-traits%E7%BC%96%E8%AF%91%E6%9C%9F%E8%90%83%E5%8F%96%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="nav-text"> 3.3 traits编译期萃取类型信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#331-%E7%A4%BA%E4%BE%8B1"><span class="nav-text"> 3.3.1 示例1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#332-%E7%A4%BA%E4%BE%8B2"><span class="nav-text"> 3.3.2 示例2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-gdb"><span class="nav-text"> 4 GDB</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#41-gdb%E8%83%BD%E5%A4%9F%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-text"> 4.1 GDB能够做什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5gdb-shell"><span class="nav-text"> 4.2 如何进入GDB shell</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-command"><span class="nav-text"> 4.3 command</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#431-%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="nav-text"> 4.3.1 运行程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#432-gdb%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%85%B3%E8%81%94"><span class="nav-text"> 4.3.2 GDB与程序关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#433-%E6%96%AD%E7%82%B9%E8%AE%BE%E7%BD%AE"><span class="nav-text"> 4.3.3 断点设置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4331-demo"><span class="nav-text"> 4.3.3.1 demo</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#434-%E8%B0%83%E8%AF%95"><span class="nav-text"> 4.3.4 调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#435-%E6%9F%A5%E7%9C%8B%E8%B0%83%E8%AF%95%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="nav-text"> 4.3.5 查看调试相关信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4351-demo-of-print"><span class="nav-text"> 4.3.5.1 demo of print</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#436-%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4"><span class="nav-text"> 4.3.6 !执行外部命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-asan"><span class="nav-text"> 4.4 ASAN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-%E5%8F%82%E8%80%83"><span class="nav-text"> 4.5 参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-make"><span class="nav-text"> 5 Make</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#51-makefile%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-text"> 5.1 Makefile文件的格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#511-target"><span class="nav-text"> 5.1.1 target</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#512-prerequisites"><span class="nav-text"> 5.1.2 prerequisites</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#513-commands"><span class="nav-text"> 5.1.3 commands</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-makefile%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-text"> 5.2 Makefile文件的语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#521-%E6%B3%A8%E9%87%8A"><span class="nav-text"> 5.2.1 注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#522-%E5%9B%9E%E5%A3%B0echoing"><span class="nav-text"> 5.2.2 回声（echoing）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#523-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-text"> 5.2.3 通配符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#524-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-text"> 5.2.4 模式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#525-%E5%8F%98%E9%87%8F%E5%92%8C%E8%B5%8B%E5%80%BC%E7%AC%A6"><span class="nav-text"> 5.2.5 变量和赋值符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#526-%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8Fimplicit-variables"><span class="nav-text"> 5.2.6 内置变量（Implicit Variables）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#527-%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8Fautomatic-variables"><span class="nav-text"> 5.2.7 自动变量（Automatic Variables）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5271"><span class="nav-text"> 5.2.7.1 $@</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5272"><span class="nav-text"> 5.2.7.2 $&lt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5273"><span class="nav-text"> 5.2.7.3 $?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5274"><span class="nav-text"> 5.2.7.4 $^</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5275"><span class="nav-text"> 5.2.7.5 $*</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5276-df"><span class="nav-text"> 5.2.7.6 $(@D)&#x2F;$(@F)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5277-df"><span class="nav-text"> 5.2.7.7 $(&lt;D)&#x2F;$(&lt;F)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5278-%E4%BE%8B%E5%AD%90"><span class="nav-text"> 5.2.7.8 例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#528-%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF"><span class="nav-text"> 5.2.8 判断和循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#529-%E5%87%BD%E6%95%B0"><span class="nav-text"> 5.2.9 函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-%E5%8F%82%E8%80%83"><span class="nav-text"> 5.3 参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-cmake"><span class="nav-text"> 6 CMake</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#61-tutorial"><span class="nav-text"> 6.1 tutorial</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#611-step1-a-basic-starting-point"><span class="nav-text"> 6.1.1 step1: A Basic Starting Point</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#612-step2-adding-a-library-and-adding-usage-requirements-for-a-library"><span class="nav-text"> 6.1.2 step2: Adding a Library and Adding Usage Requirements for a Library</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#613-step3-installing"><span class="nav-text"> 6.1.3 step3: Installing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#614-step4-testing"><span class="nav-text"> 6.1.4 step4: Testing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#615-step5-adding-system-introspection"><span class="nav-text"> 6.1.5 step5: Adding System Introspection</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-target"><span class="nav-text"> 6.2 target</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63-property"><span class="nav-text"> 6.3 property</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#631-include_directories"><span class="nav-text"> 6.3.1 INCLUDE_DIRECTORIES</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#632-link_directories"><span class="nav-text"> 6.3.2 LINK_DIRECTORIES</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#633-link_libraries"><span class="nav-text"> 6.3.3 LINK_LIBRARIES</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-command"><span class="nav-text"> 6.4 command</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#641-message"><span class="nav-text"> 6.4.1 message</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#642-set"><span class="nav-text"> 6.4.2 set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#643-option"><span class="nav-text"> 6.4.3 option</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#644-file"><span class="nav-text"> 6.4.4 file</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#645-add_executable"><span class="nav-text"> 6.4.5 add_executable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#646-add_library"><span class="nav-text"> 6.4.6 add_library</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#647-target_link_libraries"><span class="nav-text"> 6.4.7 target_link_libraries</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#648-include_directories"><span class="nav-text"> 6.4.8 include_directories</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#649-target_include_directories"><span class="nav-text"> 6.4.9 target_include_directories</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6410-include"><span class="nav-text"> 6.4.10 include</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6411-find_package"><span class="nav-text"> 6.4.11 find_package</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#64111-%E5%BC%95%E5%85%A5%E9%9D%9E%E5%AE%98%E6%96%B9%E7%9A%84%E5%BA%93"><span class="nav-text"> 6.4.11.1 引入非官方的库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#64112-module%E6%A8%A1%E5%BC%8F%E4%B8%8Econfig%E6%A8%A1%E5%BC%8F"><span class="nav-text"> 6.4.11.2 Module模式与Config模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#64113-%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84findlibrarynamecmake%E6%A8%A1%E5%9D%97"><span class="nav-text"> 6.4.11.3 编写自己的Find&lt;LibraryName&gt;.cmake模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6412-aux_source_directory"><span class="nav-text"> 6.4.12 aux_source_directory</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#65-tips"><span class="nav-text"> 6.5 Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#651-%E6%89%93%E5%8D%B0cmake%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-text"> 6.5.1 打印cmake中所有的变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#652-%E6%89%93%E5%8D%B0cmake%E4%B8%AD%E6%89%80%E6%9C%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-text"> 6.5.2 打印cmake中所有环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#653-%E5%BC%80%E5%90%AFdebug%E6%A8%A1%E5%BC%8F"><span class="nav-text"> 6.5.3 开启debug模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#654-%E5%90%8C%E4%B8%80%E7%9B%AE%E5%BD%95%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-text"> 6.5.4 同一目录，多个源文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#66-%E5%8F%82%E8%80%83"><span class="nav-text"> 6.6 参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E4%B8%89%E6%96%B9%E5%BA%93"><span class="nav-text"> 7 三方库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#71-gtest"><span class="nav-text"> 7.1 gtest</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72-phmap"><span class="nav-text"> 7.2 phmap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E5%85%B6%E4%BB%96"><span class="nav-text"> 8 其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#81-%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-text"> 8.1 格式化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#82-%E5%A4%B4%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84"><span class="nav-text"> 8.2 头文件搜索路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#83-%E5%8F%82%E8%80%83"><span class="nav-text"> 8.3 参考</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liuyehcf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Liuyehcf</p>
  <div class="site-description" itemprop="description">大音希声，大象无形</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">310</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">117</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liuyehcf</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qhEhLuMeMOy1zgcBhkqUS6P8-gzGzoHsz',
      appKey     : 'uhkruDLNLNdL5rQjRBY2X9Ke',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
