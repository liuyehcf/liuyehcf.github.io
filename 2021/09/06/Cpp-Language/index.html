<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="阅读更多">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp-Language">
<meta property="og:url" content="http://example.com/2021/09/06/Cpp-Language/index.html">
<meta property="og:site_name" content="Liuye Notebook">
<meta property="og:description" content="阅读更多">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/Cpp-Language/virtual-method-table.jpeg">
<meta property="og:image" content="http://example.com/images/Cpp-Language/happens-before.png">
<meta property="article:published_time" content="2021-09-06T02:53:48.000Z">
<meta property="article:modified_time" content="2024-03-29T15:51:01.000Z">
<meta property="article:author" content="Liuyehcf">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Cpp-Language/virtual-method-table.jpeg">

<link rel="canonical" href="http://example.com/2021/09/06/Cpp-Language/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Cpp-Language | Liuye Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Liuye Notebook</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-explore">

    <a href="/explore/" rel="section"><i class="fa fa-sitemap fa-fw"></i>发现</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/06/Cpp-Language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Liuyehcf">
      <meta itemprop="description" content="大音希声，大象无形">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liuye Notebook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Cpp-Language
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-06 10:53:48" itemprop="dateCreated datePublished" datetime="2021-09-06T10:53:48+08:00">2021-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-29 23:51:01" itemprop="dateModified" datetime="2024-03-29T23:51:01+08:00">2024-03-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          
            <span id="/2021/09/06/Cpp-Language/" class="post-meta-item leancloud_visitors" data-flag-title="Cpp-Language" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/06/Cpp-Language/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/06/Cpp-Language/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>阅读更多</strong></p>
<span id="more"></span>
<h1 id="1-features"><a class="markdownIt-Anchor" href="#1-features"></a> 1 Features</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/AnthonyCalandra/modern-cpp-features">modern-cpp-features</a></p>
<h1 id="2-preprocessor-directives"><a class="markdownIt-Anchor" href="#2-preprocessor-directives"></a> 2 Preprocessor Directives</h1>
<h2 id="21-conditions"><a class="markdownIt-Anchor" href="#21-conditions"></a> 2.1 Conditions</h2>
<p>预处理器支持有条件地编译源文件的某些部分。这一行为由<code>#if</code>、<code>#else</code>、<code>#elif</code>、<code>#ifdef</code>、<code>#ifndef</code>与<code>#endif</code>指令所控制</p>
<h2 id="22-define"><a class="markdownIt-Anchor" href="#22-define"></a> 2.2 <code>#define</code></h2>
<p><strong><code>ANSI C</code>标准中有几个标准预定义宏（也是常用的）：</strong></p>
<ul>
<li><code>__LINE__</code>：在源代码中插入当前源代码行号</li>
<li><code>__FILE__</code>：在源文件中插入当前源文件名</li>
<li><code>__DATE__</code>：在源文件中插入当前的编译日期</li>
<li><code>__TIME__</code>：在源文件中插入当前编译时间</li>
<li><code>__STDC__</code>：当要求程序严格遵循<code>ANSI C</code>标准时该标识被赋值为1</li>
<li><code>__cplusplus</code>：当编写<code>C++</code>程序时该标识符被定义</li>
</ul>
<p><strong>语法：</strong></p>
<ul>
<li><code>#</code>：字符串化操作符</li>
<li><code>##</code>：连接操作符</li>
<li><code>\</code>：续行操作符</li>
</ul>
<h3 id="221-work-with-compiler"><a class="markdownIt-Anchor" href="#221-work-with-compiler"></a> 2.2.1 Work with compiler</h3>
<p>macros are preprocessor directives, and they get processed before the actual compilation phase. One of the most common preprocessor directives is <code>#define</code> which is used to define macros.</p>
<p>If you want to change a macro definition at compile time, there are several ways to do it:</p>
<p><strong>Using Compiler Flags</strong>: You can use the <code>-D</code> flag (for most compilers like GCC and Clang) to define macros.</p>
<ul>
<li>
<p>For example, suppose you have the following code:</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_MACRO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MACRO <span class="string">&quot;Default Value&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; MY_MACRO &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>You can change <code>MY_MACRO</code> at compile time as:</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ your_file.cpp -o output -DMY_MACRO=<span class="string">&#x27;&quot;Compile Time Value&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>When you run the output, it will print “Compile Time Value”.</p>
</li>
</ul>
<p><strong>Using Conditional Compilation:</strong> This is where you use <code>#ifdef</code>, <code>#ifndef</code>, <code>#else</code>, and <code>#endif</code> directives to conditionally compile parts of your code based on whether a certain macro is defined or not.</p>
<ul>
<li>
<p>Here’s an example:</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="comment">// code for debugging</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// regular code</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>You can then define or not define DEBUG using the -D flag at compile time:</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ your_file.cpp -o output -DDEBUG</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="222-tips"><a class="markdownIt-Anchor" href="#222-tips"></a> 2.2.2 Tips</h3>
<h4 id="2221-do-while0-in-macros"><a class="markdownIt-Anchor" href="#2221-do-while0-in-macros"></a> 2.2.2.1 do while(0) in macros</h4>
<p>考虑下面的宏定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(x) bar(x); baz(x)</span></span><br></pre></td></tr></table></figure>
<p>然后我们调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foo</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>会被展开为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bar</span>(wolf); <span class="built_in">baz</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>看起来没有问题，我们接着考虑另一个情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) </span><br><span class="line">    <span class="built_in">foo</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>会被展开为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) </span><br><span class="line">    <span class="built_in">bar</span>(wolf);</span><br><span class="line"><span class="built_in">baz</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>这并不符合我们的预期，为了避免出现这种问题，需要用一个作用域将宏包围起来，避免语句的作用域发生偏移，于是我们进一步将宏表示为如下形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(x) &#123; bar(x); baz(x); &#125;</span></span><br></pre></td></tr></table></figure>
<p>然后我们调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    <span class="built_in">foo</span>(wolf);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">bin</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>会被展开为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">bar</span>(wolf);</span><br><span class="line">    <span class="built_in">baz</span>(wolf);</span><br><span class="line">&#125;; <span class="comment">// syntax error</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">bin</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>最终，我们将宏优化成如下形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(x) do &#123; bar(x); baz(x); &#125; while (0)</span></span><br></pre></td></tr></table></figure>
<h4 id="2222-variant"><a class="markdownIt-Anchor" href="#2222-variant"></a> 2.2.2.2 Variant</h4>
<p>借助宏的嵌套，以及约定命名规则，我们可以实现自动生成<code>else if</code>分支，示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APPLY_FOR_PARTITION_VARIANT_ALL(M) \</span></span><br><span class="line"><span class="meta">    M(_int)                                \</span></span><br><span class="line"><span class="meta">    M(_long)                               \</span></span><br><span class="line"><span class="meta">    M(_double)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">HashMapVariantType</span> &#123; _int, _long, _double &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashMapVariant</span> &#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; _int;</span><br><span class="line">    std::map&lt;<span class="type">long</span>, <span class="type">long</span>&gt; _long;</span><br><span class="line">    std::map&lt;<span class="type">double</span>, <span class="type">double</span>&gt; _double;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HashMapVariant hash_map_variant;</span><br><span class="line">HashMapVariantType type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_int_map</span><span class="params">(std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; map)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;handle int map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_long_map</span><span class="params">(std::map&lt;<span class="type">long</span>, <span class="type">long</span>&gt;&amp; map)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;handle long map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_double_map</span><span class="params">(std::map&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&amp; map)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;handle double map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dispatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_MAP_METHOD(NAME)                      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> <span class="keyword">if</span> (type == HashMapVariantType::NAME) &#123;   \</span></span><br><span class="line"><span class="meta">        handle##NAME##_map(hash_map_variant.NAME); \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line">    <span class="built_in">APPLY_FOR_PARTITION_VARIANT_ALL</span>(HASH_MAP_METHOD)</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HASH_MAP_METHOD</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    type = HashMapVariantType::_int;</span><br><span class="line">    <span class="built_in">dispatch</span>();</span><br><span class="line">    type = HashMapVariantType::_long;</span><br><span class="line">    <span class="built_in">dispatch</span>();</span><br><span class="line">    type = HashMapVariantType::_double;</span><br><span class="line">    <span class="built_in">dispatch</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述功能完全可以由<code>std::variant</code>实现，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::variant&lt;std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::map&lt;<span class="type">long</span>, <span class="type">long</span>&gt;, std::map&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt; hash_map_variant;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; map)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;handle int map&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::map&lt;<span class="type">long</span>, <span class="type">long</span>&gt;&amp; map)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;handle long map&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::map&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&amp; map)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;handle double map&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lambda_visitor = [](<span class="keyword">auto</span>&amp; map) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(map)&gt;, std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;handle int map by lambda&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(map)&gt;, std::map&lt;<span class="type">long</span>, <span class="type">long</span>&gt;&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;handle long map by lambda&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(map)&gt;, std::map&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;handle double map by lambda&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Visitor visitor;</span><br><span class="line"></span><br><span class="line">    hash_map_variant = std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">    std::<span class="built_in">visit</span>(visitor, hash_map_variant);</span><br><span class="line">    std::<span class="built_in">visit</span>(lambda_visitor, hash_map_variant);</span><br><span class="line"></span><br><span class="line">    hash_map_variant = std::map&lt;<span class="type">long</span>, <span class="type">long</span>&gt;&#123;&#125;;</span><br><span class="line">    std::<span class="built_in">visit</span>(visitor, hash_map_variant);</span><br><span class="line">    std::<span class="built_in">visit</span>(lambda_visitor, hash_map_variant);</span><br><span class="line"></span><br><span class="line">    hash_map_variant = std::map&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&#123;&#125;;</span><br><span class="line">    std::<span class="built_in">visit</span>(visitor, hash_map_variant);</span><br><span class="line">    std::<span class="built_in">visit</span>(lambda_visitor, hash_map_variant);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2223-comma-problem"><a class="markdownIt-Anchor" href="#2223-comma-problem"></a> 2.2.2.3 Comma Problem</h4>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4496842/pass-method-with-template-arguments-to-a-macro">pass method with template arguments to a macro</a></p>
<p>示例如下，我们定义了一个参数的宏<code>MY_MACRO</code>：</p>
<ul>
<li><code>MY_MACRO(func&lt;flag1, flag2&gt;())</code>：这个调用会报错，因为逗号会被认为用于分隔两个宏参数</li>
<li><code>MY_MACRO((func&lt;flag1, flag2&gt;()))</code>：这个调用正常，因为用<code>()</code>将表达式包围后，会被认为是一个宏参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MACRO(stmt) \</span></span><br><span class="line"><span class="meta">    do &#123;               \</span></span><br><span class="line"><span class="meta">        &#123; stmt; &#125;      \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> flag1, <span class="type">bool</span> flag2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> flag1, <span class="type">bool</span> flag2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MY_MACRO(func&lt;flag1, flag2&gt;());</span></span><br><span class="line">    <span class="built_in">MY_MACRO</span>((<span class="built_in">func</span>&lt;flag1, flag2&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">call_func</span>&lt;<span class="literal">true</span>, <span class="literal">true</span>&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="23-variadic-macros"><a class="markdownIt-Anchor" href="#23-variadic-macros"></a> 2.3 Variadic Macros</h2>
<p>宏也支持可变参数，通过<code>__VA_ARGS__</code>引用这些参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW_SUM_UP(...) std::cout &lt;&lt; sum(__VA_ARGS__) &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nums[] = &#123;args...&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>...(args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SHOW_SUM_UP</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="24-pragma"><a class="markdownIt-Anchor" href="#24-pragma"></a> 2.4 <code>#pragma</code></h2>
<p>在<code>C++</code>中，<code>#pragma</code>是一个预处理器指令（<code>preprocessor directive</code>），它用于向编译器发出一些特定的命令或提示，从而控制编译器的行为。<code>#pragma</code>通常用于开启或关闭某些编译器的特性、设置编译器选项、指定链接库等</p>
<p><code>#pragma</code>指令不是<code>C++</code>的标准特性，而是编译器提供的扩展。不同的编译器可能支持不同的<code>#pragma</code>指令，而且它们的行为也可能不同。因此在编写可移植的<code>C++</code>代码时应尽量避免使用它们</p>
<p>不同的编译器可能支持不同的<code>#pragma</code>指令，以下是一些常用的<code>#pragma</code>指令及其作用</p>
<ul>
<li>
<p><code>#pragma once</code>：该指令用于避免头文件被多次包含，以解决头文件重复包含的问题。它告诉编译器只包含一次该头文件</p>
</li>
<li>
<p><code>#pragma pack</code>：该<code>pragma</code>族控制后继定义的结构体、联合体、类的最大对齐</p>
<ul>
<li><code>#pragma pack(&lt;arg&gt;)</code>：设置当前对齐为值<code>&lt;arg&gt;</code></li>
<li><code>#pragma pack()</code>：设置当前对齐为默认值（由命令行选项指定）</li>
<li><code>#pragma pack(push)</code>：推入当前对齐的值到内部栈</li>
<li><code>#pragma pack(push, &lt;arg&gt;)</code>：推入当前对齐的值到内部栈然后设置当前对齐为值<code>&lt;arg&gt;</code></li>
<li><code>#pragma pack(pop)</code>：从内部栈弹出顶条目然后设置（恢复）当前对齐为该值</li>
<li>其中<code>&lt;arg&gt;</code>实参是小的<code>2</code>的幂，指定以字节计的新对齐</li>
</ul>
</li>
<li>
<p><code>#pragma message</code>：该指令用于在编译时输出一条消息</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> message(<span class="string">&quot;Compiling &quot;</span> __FILE__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>#pragma GCC diagnostic</code>：该指令用于控制编译器的警告和错误信息。可以用它来控制特定的警告或错误信息是否应该被忽略或显示</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">something</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic ignored <span class="string">&quot;-Wunused-result&quot;</span></span></span><br><span class="line">    <span class="built_in">something</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>#pragma omp</code>：该指令用于<code>OpenMP</code>并行编程，用于指定并行执行的方式</p>
</li>
</ul>
<h2 id="25-error"><a class="markdownIt-Anchor" href="#25-error"></a> 2.5 <code>#error</code></h2>
<p>显示给定的错误消息，并终止编译过程</p>
<h2 id="26-参考"><a class="markdownIt-Anchor" href="#26-参考"></a> 2.6 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://bot-man-jl.github.io/articles/?post=2020/Macro-Programming-Art">C/C++ 宏编程的艺术</a></li>
</ul>
<h1 id="3-key-word"><a class="markdownIt-Anchor" href="#3-key-word"></a> 3 Key Word</h1>
<h2 id="31-type-qualifier"><a class="markdownIt-Anchor" href="#31-type-qualifier"></a> 3.1 Type Qualifier</h2>
<h3 id="311-const"><a class="markdownIt-Anchor" href="#311-const"></a> 3.1.1 const</h3>
<p>默认状态下，<code>const</code>对象仅在文件内有效。编译器将在编译过程中把用到该变量的地方都替代成对应的值，也就是说，编译器会找到代码中所有用到该<code>const</code>变量的地方，然后将其替换成定义的值</p>
<p>为了执行上述替换，编译器必须知道变量的初始值，如果程序包含多个文件，则每个用了<code>const</code>对象的文件都必须能访问到它的初始值才行。要做到这一点，就必须在每一个用到该变量的文件中都对它有定义（将定义该<code>const</code>变量的语句放在头文件中，然后用到该变量的源文件包含头文件即可），为了支持这一用法，同时避免对同一变量的重复定义，默认情况下<code>const</code>被设定为尽在文件内有效（<code>const</code>的全局变量，其实只是在每个文件中都定义了一边而已）</p>
<p>有时候出现这样的情况：<code>const</code>变量的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件生成独立的变量，相反，我们想让这类<code>const</code>对象像其他对象一样工作。<strong>即：在一个文件中定义<code>const</code>，在多个文件中声明并使用它，无论声明还是定 义都添加<code>extern</code>关键字</strong></p>
<ul>
<li><code>.h</code>文件中：<code>extern const int a;</code></li>
<li><code>.cpp</code>文件中：<code>extern const int a=f();</code></li>
</ul>
<h4 id="3111-topbottom-level-const"><a class="markdownIt-Anchor" href="#3111-topbottom-level-const"></a> 3.1.1.1 Top/Bottom Level const</h4>
<p><strong>只有指针和引用才有顶层底层之分</strong></p>
<ul>
<li>顶层<code>const</code>属性表示对象本身不可变</li>
<li>底层<code>const</code>属性表示指向的对象不可变</li>
<li>引用的<code>const</code>属性只能是底层。因为引用本身不是对象，没法指定顶层的<code>const</code>属性</li>
<li>指针的<code>const</code>属性既可以是顶层又可以是底层
<ul>
<li>注意，只有<code>const</code>与<code>变量名</code>相邻时（中间不能有<code>*</code>），才算顶层<code>const</code>。例如下面例子中的<code>p1</code>和<code>p2</code>都是顶层<code>const</code></li>
</ul>
</li>
<li>指针的底层<code>const</code>是可以重新绑定的，例如下面例子中的<code>p1</code>和<code>p2</code></li>
<li>引用的底层<code>const</code>是无法重新绑定的，这是因为引用本身就不支持重新绑定，而非<code>const</code>的限制</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bottom level const</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* p1 = &amp;a;</span><br><span class="line">    p1 = &amp;c;</span><br><span class="line">    <span class="comment">// *p1 += 1; // compile error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// bottom level const</span></span><br><span class="line">    <span class="type">int</span> <span class="type">const</span>* p2 = &amp;b;</span><br><span class="line">    p2 = &amp;c;</span><br><span class="line">    <span class="comment">// *p2 += 1; // compile error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// top level const</span></span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> p3 = &amp;c;</span><br><span class="line">    <span class="comment">// p3 = &amp;a; // compile error</span></span><br><span class="line">    *p3 += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; r1 = a;</span><br><span class="line">    <span class="comment">// r1 = b; // compile error</span></span><br><span class="line">    <span class="comment">// r1 += 1; // compile error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>const</code>遵循如下规则：</strong></p>
<ul>
<li>顶层<code>const</code>可以访问<code>const</code>和非<code>const</code>的成员</li>
<li>底层<code>const</code>只能访问<code>const</code>的成员</li>
</ul>
<p>示例如下，可以发现：</p>
<ul>
<li><code>const Container* container</code>以及<code>const Container&amp; container</code>都只能访问<code>const</code>成员，而无法访问非<code>const</code>成员</li>
<li><code>Container* const container</code>可以访问<code>const</code>成员以及非<code>const</code>成员</li>
<li>特别地，<code>const ContainerPtr&amp; container</code>可以访问非<code>const</code>成员，这是因为<code>container-&gt;push_back(num)</code>是一个两级调用
<ul>
<li>第一级：访问的是<code>std::shared_ptr::operator-&gt;</code>运算符，该运算符是<code>const</code>的，且返回类型为<code>element_type*</code></li>
<li>第二级：通过返回的<code>element_type*</code>访问<code>std::vector::push_back</code>，因此与上述结论并不矛盾</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Container = std::vector&lt;<span class="type">int32_t</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> ContainerPtr = std::shared_ptr&lt;Container&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append_by_const_reference_shared_ptr</span><span class="params">(<span class="type">const</span> ContainerPtr&amp; container, <span class="type">const</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// can calling non-const member function</span></span><br><span class="line">    container-&gt;<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append_by_const_reference</span><span class="params">(<span class="type">const</span> Container&amp; container, <span class="type">const</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cannot calling non-const member function</span></span><br><span class="line">    <span class="comment">// container.push_back(num);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append_by_bottom_const_pointer</span><span class="params">(<span class="type">const</span> Container* container, <span class="type">const</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cannot calling non-const member function</span></span><br><span class="line">    <span class="comment">// container-&gt;push_back(num);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append_by_top_const_pointer</span><span class="params">(Container* <span class="type">const</span> container, <span class="type">const</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// can calling non-const member function</span></span><br><span class="line">    container-&gt;<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3112-const-actual-and-formal-parameters"><a class="markdownIt-Anchor" href="#3112-const-actual-and-formal-parameters"></a> 3.1.1.2 const Actual and Formal Parameters</h4>
<p>实参初始化形参时会自动忽略掉顶层<code>const</code>属性</p>
<p>顶层<code>const</code>不影响形参的类型，例如下面的代码，编译会失败，错误信息是函数重定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> value)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3113-const-member"><a class="markdownIt-Anchor" href="#3113-const-member"></a> 3.1.1.3 const Member</h4>
<p>构造函数中显式初始化：在初始化部分进行初始化，而不能在函数体内初始化；如果没有显式初始化，就调用定义时的初始值进行初始化</p>
<h4 id="3114-const-member-function"><a class="markdownIt-Anchor" href="#3114-const-member-function"></a> 3.1.1.4 const Member Function</h4>
<p><strong><code>const</code>关键字修饰的成员函数，不能修改当前类的任何字段的值，如果字段是对象类型，也不能调用非<code>const</code>修饰的成员方法。（有一个特例，就是当持有的是某个类型的指针时，可以通过该指针调用非<code>const</code>方法）</strong></p>
<p>常量对象以及常量对象的引用或指针都只能调用常量成员函数</p>
<p>常量对象以及常量对象的引用或指针都可以调用常量成员函数以及非常量成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello1</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello world, const version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello world, non const version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Demo d;</span><br><span class="line">    d.<span class="built_in">sayHello1</span>();</span><br><span class="line">    d.<span class="built_in">sayHello2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Demo cd;</span><br><span class="line">    cd.<span class="built_in">sayHello1</span>();</span><br><span class="line">    <span class="comment">// the following statement will lead to compile error</span></span><br><span class="line">    <span class="comment">// cd.sayHello2();</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="312-volatile"><a class="markdownIt-Anchor" href="#312-volatile"></a> 3.1.2 volatile</h3>
<p><code>volatile</code>关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改（程序之外的因素），比如：操作系统、硬件等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问</p>
<ul>
<li><strong>仅从<code>C/C++</code>标准的角度来说（不考虑平台以及编译器扩展），<code>volatile</code>并不保证线程间的可见性</strong>。在实际场景中，例如<code>x86</code>平台，在<code>MESI</code>协议的支持下，<code>volatile</code>是可以保证可见性的，这可以理解为一个巧合，利用了平台相关性，因此不具备平台可移植性</li>
</ul>
<p><code>Java</code>中也有<code>volatile</code>关键字，但作用完全不同，<code>Java</code>在语言层面就保证了<code>volatile</code>具有线程可见性</p>
<ul>
<li><code>x86</code>
<ul>
<li>仅依赖<code>MESI</code>协议，可能也无法实现可见性。举个例子，当<code>CPU1</code>执行写操作时，要等到其他<code>CPU</code>将对应的缓存行设置成<code>I</code>状态后，写入才能完成，性能较差，于是<code>CPU</code>又引入了<code>Store Buffer</code>（<code>MESI</code>协议不感知<code>Store Buffer</code>），<code>CPU1</code>只需要将数据写入<code>Store Buffer</code>而不用等待其他<code>CPU</code>将缓存行设置成<code>I</code>状态就可以干其他事了</li>
<li>为了解决上述问题，<code>JVM</code>使用了<code>lock</code>前缀的汇编指令，将当前<code>Store Buffer</code>中的所有数据（不仅仅是<code>volatile</code>修饰的变量）都通过<code>MESI</code>写入</li>
</ul>
</li>
<li>其他架构，采用其他方式来保证线程可见性这一承诺</li>
</ul>
<p><strong>参考：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://isocpp.org/blog/2018/06/is-volatile-useful-with-threads-isvolatileusefulwiththreads.com">Is volatile useful with threads?</a>
<ul>
<li><a target="_blank" rel="noopener" href="http://isvolatileusefulwiththreads.com/">isvolatileusefulwiththreads</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18695120/volatile-and-cache-behaviour">Volatile and cache behaviour</a></li>
<li><a target="_blank" rel="noopener" href="https://www.hitzhangjie.pro/blog/2019-01-07-%E4%BD%A0%E4%B8%8D%E8%AE%A4%E8%AF%86%E7%9A%84cc++-volatile/">你不认识的cc++ volatile</a></li>
</ul>
<p><strong>示例如下：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; volatile.cpp &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#include &lt;atomic&gt;</span></span><br><span class="line"></span><br><span class="line">void read_from_normal(int32_t&amp; src, int32_t&amp; target) &#123;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void read_from_volatile(volatile int32_t&amp; src, int32_t&amp; target) &#123;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void read_from_atomic(std::atomic&lt;int32_t&gt;&amp; src, int32_t&amp; target) &#123;</span><br><span class="line">    target = src.load(std::memory_order_seq_cst);</span><br><span class="line">    target = src.load(std::memory_order_relaxed);</span><br><span class="line">    target = src.load(std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write_to_normal(int32_t&amp; src, int32_t&amp; target) &#123;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write_to_volatile(int32_t&amp; src, volatile int32_t&amp; target) &#123;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write_to_atomic(int32_t&amp; src, std::atomic&lt;int32_t&gt;&amp; target) &#123;</span><br><span class="line">    target.store(src, std::memory_order_seq_cst);</span><br><span class="line">    target.store(src, std::memory_order_relaxed);</span><br><span class="line">    target.store(src, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">gcc -o volatile.o -c volatile.cpp -O3 -lstdc++ -std=gnu++17</span><br><span class="line">objdump -drwCS volatile.o</span><br></pre></td></tr></table></figure>
<p><strong>输出如下：</strong></p>
<ul>
<li><code>read_from_normal</code>的三次操作被优化成了一次</li>
<li><code>write_to_normal</code>的三次操作被优化成了一次</li>
<li><code>write_to_atomic</code>中，<code>std::memory_order_seq_cst</code>使用的是<a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/xchg"><code>xchg</code>指令</a>，当有一个操作数是内存地址时，会自动启用<code>locking protocol</code>，确保写操作的串行化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">volatile.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;read_from_normal(int&amp;, int&amp;)&gt;:</span><br><span class="line">   0:	f3 0f 1e fa          	endbr64</span><br><span class="line">   4:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">   6:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">   8:	c3                   	ret</span><br><span class="line">   9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000000010 &lt;read_from_volatile(int volatile&amp;, int&amp;)&gt;:</span><br><span class="line">  10:	f3 0f 1e fa          	endbr64</span><br><span class="line">  14:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  16:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  18:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  1a:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  1c:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  1e:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  20:	c3                   	ret</span><br><span class="line">  21:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 cs nopw 0x0(%rax,%rax,1)</span><br><span class="line">  2c:	0f 1f 40 00          	nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000000030 &lt;read_from_atomic(std::atomic&lt;int&gt;&amp;, int&amp;)&gt;:</span><br><span class="line">  30:	f3 0f 1e fa          	endbr64</span><br><span class="line">  34:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  36:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  38:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  3a:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  3c:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  3e:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  40:	c3                   	ret</span><br><span class="line">  41:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 cs nopw 0x0(%rax,%rax,1)</span><br><span class="line">  4c:	0f 1f 40 00          	nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000000050 &lt;write_to_normal(int&amp;, int&amp;)&gt;:</span><br><span class="line">  50:	f3 0f 1e fa          	endbr64</span><br><span class="line">  54:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  56:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  58:	c3                   	ret</span><br><span class="line">  59:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000000060 &lt;write_to_volatile(int&amp;, int volatile&amp;)&gt;:</span><br><span class="line">  60:	f3 0f 1e fa          	endbr64</span><br><span class="line">  64:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  66:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  68:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  6a:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  6c:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  6e:	c3                   	ret</span><br><span class="line">  6f:	90                   	nop</span><br><span class="line"></span><br><span class="line">0000000000000070 &lt;write_to_atomic(int&amp;, std::atomic&lt;int&gt;&amp;)&gt;:</span><br><span class="line">  70:	f3 0f 1e fa          	endbr64</span><br><span class="line">  74:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  76:	87 06                	xchg   %eax,(%rsi)</span><br><span class="line">  78:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  7a:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  7c:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  7e:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  80:	c3                   	ret</span><br></pre></td></tr></table></figure>
<h4 id="3121-visibility-verification"><a class="markdownIt-Anchor" href="#3121-visibility-verification"></a> 3.1.2.1 Visibility Verification</h4>
<p>首先明确一下<code>visibility</code>的概念，这里我对它的定义是：当<code>A</code>和<code>B</code>两个线程，<code>A</code>对变量<code>x</code>进行写操作，<code>B</code>对变量<code>x</code>进行读操作，若时间上写操作先发生于读操作时，读操作能够读取到写操作写入的值</p>
<p>这个问题比较难直接验证，我们打算用一种间接的方式来验证：</p>
<ul>
<li>假设读操作和写操作的性能开销之比为<code>α</code></li>
<li>开两个线程，分别循环执行读操作和写操作，读执行<code>n</code>次（期间持续进行写操作）。统计读线程，相邻两次读操作，读取数值不同的次数为<code>m</code>，<code>β=m/n</code>。
<ul>
<li>若<code>α &gt; 1</code>，即读比写更高效。如果满足可见性，那么<code>β</code>应该大致接近<code>1/α</code></li>
<li>若<code>α &lt;= 1</code>，即读比写更低效。如果满足可见性，那么<code>β</code>应该接近1（写的值大概率被看见）</li>
</ul>
</li>
</ul>
<p>首先，测试<code>atomic</code>与<code>volatile</code>的读写性能</p>
<ul>
<li>测试时，会有一个额外的线程对<code>atomic</code>或<code>volatile</code>变量进行持续的读写操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;benchmark/benchmark.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">uint64_t</span>&gt; atomic_value&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">uint64_t</span> <span class="keyword">volatile</span> volatile_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> RAND_ROUND_SIZE = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">volatile_random_write</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint64_t</span>&amp; value, std::atomic&lt;<span class="type">bool</span>&gt;&amp; stop)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stop.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; RAND_ROUND_SIZE; i++) &#123;</span><br><span class="line">            value = tmp;</span><br><span class="line">            tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">volatile_random_read</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint64_t</span>&amp; value, std::atomic&lt;<span class="type">bool</span>&gt;&amp; stop)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (!stop.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; RAND_ROUND_SIZE; i++) &#123;</span><br><span class="line">            tmp = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    benchmark::<span class="built_in">DoNotOptimize</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order order&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">atomic_random_write</span><span class="params">(std::atomic&lt;<span class="type">uint64_t</span>&gt;&amp; value, std::atomic&lt;<span class="type">bool</span>&gt;&amp; stop)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stop.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; RAND_ROUND_SIZE; i++) &#123;</span><br><span class="line">            value.<span class="built_in">store</span>(tmp, order);</span><br><span class="line">            tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order order&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">atomic_random_read</span><span class="params">(std::atomic&lt;<span class="type">uint64_t</span>&gt;&amp; value, std::atomic&lt;<span class="type">bool</span>&gt;&amp; stop)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (!stop.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; RAND_ROUND_SIZE; i++) &#123;</span><br><span class="line">            tmp = value.<span class="built_in">load</span>(order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    benchmark::<span class="built_in">DoNotOptimize</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order order&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">atomic_read</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> tmp = <span class="number">0</span>;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;]() &#123; atomic_random_write&lt;order&gt;(atomic_value, stop); &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        tmp = atomic_value.<span class="built_in">load</span>(order);</span><br><span class="line">    &#125;</span><br><span class="line">    benchmark::<span class="built_in">DoNotOptimize</span>(tmp);</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order order&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">atomic_write</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> tmp = <span class="number">0</span>;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;]() &#123; atomic_random_read&lt;order&gt;(atomic_value, stop); &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        atomic_value.<span class="built_in">store</span>(tmp, order);</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">volatile_read</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> tmp = <span class="number">0</span>;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;]() &#123; volatile_random_write(volatile_value, stop); &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        tmp = volatile_value;</span><br><span class="line">    &#125;</span><br><span class="line">    benchmark::<span class="built_in">DoNotOptimize</span>(tmp);</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">volatile_write</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> tmp = <span class="number">0</span>;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;]() &#123; volatile_random_read(volatile_value, stop); &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        volatile_value = tmp;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BENCHMARK</span>(atomic_read&lt;std::memory_order_seq_cst&gt;);</span><br><span class="line"><span class="built_in">BENCHMARK</span>(atomic_write&lt;std::memory_order_seq_cst&gt;);</span><br><span class="line"><span class="built_in">BENCHMARK</span>(atomic_read&lt;std::memory_order_relaxed&gt;);</span><br><span class="line"><span class="built_in">BENCHMARK</span>(atomic_write&lt;std::memory_order_relaxed&gt;);</span><br><span class="line"><span class="built_in">BENCHMARK</span>(volatile_read);</span><br><span class="line"><span class="built_in">BENCHMARK</span>(volatile_write);</span><br><span class="line"></span><br><span class="line"><span class="built_in">BENCHMARK_MAIN</span>();</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<ul>
<li>对于<code>atomic&lt;uint64_t&gt;, std::memory_order_seq_cst</code>
<ul>
<li><code>α = 28.9/1.24 = 23.30 &gt; 1</code></li>
<li><code>β</code>的预期值为<code>1/α = 0.043</code></li>
</ul>
</li>
<li>对于<code>atomic&lt;uint64_t&gt;, std::memory_order_relaxed</code>
<ul>
<li><code>α = 0.391/1.38 = 0.28 &lt; 1</code></li>
<li><code>β</code>的预期值为<code>1</code></li>
</ul>
</li>
<li>对于<code>volatile</code>
<ul>
<li><code>α = 0.331/1.33 = 0.25 &lt; 1</code></li>
<li><code>β</code>的预期值为<code>1</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">Benchmark                                        Time             CPU   Iterations</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">atomic_read&lt;std::memory_order_seq_cst&gt;        1.24 ns         1.24 ns    577159059</span><br><span class="line">atomic_write&lt;std::memory_order_seq_cst&gt;       28.9 ns         28.9 ns     23973114</span><br><span class="line">atomic_read&lt;std::memory_order_relaxed&gt;        1.38 ns         1.38 ns    595494132</span><br><span class="line">atomic_write&lt;std::memory_order_relaxed&gt;      0.391 ns        0.391 ns   1000000000</span><br><span class="line">volatile_read                                 1.33 ns         1.33 ns    551154517</span><br><span class="line">volatile_write                               0.331 ns        0.331 ns   1000000000</span><br></pre></td></tr></table></figure>
<p>同一个环境，测试程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint64_t</span> SIZE = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_volatile</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint64_t</span>&amp; value, <span class="type">const</span> std::string&amp; description)</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">write_thread</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!stop.load(std::memory_order_relaxed)) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                value = i;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">read_thread</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> prev_value = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> non_diff_cnt = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> diff_cnt = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> cur_value;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            cur_value = value;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// These two statements have little overhead which can be ignored if enable -03</span></span></span></span><br><span class="line"><span class="params"><span class="function">            cur_value == prev_value ? non_diff_cnt++ : diff_cnt++;</span></span></span><br><span class="line"><span class="params"><span class="function">            prev_value = cur_value;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; description &lt;&lt; <span class="string">&quot;, β=&quot;</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="type">double</span>&gt;(diff_cnt) / SIZE &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    read_thread.<span class="built_in">join</span>();</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    write_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order order&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_atomic</span><span class="params">(std::atomic&lt;<span class="type">uint64_t</span>&gt;&amp; value, <span class="type">const</span> std::string&amp; description)</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">write_thread</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!stop.load(std::memory_order_relaxed)) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                value.store(i, order);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">read_thread</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> prev_value = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> non_diff_cnt = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> diff_cnt = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> cur_value;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            cur_value = value.load(order);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// These two statements have little overhead which can be ignored if enable -03</span></span></span></span><br><span class="line"><span class="params"><span class="function">            cur_value == prev_value ? non_diff_cnt++ : diff_cnt++;</span></span></span><br><span class="line"><span class="params"><span class="function">            prev_value = cur_value;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; description &lt;&lt; <span class="string">&quot;, β=&quot;</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="type">double</span>&gt;(diff_cnt) / SIZE &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    read_thread.<span class="built_in">join</span>();</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    write_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::atomic&lt;<span class="type">uint64_t</span>&gt; value = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">test_atomic</span>&lt;std::memory_order_seq_cst&gt;(value, <span class="string">&quot;atomic&lt;uint64_t&gt;, std::memory_order_seq_cst&quot;</span>);</span><br><span class="line">        <span class="built_in">test_atomic</span>&lt;std::memory_order_relaxed&gt;(value, <span class="string">&quot;atomic&lt;uint64_t&gt;, std::memory_order_relaxed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint64_t</span> <span class="keyword">volatile</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">test_volatile</span>(value, <span class="string">&quot;volatile&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下（<code>volatile</code>以及<code>std::memory_order_relaxed</code>的行为是平台相关的，测试环境是x86，实验结果不具备平台扩展性）：</p>
<ul>
<li><code>std::memory_order_seq_cst</code>符合预期</li>
<li><code>std::memory_order_relaxed</code>、<code>volatile</code>都不符合预期。这两者都不具备<code>visibility</code></li>
<li>导致这一现象的原因，我的猜想如下：
<ul>
<li>x86会用到一种硬件优化，<code>Store Buffer</code>用于加速写操作</li>
<li><code>std::memory_order_seq_cst</code>的写操作，会立即将<code>Store Buffer</code>刷入内存</li>
<li><code>std::memory_order_relaxed</code>、<code>volatile</code>的写操作，会写入<code>Store Buffer</code>，当容量满了之后，刷入内存</li>
<li>将<code>Store Buffer</code>填充满所需的时间很短。于是上述代码等价于<code>std::memory_order_seq_cst</code>每次写操作写一次内存，<code>std::memory_order_relaxed</code>、<code>volatile</code>的一批写操作写一次内存。写内存的频率接近。于是这三种情况下，<code>β</code>相近</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;uint64_t&gt;, std::memory_order_seq_cst, β=0.0283726</span><br><span class="line">atomic&lt;uint64_t&gt;, std::memory_order_relaxed, β=0.0276697</span><br><span class="line">volatile, β=0.0271394</span><br></pre></td></tr></table></figure>
<p><strong>如果用Java进行上述等价验证，会发现实际结果与预期吻合，这里不再赘述</strong></p>
<h4 id="3122-atomicity-verification"><a class="markdownIt-Anchor" href="#3122-atomicity-verification"></a> 3.1.2.2 Atomicity Verification</h4>
<p><code>std::atomic</code>可以为其他非原子变量提供<code>happens-before</code>关系</p>
<ul>
<li><code>normal-write happens-before atomic-write</code></li>
<li><code>atomic-write happens-before atomic-read</code></li>
<li><code>atomic-read happens-before normal-read</code></li>
<li>推导出<code>normal-write happens-before normal-read</code></li>
</ul>
<p>此外，由于测试机器是x86的，x86是<code>TSO</code>模型，<code>std::memory_order_relaxed</code>同样满足<code>atomic-write happens-before atomic-read</code>规则，只不过生成的指令更接近<code>volatile</code>，因此这里使用<code>std::memory_order_relaxed</code>，便于对比两者指令的差异</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> INVALID_VALUE = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> EXPECTED_VALUE = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> TIMES = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> data;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">atomic_data_ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="type">bool</span> <span class="title">volatile_data_ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!atomic_data_ready.<span class="built_in">load</span>(std::memory_order_relaxed))</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(data == EXPECTED_VALUE);</span><br><span class="line"></span><br><span class="line">        data = INVALID_VALUE;</span><br><span class="line">        atomic_data_ready.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (atomic_data_ready.<span class="built_in">load</span>(std::memory_order_relaxed))</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">        data = EXPECTED_VALUE;</span><br><span class="line"></span><br><span class="line">        atomic_data_ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_atomic_visibility</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data = INVALID_VALUE;</span><br><span class="line">    atomic_data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(atomic_reader)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(atomic_writer)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">volatile_reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!volatile_data_ready)</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(data == EXPECTED_VALUE);</span><br><span class="line"></span><br><span class="line">        data = INVALID_VALUE;</span><br><span class="line">        volatile_data_ready = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">volatile_writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (volatile_data_ready)</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">        data = EXPECTED_VALUE;</span><br><span class="line"></span><br><span class="line">        volatile_data_ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_volatile_visibility</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data = INVALID_VALUE;</span><br><span class="line">    volatile_data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(volatile_reader)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(volatile_writer)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_atomic_visibility</span>();</span><br><span class="line">    <span class="built_in">test_volatile_visibility</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以<code>-O3</code>优化级别进行编译，查看其汇编指令，可以发现：</p>
<ul>
<li><code>volatile_writer</code>中，<code>data</code>的赋值被优化到了循环外，<code>volatile_data_ready</code>每次循环都会进行一次赋值（这种优化破坏了程序的本意）</li>
<li><code>atomic_writer</code>中，由于内存屏障的存在（<code>std::atomic</code>的写操作），<code>data</code>的赋值并未被优化到循环外。<code>data</code>和<code>atomic_data_ready</code>每次循环都会被赋值（符合程序本意）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">00000000000013c0 &lt;volatile_writer()&gt;:</span><br><span class="line">    13c0:	f3 0f 1e fa          	endbr64</span><br><span class="line">    13c4:	ba 40 42 0f 00       	mov    $0xf4240,%edx</span><br><span class="line">    13c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)</span><br><span class="line">    13d0:	0f b6 05 45 2c 00 00 	movzbl 0x2c45(%rip),%eax        # 401c &lt;volatile_data_ready&gt;</span><br><span class="line">    13d7:	84 c0                	test   %al,%al</span><br><span class="line">    13d9:	75 f5                	jne    13d0 &lt;volatile_writer()+0x10&gt;</span><br><span class="line">    13db:	c6 05 3a 2c 00 00 01 	movb   $0x1,0x2c3a(%rip)        # 401c &lt;volatile_data_ready&gt;</span><br><span class="line">    13e2:	83 ea 01             	sub    $0x1,%edx</span><br><span class="line">    13e5:	75 e9                	jne    13d0 &lt;volatile_writer()+0x10&gt;</span><br><span class="line">    13e7:	c7 05 2f 2c 00 00 63 00 00 00 	movl   $0x63,0x2c2f(%rip)        # 4020 &lt;data&gt;</span><br><span class="line">    13f1:	c6 05 24 2c 00 00 01 	movb   $0x1,0x2c24(%rip)        # 401c &lt;volatile_data_ready&gt;</span><br><span class="line">    13f8:	c3                   	ret</span><br><span class="line">    13f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000001400 &lt;atomic_writer()&gt;:</span><br><span class="line">    1400:	f3 0f 1e fa          	endbr64</span><br><span class="line">    1404:	ba 40 42 0f 00       	mov    $0xf4240,%edx</span><br><span class="line">    1409:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)</span><br><span class="line">    1410:	0f b6 05 06 2c 00 00 	movzbl 0x2c06(%rip),%eax        # 401d &lt;atomic_data_ready&gt;</span><br><span class="line">    1417:	84 c0                	test   %al,%al</span><br><span class="line">    1419:	75 f5                	jne    1410 &lt;atomic_writer()+0x10&gt;</span><br><span class="line">    141b:	c7 05 fb 2b 00 00 63 00 00 00 	movl   $0x63,0x2bfb(%rip)        # 4020 &lt;data&gt;</span><br><span class="line">    1425:	c6 05 f1 2b 00 00 01 	movb   $0x1,0x2bf1(%rip)        # 401d &lt;atomic_data_ready&gt;</span><br><span class="line">    142c:	83 ea 01             	sub    $0x1,%edx</span><br><span class="line">    142f:	75 df                	jne    1410 &lt;atomic_writer()+0x10&gt;</span><br><span class="line">    1431:	c3                   	ret</span><br><span class="line">    1432:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 cs nopw 0x0(%rax,%rax,1)</span><br><span class="line">    143d:	0f 1f 00             	nopl   (%rax)</span><br></pre></td></tr></table></figure>
<p>如果以<code>-O0</code>优化级别进行编译，则上述程序中的断言不会报错</p>
<h3 id="313-mutable"><a class="markdownIt-Anchor" href="#313-mutable"></a> 3.1.3 mutable</h3>
<p>容许常量类类型对象修改相应类成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int32_t</span> data)</span> <span class="type">const</span> </span>&#123; <span class="keyword">this</span>-&gt;data = data; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int32_t</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="32-other-specifiers"><a class="markdownIt-Anchor" href="#32-other-specifiers"></a> 3.2 Other Specifiers</h2>
<h3 id="321-inline"><a class="markdownIt-Anchor" href="#321-inline"></a> 3.2.1 inline</h3>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/keyword/inline">C++ 关键词：inline</a></p>
<ul>
<li>在用于函数的声明说明符序列时，将函数声明为一个内联函数
<ul>
<li>整个定义都在<code>class/struct/union</code>的定义内且被附着到全局模块（C++20 起）的函数是隐式的内联函数，无论它是成员函数还是非成员<code>friend</code>函数</li>
<li><code>inline</code>关键词的本意是作为给优化器的指示器，以指示优先采用函数的内联替换而非进行函数调用，即并不执行将控制转移到函数体内的函数调用CPU指令，而是代之以执行函数体的一份副本而无需生成调用。这会避免函数调用的开销（传递实参及返回结果），但它可能导致更大的可执行文件，因为函数体必须被复制多次</li>
<li>因为关键词<code>inline</code>的含义是非强制的，编译器拥有对任何未标记为<code>inline</code>的函数使用内联替换的自由，和对任何标记为<code>inline</code>的函数生成函数调用的自由。这些优化选择不改变上述关于多个定义和共享静态变量的规则</li>
<li>声明有<code>constexpr</code>的函数是隐式的内联函数</li>
</ul>
</li>
<li>在用于具有静态存储期的变量（静态类成员或命名空间作用域变量）的声明说明符序列时，将变量声明为内联变量
<ul>
<li>声明为<code>constexpr</code>的静态成员变量（但不是命名空间作用域变量）是隐式的内联变量</li>
</ul>
</li>
</ul>
<h2 id="33-type-length"><a class="markdownIt-Anchor" href="#33-type-length"></a> 3.3 Type Length</h2>
<h3 id="331-memory-alignment"><a class="markdownIt-Anchor" href="#331-memory-alignment"></a> 3.3.1 Memory Alignment</h3>
<p><strong>内存对齐最最底层的原因是内存的IO是以<code>8</code>个字节<code>64bit</code>为单位进行的</strong></p>
<p>假如你指定要获取的是<code>0x0001-0x0008</code>，也是8字节，但是不是0开头的，内存需要怎么工作呢？没有好办法，内存只好先工作一次把<code>0x0000-0x0007</code>取出来，然后再把<code>0x0008-0x0015</code>取出来，把两次的结果都返回给你。CPU和内存IO的硬件限制导致没办法一次跨在两个数据宽度中间进行IO。这样你的应用程序就会变慢，算是计算机因为你不懂内存对齐而给你的一点点惩罚</p>
<p><strong>内存对齐规则</strong></p>
<ol>
<li><strong>结构体第一个成员的偏移量<code>offset</code>为<code>0</code>，以后每个成员相对于结构体首地址的<code>offset</code>都是该成员大小与<code>有效对齐值</code>中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节</strong></li>
<li><strong>结构体的总大小为<code>有效对齐值</code>的整数倍，如有需要编译器会在最末一个成员之后加上填充字节</strong></li>
</ol>
<ul>
<li><strong>有效对齐值：是给定值<code>#pragma pack(n)</code>和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。gcc中默认<code>#pragma pack(4)</code>，可以通过预编译命令<code>#pragma pack(n)，n = 1,2,4,8,16</code>来改变这一系数</strong></li>
</ul>
<p><strong>下面以一个例子来说明</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Align1</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> f1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Align2</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> f1;</span><br><span class="line">    <span class="type">int16_t</span> f2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Align3</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> f1;</span><br><span class="line">    <span class="type">int16_t</span> f2;</span><br><span class="line">    <span class="type">int32_t</span> f3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Align4</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> f1;</span><br><span class="line">    <span class="type">int16_t</span> f2;</span><br><span class="line">    <span class="type">int32_t</span> f3;</span><br><span class="line">    <span class="type">int64_t</span> f4;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Align1&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf1&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align1, f1) &lt;&lt; <span class="string">&quot;, f1&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align1::f1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Align2&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf1&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align2, f1) &lt;&lt; <span class="string">&quot;, f1&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align2::f1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf2&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align2, f2) &lt;&lt; <span class="string">&quot;, f2&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align2::f2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Align3&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align3) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf1&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align3, f1) &lt;&lt; <span class="string">&quot;, f1&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align3::f1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf2&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align3, f2) &lt;&lt; <span class="string">&quot;, f2&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align3::f2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf3&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align3, f3) &lt;&lt; <span class="string">&quot;, f3&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align3::f3) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Align4&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align4) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf1&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align4, f1) &lt;&lt; <span class="string">&quot;, f1&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align4::f1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf2&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align4, f2) &lt;&lt; <span class="string">&quot;, f2&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align4::f2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf3&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align4, f3) &lt;&lt; <span class="string">&quot;, f3&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align4::f3) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf4&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align4, f4) &lt;&lt; <span class="string">&quot;, f4&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align4::f4) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果如下</strong></p>
<ul>
<li>由于每个成员的offset必须是该成员与<code>有效对齐值</code>中较小的那个值的整数倍，下面称较小的这个值为<code>成员有效对齐值</code></li>
<li><code>Align1</code>：最长数据类型的长度是<code>1</code>，pack=<code>4</code>，因此，<code>有效对齐值</code>是<code>min(1, 4) = 1</code>
<ul>
<li>规则1：
<ul>
<li><code>f1</code>，第一个成员的<code>offset = 0</code></li>
</ul>
</li>
<li>规则2：
<ul>
<li>类型总长度为<code>1</code>，是<code>有效对齐值（1）</code>的整数倍</li>
</ul>
</li>
</ul>
</li>
<li><code>Align2</code>：最长数据类型的长度是<code>2</code>，pack=<code>4</code>，因此，<code>有效对齐值</code>是<code>min(2, 4) = 2</code>
<ul>
<li>规则1：
<ul>
<li><code>f1</code>，第一个成员的<code>offset = 0</code></li>
<li><code>f2</code>，类型长度为<code>2</code>，因此，<code>成员有效对齐值</code>是<code>min(2, 2) = 2</code>。<code>offset = 2</code>是<code>成员有效对齐值（2)</code>的整数倍</li>
</ul>
</li>
<li>规则2：
<ul>
<li>类型总长度为<code>4</code>，是<code>有效对齐值（2）</code>的整数倍</li>
</ul>
</li>
</ul>
</li>
<li><code>Align3</code>：最长数据类型的长度是<code>4</code>，pack=<code>4</code>，因此，<code>有效对齐值</code>是<code>min(4, 4) = 4</code>
<ul>
<li>规则1：
<ul>
<li><code>f1</code>，第一个成员的<code>offset = 0</code></li>
<li><code>f2</code>，类型长度为<code>2</code>，因此，<code>成员有效对齐值</code>是<code>min(2, 4) = 2</code>。<code>offset = 2</code>是<code>成员有效对齐值（2)</code>的整数倍</li>
<li><code>f3</code>，类型长度为<code>4</code>，因此，<code>成员有效对齐值</code>是<code>min(4, 4) = 4</code>。<code>offset = 4</code>是<code>成员有效对齐值（4)</code>的整数倍</li>
</ul>
</li>
<li>规则2：
<ul>
<li>类型总长度为<code>8</code>，是<code>有效对齐值（4）</code>的整数倍</li>
</ul>
</li>
</ul>
</li>
<li><code>Align4</code>：最长数据类型的长度是<code>8</code>，pack=<code>4</code>，因此，<code>有效对齐值</code>是<code>min(8, 4) = 4</code>
<ul>
<li>规则1：
<ul>
<li><code>f1</code>，第一个成员的<code>offset = 0</code></li>
<li><code>f2</code>，类型长度为<code>2</code>，因此，<code>成员有效对齐值</code>是<code>min(2, 4) = 2</code>。<code>offset = 2</code>是<code>成员有效对齐值（2)</code>的整数倍</li>
<li><code>f3</code>，类型长度为<code>4</code>，因此，<code>成员有效对齐值</code>是<code>min(4, 4) = 4</code>。<code>offset = 4</code>是<code>成员有效对齐值（4)</code>的整数倍</li>
<li><code>f4</code>，类型长度为<code>8</code>，因此，<code>成员有效对齐值</code>是<code>min(8, 4) = 4</code>。<code>offset = 8</code>是<code>成员有效对齐值（4)</code>的整数倍</li>
</ul>
</li>
<li>规则2：
<ul>
<li>类型总长度为<code>16</code>，是<code>有效对齐值（4）</code>的整数倍</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Align1&#x27;s size = 1</span><br><span class="line">    f1&#x27;s offset = 0, f1&#x27;s size = 1</span><br><span class="line"></span><br><span class="line">Align2&#x27;s size = 4</span><br><span class="line">    f1&#x27;s offset = 0, f1&#x27;s size = 1</span><br><span class="line">    f2&#x27;s offset = 2, f2&#x27;s size = 2</span><br><span class="line"></span><br><span class="line">Align3&#x27;s size = 8</span><br><span class="line">    f1&#x27;s offset = 0, f1&#x27;s size = 1</span><br><span class="line">    f2&#x27;s offset = 2, f2&#x27;s size = 2</span><br><span class="line">    f3&#x27;s offset = 4, f3&#x27;s size = 4</span><br><span class="line"></span><br><span class="line">Align4&#x27;s size = 16</span><br><span class="line">    f1&#x27;s offset = 0, f1&#x27;s size = 1</span><br><span class="line">    f2&#x27;s offset = 2, f2&#x27;s size = 2</span><br><span class="line">    f3&#x27;s offset = 4, f3&#x27;s size = 4</span><br><span class="line">    f4&#x27;s offset = 8, f4&#x27;s size = 8</span><br></pre></td></tr></table></figure>
<h3 id="332-sizeof"><a class="markdownIt-Anchor" href="#332-sizeof"></a> 3.3.2 sizeof</h3>
<p><strong><code>sizeof</code>用于获取对象的内存大小</strong></p>
<ul>
<li><code>sizeof(int32_t)</code>：4</li>
<li><code>sizeof(char[2][2][2])</code>：8</li>
</ul>
<h3 id="333-alignof"><a class="markdownIt-Anchor" href="#333-alignof"></a> 3.3.3 alignof</h3>
<p><strong><code>alignof</code>用于获取对象的有效对齐值。<code>alignas</code>用于设置有效对其值（不允许小于默认的有效对齐值）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo1</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int32_t</span> i32;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile error</span></span><br><span class="line"><span class="comment">// Requested alignment is less than minimum int alignment of 4 for type &#x27;Foo2&#x27;</span></span><br><span class="line"><span class="comment">// struct alignas(1) Foo2 &#123;</span></span><br><span class="line"><span class="comment">//     char c;</span></span><br><span class="line"><span class="comment">//     int32_t i32;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile error</span></span><br><span class="line"><span class="comment">// Requested alignment is less than minimum int alignment of 4 for type &#x27;Foo3&#x27;</span></span><br><span class="line"><span class="comment">// struct alignas(2) Foo3 &#123;</span></span><br><span class="line"><span class="comment">//     char c;</span></span><br><span class="line"><span class="comment">//     int32_t i32;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">4</span>) Foo4 &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int32_t</span> i32;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">8</span>) Foo5 &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int32_t</span> i32;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>) Foo6 &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int32_t</span> i32;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_SIZE(name)                                                                                      \</span></span><br><span class="line"><span class="meta">    std::cout &lt;&lt; <span class="string">&quot;sizeof(&quot;</span> &lt;&lt; #name &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; sizeof(name) &lt;&lt; <span class="string">&quot;, alignof(&quot;</span> &lt;&lt; #name &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; alignof(name) \</span></span><br><span class="line"><span class="meta">              &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">PRINT_SIZE</span>(Foo1);</span><br><span class="line">    <span class="built_in">PRINT_SIZE</span>(Foo4);</span><br><span class="line">    <span class="built_in">PRINT_SIZE</span>(Foo5);</span><br><span class="line">    <span class="built_in">PRINT_SIZE</span>(Foo6);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Foo1)=8, alignof(Foo1)=4</span><br><span class="line">sizeof(Foo4)=8, alignof(Foo4)=4</span><br><span class="line">sizeof(Foo5)=8, alignof(Foo5)=8</span><br><span class="line">sizeof(Foo6)=16, alignof(Foo6)=16</span><br></pre></td></tr></table></figure>
<h3 id="334-alignas"><a class="markdownIt-Anchor" href="#334-alignas"></a> 3.3.4 alignas</h3>
<p><code>alignas</code>类型说明符是一种可移植的<code>C++</code>标准方法，用于指定变量和自定义类型的对齐方式，可以在定义 <code>class</code>、<code>struct</code>、<code>union</code>或声明变量时使用。如果遇到多个<code>alignas</code>说明符，编译器会选择最严格的那个（最大对齐值）</p>
<p>内存对齐可以使处理器更好地利用<code>cache</code>，包括减少<code>cache line</code>访问，以及避免多核一致性问题引发的 <code>cache miss</code>。具体来说，在多线程程序中，一种常用的优化手段是将需要高频并发访问的数据按<code>cache line</code>大小（通常为<code>64</code>字节）对齐。一方面，对于小于<code>64</code>字节的数据可以做到只触及一个<code>cache line</code>，减少访存次数；另一方面，相当于独占了整个<code>cache line</code>，避免其他数据可能修改同一<code>cache line</code>导致其他核<code>cache miss</code>的开销</p>
<p><strong>数组：对数组使用<code>alignas</code>，对齐的是数组的首地址，而不是每个数组元素。也就是说，下面这个数组并不是每个<code>int</code>都占<code>64</code>字节。如果一定要让每个元素都对齐，可以定义一个<code>struct</code>，如<code>int_align_64</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> array1[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) int_align_64 &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">int_align_64 array2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_SIZEOF(element) std::cout &lt;&lt; <span class="string">&quot;sizeof(&quot;</span> &lt;&lt; #element &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; sizeof(element) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_ALIGNOF(element) std::cout &lt;&lt; <span class="string">&quot;alignof(&quot;</span> &lt;&lt; #element &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; alignof(element) &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF</span>(array1[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF</span>(array2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PRINT_ALIGNOF</span>(<span class="keyword">decltype</span>(array1));</span><br><span class="line">    <span class="built_in">PRINT_ALIGNOF</span>(<span class="keyword">decltype</span>(array2));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PRINT_ALIGNOF</span>(<span class="keyword">decltype</span>(array1[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">PRINT_ALIGNOF</span>(<span class="keyword">decltype</span>(array2[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sizeof(array1[1])=4</span><br><span class="line">sizeof(array2[1])=64</span><br><span class="line">alignof(decltype(array1))=4</span><br><span class="line">alignof(decltype(array2))=64</span><br><span class="line">alignof(decltype(array1[1]))=4</span><br><span class="line">alignof(decltype(array2[1]))=64</span><br></pre></td></tr></table></figure>
<h2 id="34-type-inference"><a class="markdownIt-Anchor" href="#34-type-inference"></a> 3.4 Type Inference</h2>
<h3 id="341-auto"><a class="markdownIt-Anchor" href="#341-auto"></a> 3.4.1 auto</h3>
<p><strong><code>auto</code>会忽略顶层<code>const</code>，保留底层的<code>const</code>，但是当设置一个类型为<code>auto</code>的引用时，初始值中的顶层常量属性仍然保留</strong></p>
<h3 id="342-decltype"><a class="markdownIt-Anchor" href="#342-decltype"></a> 3.4.2 decltype</h3>
<ul>
<li><strong><code>decltype</code>会保留变量的所有类型信息（包括顶层<code>const</code>和引用在内）</strong></li>
<li>如果表达式的内容是解引用操作，得到的将是引用类型
<ul>
<li><code>int i = 42;</code></li>
<li><code>int *p = &amp;i;</code></li>
<li><code>decltype(*p)</code>得到的是<code>int&amp;</code></li>
</ul>
</li>
<li><strong><code>decltype((c))</code>会得到<code>c</code>的引用类型（无论<code>c</code>本身是不是引用）</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> print_type_info(exp)                                                                     \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                                         \</span></span><br><span class="line"><span class="meta">        std::cout &lt;&lt; #exp &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; std::endl;                                                  \</span></span><br><span class="line"><span class="meta">        std::cout <span class="string">&lt;&lt; &quot;\tis_reference_v=&quot; &lt;&lt; std::is_reference_v&lt;exp&gt;</span> &lt;&lt; std::endl;               \</span></span><br><span class="line"><span class="meta">        std::cout <span class="string">&lt;&lt; &quot;\tis_lvalue_reference_v=&quot; &lt;&lt; std::is_lvalue_reference_v&lt;exp&gt;</span> &lt;&lt; std::endl; \</span></span><br><span class="line"><span class="meta">        std::cout <span class="string">&lt;&lt; &quot;\tis_rvalue_reference_v=&quot; &lt;&lt; std::is_rvalue_reference_v&lt;exp&gt;</span> &lt;&lt; std::endl; \</span></span><br><span class="line"><span class="meta">        std::cout <span class="string">&lt;&lt; &quot;\tis_const_v=&quot; &lt;&lt; std::is_const_v&lt;exp&gt;</span> &lt;&lt; std::endl;                       \</span></span><br><span class="line"><span class="meta">        std::cout <span class="string">&lt;&lt; &quot;\tis_pointer_v=&quot; &lt;&lt; std::is_pointer_v&lt;exp&gt;</span> &lt;&lt; std::endl;                   \</span></span><br><span class="line"><span class="meta">        std::cout &lt;&lt; std::endl;                                                                  \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>&amp; num2 = num1;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; num3 = num1;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; num4 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* ptr1 = &amp;num1;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> ptr2 = &amp;num1;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr3 = &amp;num1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>((<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(num1));</span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>((num1)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(num2));</span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(num3));</span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(num4));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(ptr1));</span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(*ptr1));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(ptr2));</span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(*ptr2));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(ptr3));</span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(*ptr3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">decltype(0):</span><br><span class="line">    is_reference_v=0</span><br><span class="line">    is_lvalue_reference_v=0</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype((0)):</span><br><span class="line">    is_reference_v=0</span><br><span class="line">    is_lvalue_reference_v=0</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype(num1):</span><br><span class="line">    is_reference_v=0</span><br><span class="line">    is_lvalue_reference_v=0</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype((num1)):</span><br><span class="line">    is_reference_v=1</span><br><span class="line">    is_lvalue_reference_v=1</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype(num2):</span><br><span class="line">    is_reference_v=1</span><br><span class="line">    is_lvalue_reference_v=1</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype(num3):</span><br><span class="line">    is_reference_v=1</span><br><span class="line">    is_lvalue_reference_v=1</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype(num4):</span><br><span class="line">    is_reference_v=1</span><br><span class="line">    is_lvalue_reference_v=0</span><br><span class="line">    is_rvalue_reference_v=1</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype(ptr1):</span><br><span class="line">    is_reference_v=0</span><br><span class="line">    is_lvalue_reference_v=0</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=1</span><br><span class="line"></span><br><span class="line">decltype(*ptr1):</span><br><span class="line">    is_reference_v=1</span><br><span class="line">    is_lvalue_reference_v=1</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype(ptr2):</span><br><span class="line">    is_reference_v=0</span><br><span class="line">    is_lvalue_reference_v=0</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=1</span><br><span class="line">    is_pointer_v=1</span><br><span class="line"></span><br><span class="line">decltype(*ptr2):</span><br><span class="line">    is_reference_v=1</span><br><span class="line">    is_lvalue_reference_v=1</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype(ptr3):</span><br><span class="line">    is_reference_v=0</span><br><span class="line">    is_lvalue_reference_v=0</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=1</span><br><span class="line"></span><br><span class="line">decltype(*ptr3):</span><br><span class="line">    is_reference_v=1</span><br><span class="line">    is_lvalue_reference_v=1</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br></pre></td></tr></table></figure>
<p>此外，<code>decltype</code>发生在编译期，即它不会产生任何运行时的代码。示例如下，编译执行后，可以发现<code>say_hello</code>并未执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">say_hello</span>()) a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="343-typeof"><a class="markdownIt-Anchor" href="#343-typeof"></a> 3.4.3 typeof</h3>
<p><strong>非<code>C++</code>标准</strong></p>
<h3 id="344-typeid"><a class="markdownIt-Anchor" href="#344-typeid"></a> 3.4.4 typeid</h3>
<p><strong><code>typeid</code>运算符允许在运行时确定对象的类型。若要判断是父类还是子类的话，那么父类必须包含虚函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_TYPE(left, right)                                                            \</span></span><br><span class="line"><span class="meta">    std::cout &lt;&lt; <span class="string">&quot;typeid(&quot;</span> &lt;&lt; #left &lt;&lt; <span class="string">&quot;) == typeid(&quot;</span> &lt;&lt; #right &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; std::boolalpha \</span></span><br><span class="line"><span class="meta">              &lt;&lt; (typeid(left) == typeid(right)) &lt;&lt; std::noboolalpha &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseWithoutVirtualFunc</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeriveWithoutVirtualFunc</span> : <span class="keyword">public</span> BaseWithoutVirtualFunc &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseWithVirtualFunc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeriveWithVirtualFunc</span> : <span class="keyword">public</span> BaseWithVirtualFunc &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(str, std::string);</span><br><span class="line"></span><br><span class="line">    BaseWithoutVirtualFunc* ptr1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr1, BaseWithoutVirtualFunc);</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr1, DeriveWithoutVirtualFunc);</span><br><span class="line"></span><br><span class="line">    BaseWithoutVirtualFunc* ptr2 = <span class="keyword">new</span> <span class="built_in">BaseWithoutVirtualFunc</span>();</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr2, BaseWithoutVirtualFunc);</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr2, DeriveWithoutVirtualFunc);</span><br><span class="line"></span><br><span class="line">    BaseWithoutVirtualFunc* ptr3 = <span class="keyword">new</span> <span class="built_in">DeriveWithoutVirtualFunc</span>();</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr3, BaseWithoutVirtualFunc);</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr3, DeriveWithoutVirtualFunc);</span><br><span class="line"></span><br><span class="line">    BaseWithVirtualFunc* ptr4 = <span class="keyword">new</span> <span class="built_in">BaseWithVirtualFunc</span>();</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr4, BaseWithVirtualFunc);</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr4, DeriveWithVirtualFunc);</span><br><span class="line"></span><br><span class="line">    BaseWithVirtualFunc* ptr5 = <span class="keyword">new</span> <span class="built_in">DeriveWithVirtualFunc</span>();</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr5, BaseWithVirtualFunc);</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr5, DeriveWithVirtualFunc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typeid(str) == typeid(std::string): true</span><br><span class="line">typeid(*ptr1) == typeid(BaseWithoutVirtualFunc): true</span><br><span class="line">typeid(*ptr1) == typeid(DeriveWithoutVirtualFunc): false</span><br><span class="line">typeid(*ptr2) == typeid(BaseWithoutVirtualFunc): true</span><br><span class="line">typeid(*ptr2) == typeid(DeriveWithoutVirtualFunc): false</span><br><span class="line">typeid(*ptr3) == typeid(BaseWithoutVirtualFunc): true</span><br><span class="line">typeid(*ptr3) == typeid(DeriveWithoutVirtualFunc): false</span><br><span class="line">typeid(*ptr4) == typeid(BaseWithVirtualFunc): true</span><br><span class="line">typeid(*ptr4) == typeid(DeriveWithVirtualFunc): false</span><br><span class="line">typeid(*ptr5) == typeid(BaseWithVirtualFunc): false</span><br><span class="line">typeid(*ptr5) == typeid(DeriveWithVirtualFunc): true</span><br></pre></td></tr></table></figure>
<p><strong>此外，还可以使用<code>dynamic_cast</code>来判断指针指向子类还是父类</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_TYPE(left, right)                                                                   \</span></span><br><span class="line"><span class="meta">    std::cout <span class="string">&lt;&lt; &quot;dynamic_cast&lt;&quot; &lt;&lt; #right &lt;&lt; &quot;&gt;</span>(<span class="string">&quot; &lt;&lt; #left &lt;&lt; &quot;</span>) != nullptr: <span class="string">&quot; &lt;&lt; std::boolalpha \</span></span></span><br><span class="line"><span class="string"><span class="meta">              &lt;&lt; (dynamic_cast&lt;right&gt;(left) != nullptr) &lt;&lt; std::noboolalpha &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">class Base &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">public:</span></span></span><br><span class="line"><span class="string"><span class="meta">    virtual ~Base() &#123;&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">class Derive : public Base &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    virtual ~Derive() &#123;&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">int main() &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    Base* ptr1 = nullptr;</span></span></span><br><span class="line"><span class="string"><span class="meta">    CHECK_TYPE(ptr1, Base*);</span></span></span><br><span class="line"><span class="string"><span class="meta">    CHECK_TYPE(ptr1, Derive*);</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    Base* ptr2 = new Base();</span></span></span><br><span class="line"><span class="string"><span class="meta">    CHECK_TYPE(ptr2, Base*);</span></span></span><br><span class="line"><span class="string"><span class="meta">    CHECK_TYPE(ptr2, Derive*);</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    Base* ptr3 = new Derive();</span></span></span><br><span class="line"><span class="string"><span class="meta">    CHECK_TYPE(ptr3, Base*);</span></span></span><br><span class="line"><span class="string"><span class="meta">    CHECK_TYPE(ptr3, Derive*);</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dynamic_cast&lt;Base*&gt;(ptr1) != nullptr: false</span><br><span class="line">dynamic_cast&lt;Derive*&gt;(ptr1) != nullptr: false</span><br><span class="line">dynamic_cast&lt;Base*&gt;(ptr2) != nullptr: true</span><br><span class="line">dynamic_cast&lt;Derive*&gt;(ptr2) != nullptr: false</span><br><span class="line">dynamic_cast&lt;Base*&gt;(ptr3) != nullptr: true</span><br><span class="line">dynamic_cast&lt;Derive*&gt;(ptr3) != nullptr: true</span><br></pre></td></tr></table></figure>
<h2 id="35-type-conversion"><a class="markdownIt-Anchor" href="#35-type-conversion"></a> 3.5 Type Conversion</h2>
<h3 id="351-static_cast"><a class="markdownIt-Anchor" href="#351-static_cast"></a> 3.5.1 static_cast</h3>
<p><strong>用法：<code>static_cast&lt;type&gt; (expr)</code></strong></p>
<p><code>static_cast</code>运算符执行非动态转换，没有运行时类检查来保证转换的安全性。例如，它可以用来把一个基类指针转换为派生类指针。任何具有明确意义的类型转换，只要不包含底层<code>const</code>，都可以使用<code>static_cast</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *cc = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> s = <span class="built_in">static_cast</span>&lt;std::string&gt;(cc);</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compile error</span></span><br><span class="line">    <span class="comment">// auto i = static_cast&lt;int&gt;(cc);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，若待转换类型既不是引用类型，也不是指针类型时，会调用该类型的拷贝构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Foo&#x27;s default ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp; foo) &#123; std::cout &lt;&lt; <span class="string">&quot;Foo&#x27;s copy ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">something</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo* f = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Foo&gt;(*f).<span class="built_in">something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="352-dynamic_cast"><a class="markdownIt-Anchor" href="#352-dynamic_cast"></a> 3.5.2 dynamic_cast</h3>
<p><strong>用法：<code>dynamic_cast&lt;type&gt; (expr)</code></strong></p>
<p><code>dynamic_cast</code>通常用于在继承结构之间进行转换，在运行时执行转换，验证转换的有效性。<code>type</code>必须是类的指针、类的引用或者<code>void*</code>。若指针转换失败，则得到的是<code>nullptr</code>；若引用转换失败，那么会抛出<code>std::bad_cast</code>类型的异常</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base&#x27;s func&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive&#x27;s func&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> Base &amp;b = Derive&#123;&#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;d = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derive &amp;&gt;(b);</span><br><span class="line">        d.<span class="built_in">func</span>();</span><br><span class="line">        <span class="keyword">auto</span> &amp;s = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> std::string &amp;&gt;(b); <span class="comment">// error case</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::bad_cast &amp;err) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;err=&quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Base *pb = &amp;b;</span><br><span class="line">    <span class="keyword">auto</span> *pd = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derive *&gt;(pb);</span><br><span class="line">    pd-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">auto</span> *ps = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> std::string *&gt;(pb); <span class="comment">// error case</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ps=&quot;</span> &lt;&lt; ps &lt;&lt; std::endl; <span class="comment">// print nullptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="353-const_cast"><a class="markdownIt-Anchor" href="#353-const_cast"></a> 3.5.3 const_cast</h3>
<p><strong>用法：<code>const_cast&lt;type&gt; (expr)</code></strong></p>
<p>这种类型的转换主要是用来操作所传对象的<code>const</code>属性，可以加上<code>const</code>属性，也可以去掉<code>const</code>属性（顶层底层均可）。其中，<code>type</code>只能是如下几类（必须是引用或者指针类型）</p>
<ul>
<li><code>T &amp;</code></li>
<li><code>const T &amp;</code></li>
<li><code>T &amp;&amp;</code></li>
<li><code>T *</code></li>
<li><code>const T *</code></li>
<li><code>T *const</code></li>
<li><code>const T *const</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;const T &amp; -&gt; T &amp;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;v1 = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v1&#x27;s address=&quot;</span> &lt;&lt; &amp;v1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> &amp;v2 = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> &amp;&gt;(v1);</span><br><span class="line">    v2 = <span class="number">200</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v2&#x27;s address=&quot;</span> &lt;&lt; &amp;v2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nT &amp; -&gt; T &amp;&amp;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> &amp;&amp;v3 = <span class="built_in">const_cast</span>&lt; <span class="type">int</span> &amp;&amp;&gt;(v2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v3&#x27;s address=&quot;</span> &lt;&lt; &amp;v3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nT * -&gt; const T *const&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;v2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1=&quot;</span> &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p2 = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> &gt;(p1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2=&quot;</span> &lt;&lt; p2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="354-reinterpret_cast"><a class="markdownIt-Anchor" href="#354-reinterpret_cast"></a> 3.5.4 reinterpret_cast</h3>
<p><strong>用法：<code>reinterpret_cast&lt;type&gt; (expr)</code></strong></p>
<p><code>reinterpret_cast</code>是最危险的类型转换，它能够直接将一种类型的指针转换为另一种类型的指针，应该非常谨慎地使用。在很大程度上，使用<code>reinterpret_cast</code>获得的唯一保证是，通常如果你将结果转换回原始类型，您将获得完全相同的值（但如果中间类型小于原始类型，则不会）。也有许多<code>reinterpret_cast</code>不能做的转换。它主要用于特别奇怪的转换和位操作，例如将原始数据流转换为实际数据，或将数据存储在指向对齐数据的指针的低位中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> i = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">    <span class="type">int32_t</span> *pi = &amp;i;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> *pl = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int64_t</span> *&gt; (pi);</span><br><span class="line">        std::cout &lt;&lt; *pl &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">auto</span> *rebuild_pi = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int32_t</span> *&gt; (pl);</span><br><span class="line">        std::cout &lt;&lt; *rebuild_pi &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="36-storage-class-specifiers"><a class="markdownIt-Anchor" href="#36-storage-class-specifiers"></a> 3.6 Storage Class Specifiers</h2>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/storage_duration">Storage class specifiers</a></p>
<p>In C++, storage classes determine the scope, visibility, and lifetime of variables. There are four storage classes in C++:</p>
<ol>
<li><strong>Automatic Storage Class (default)</strong>: Variables declared within a block or function without specifying a storage class are considered to have automatic storage class. These variables are created when the block or function is entered and destroyed when the block or function is exited. The keyword “auto” can also be used explicitly, although it is optional.</li>
<li><strong>Static Storage Class</strong>: Variables with static storage class are created and initialized only once, and their values persist across function calls. They are initialized to zero by default. Static variables can be declared within a block or function, but their scope is limited to that block or function. The keyword “static” is used to specify static storage class.</li>
<li><strong>Register Storage Class (deprecated)</strong>: The register storage class is used to suggest that a variable be stored in a register instead of memory. The keyword “register” is used to specify register storage class. However, the compiler is free to ignore this suggestion.</li>
<li><strong>Extern Storage Class</strong>: The extern storage class is used to declare a variable that is defined in another translation unit (source file). It is often used to provide a global variable declaration that can be accessed from multiple files. When using extern, the variable is not allocated any storage, as it is assumed to be defined elsewhere. The keyword “extern” is used to specify extern storage class.</li>
</ol>
<p>Here’s an example illustrating the usage of different storage classes:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVariable; <span class="comment">// extern storage class by default</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVariable; <span class="comment">// static storage class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> autoVariable;              <span class="comment">// automatic storage class</span></span><br><span class="line">        <span class="keyword">register</span> <span class="type">int</span> registerVariable; <span class="comment">// register storage class</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Auto: &quot;</span> &lt;&lt; autoVariable &lt;&lt; <span class="string">&quot;, Static: &quot;</span> &lt;&lt; staticVariable &lt;&lt; <span class="string">&quot;, Register: &quot;</span> &lt;&lt; registerVariable</span><br><span class="line">                  &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        ++autoVariable;</span><br><span class="line">        ++staticVariable;</span><br><span class="line">        ++registerVariable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    globalVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="361-static"><a class="markdownIt-Anchor" href="#361-static"></a> 3.6.1 static</h3>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/keyword/static">C++ 关键词：static</a></p>
<ol>
<li>声明具有静态存储期和内部链接的命名空间成员（全局静态变量/函数，其他编译单元不可见）
<ul>
<li>表示该编译单元不导出这个函数/变量的符号，因此无法再别的编译单元里使用</li>
</ul>
</li>
<li>定义具有静态存储期且仅初始化一次的块作用域变量（函数的静态变量）
<ul>
<li>变量的存储方式和全局变量一样，但仍然不导出符号</li>
</ul>
</li>
<li>声明不绑定到特定实例的类成员（类的静态成员）</li>
</ol>
<h3 id="362-extern"><a class="markdownIt-Anchor" href="#362-extern"></a> 3.6.2 extern</h3>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/keyword/extern">C++ 关键词：extern</a></p>
<ul>
<li>Static storage duration specifier with external linkage
<ul>
<li>This symbol is defined in another compilation unit, which means it needs to be placed in the unresolved symbol table (external linkage)</li>
</ul>
</li>
<li>Language linkage specification, to avoid name mangling
<ul>
<li><code>extern &quot;C&quot; &#123;&#125;</code></li>
</ul>
</li>
<li>Explicit template instantiation declaration
<ul>
<li>For class templates</li>
<li>For function templates</li>
</ul>
</li>
</ul>
<h4 id="3621-shared-global-variable"><a class="markdownIt-Anchor" href="#3621-shared-global-variable"></a> 3.6.2.1 Shared Global Variable</h4>
<p><strong>每个源文件中都得有该变量的声明，但是只有一个源文件中可以包含该变量的定义，通常可以采用如下做法</strong></p>
<ul>
<li>定义一个头文件<code>xxx.h</code>，声明该变量（需要用extern关键字）</li>
<li>所有源文件包含该头文件<code>xxx.h</code></li>
<li>在某个源文件中定义该变量</li>
</ul>
<p><strong>示例如下：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建头文件</span></span><br><span class="line"><span class="built_in">cat</span> &gt; extern.h &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#pragma once</span></span><br><span class="line"></span><br><span class="line">extern int extern_value;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建源文件</span></span><br><span class="line"><span class="built_in">cat</span> &gt; extern.cpp &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#include &quot;extern.h&quot;</span></span><br><span class="line"></span><br><span class="line">int extern_value = 5;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建源文件</span></span><br><span class="line"><span class="built_in">cat</span> &gt; main.cpp &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &quot;extern.h&quot;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">extern_value &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 编译</span></span><br><span class="line"><span class="string">gcc -o main main.cpp extern.cpp -lstdc++ -Wall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 执行</span></span><br><span class="line"><span class="string">./main</span></span><br></pre></td></tr></table></figure>
<h3 id="363-thread_local"><a class="markdownIt-Anchor" href="#363-thread_local"></a> 3.6.3 thread_local</h3>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/keyword/thread_local">C++ 关键词：thread_local (C++11 起)</a></p>
<ul>
<li>线程局域存储期指定符</li>
</ul>
<p>实现原理（猜测）：在每个线程的栈空间起始位置（高位，栈是从上往下分配内存的）存储由<code>thread_local</code>修饰的变量。下面由一个程序来验证一下这个猜想：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int32_t</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_address</span><span class="params">(<span class="type">const</span> std::string name, <span class="type">int32_t</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::mutex m;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; &amp;value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> addr_t1;</span><br><span class="line">    <span class="type">uint64_t</span> addr_t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_address</span>(<span class="string">&quot;main_thread_local&quot;</span>, value);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">print_address</span>(<span class="string">&quot;main_local&quot;</span>, i);</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;addr_t1]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        addr_t1 = <span class="keyword">reinterpret_cast</span>&lt;<span class="type">uint64_t</span>&gt;(&amp;value);</span></span></span><br><span class="line"><span class="params"><span class="function">        print_address(<span class="string">&quot;t1_thread_local&quot;</span>, value);</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> i;</span></span></span><br><span class="line"><span class="params"><span class="function">        print_address(<span class="string">&quot;t1_local&quot;</span>, i);</span></span></span><br><span class="line"><span class="params"><span class="function">        assert(&amp;i &lt; &amp;value);</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;addr_t2]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        addr_t2 = <span class="keyword">reinterpret_cast</span>&lt;<span class="type">uint64_t</span>&gt;(&amp;value);</span></span></span><br><span class="line"><span class="params"><span class="function">        print_address(<span class="string">&quot;t2_thread_local&quot;</span>, value);</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> i;</span></span></span><br><span class="line"><span class="params"><span class="function">        print_address(<span class="string">&quot;t2_local&quot;</span>, i);</span></span></span><br><span class="line"><span class="params"><span class="function">        assert(&amp;i &lt; &amp;value);</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> distance = addr_t1 - addr_t2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;addr distance between t1 and t2 is: &quot;</span> &lt;&lt; distance &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我的环境中，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main_thread_local: 0x7f190e1a573c</span><br><span class="line">main_local: 0x7fff425e1dd4</span><br><span class="line">t1_thread_local: 0x7f190e1a463c</span><br><span class="line">t1_local: 0x7f190e1a3ddc</span><br><span class="line">t2_thread_local: 0x7f190d9a363c</span><br><span class="line">t2_local: 0x7f190d9a2ddc</span><br><span class="line">addr distance between t1 and t2 is: 8392704</span><br></pre></td></tr></table></figure>
<p>可以发现，在不同的线程中，<code>value</code>的内存地址是不同的，且处于高位。相邻两个线程，<code>value</code>地址的差值差不多就是栈空间的大小（<code>ulimit -s</code>）</p>
<h4 id="3631-initialization"><a class="markdownIt-Anchor" href="#3631-initialization"></a> 3.6.3.1 Initialization</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::mutex m;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="type">int</span> _[] = &#123;(std::cout &lt;&lt; args, <span class="number">0</span>)...&#125;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;default ctor&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp; foo) &#123; <span class="built_in">print</span>(<span class="string">&quot;copy ctor&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(Foo&amp;&amp; foo) &#123; <span class="built_in">print</span>(<span class="string">&quot;move ctor&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;dtor&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> Foo foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo.value = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main: foo&#x27;address=&quot;</span>, &amp;foo, <span class="string">&quot;, value=&quot;</span>, foo.value);</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;]() &#123; print(<span class="string">&quot;t1: foo&#x27;address=&quot;</span>, &amp;foo, <span class="string">&quot;, value=&quot;</span>, foo.value); &#125;)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<ul>
<li>构造方法调用了2次，因为这两个线程都经过了<code>foo</code>这个变量的声明，因此都会分配存储空间并进行初始化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default ctor</span><br><span class="line">main: foo&#x27;address=0x7f5fd6b0c77c, value=1</span><br><span class="line">default ctor</span><br><span class="line">t1: foo&#x27;address=0x7f5fd5a3c6fc, value=0</span><br><span class="line">dtor</span><br><span class="line">dtor</span><br></pre></td></tr></table></figure>
<p>修改一下，我们将<code>thread_local</code>移动到<code>main</code>函数内部</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::mutex m;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="type">int</span> _[] = &#123;(std::cout &lt;&lt; args, <span class="number">0</span>)...&#125;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;default ctor&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp; foo) &#123; <span class="built_in">print</span>(<span class="string">&quot;copy ctor&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(Foo&amp;&amp; foo) &#123; <span class="built_in">print</span>(<span class="string">&quot;move ctor&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;dtor&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> Foo foo;</span><br><span class="line">    foo.value = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main: foo&#x27;address=&quot;</span>, &amp;foo, <span class="string">&quot;, value=&quot;</span>, foo.value);</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;]() &#123; print(<span class="string">&quot;t1: foo&#x27;address=&quot;</span>, &amp;foo, <span class="string">&quot;, value=&quot;</span>, foo.value); &#125;)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<ul>
<li>构造方法调用了1次，只有<code>main</code>线程经过了<code>foo</code>这个变量的声明，因此会分配存储空间并进行初始化。而<code>t1</code>线程并未经过<code>foo</code>这个变量的声明，因此只分配了存储空间，并未进行初始化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default ctor</span><br><span class="line">main: foo&#x27;address=0x7f2d690e6778, value=1</span><br><span class="line">t1: foo&#x27;address=0x7f2d680166f8, value=0</span><br><span class="line">dtor</span><br></pre></td></tr></table></figure>
<h2 id="37-inheritance-and-polymorphism"><a class="markdownIt-Anchor" href="#37-inheritance-and-polymorphism"></a> 3.7 Inheritance and Polymorphism</h2>
<h3 id="371-inheritance-modes"><a class="markdownIt-Anchor" href="#371-inheritance-modes"></a> 3.7.1 Inheritance Modes</h3>
<table>
<thead>
<tr>
<th style="text-align:left">继承方式\成员的权限</th>
<th style="text-align:left">public</th>
<th style="text-align:left">protected</th>
<th style="text-align:left">private</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>public inherit</strong></td>
<td style="text-align:left">public</td>
<td style="text-align:left">protected</td>
<td style="text-align:left">invisible</td>
</tr>
<tr>
<td style="text-align:left"><strong>protected inherit</strong></td>
<td style="text-align:left">protected</td>
<td style="text-align:left">protected</td>
<td style="text-align:left">invisible</td>
</tr>
<tr>
<td style="text-align:left"><strong>private inherit</strong></td>
<td style="text-align:left">private</td>
<td style="text-align:left">private</td>
<td style="text-align:left">invisible</td>
</tr>
</tbody>
</table>
<p>无论哪种继承方式，都可以访问父类的<code>public</code>成员以及<code>protected</code>成员，但是会根据继承方式修改其访问权限，从而影响到派生类的访问权限</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">public_op</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;public_op&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">protected_op</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;protected_op&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">private_op</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;private_op&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PublicDerive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">public_op</span>();</span><br><span class="line">        <span class="built_in">protected_op</span>();</span><br><span class="line">        <span class="comment">// private_op();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondaryPublicDerive</span> : <span class="keyword">public</span> PublicDerive &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">public_op</span>();</span><br><span class="line">        <span class="built_in">protected_op</span>();</span><br><span class="line">        <span class="comment">// private_op();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProtectedDerive</span> : <span class="keyword">protected</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">public_op</span>();</span><br><span class="line">        <span class="built_in">protected_op</span>();</span><br><span class="line">        <span class="comment">// private_op();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondaryProtectedDerive</span> : <span class="keyword">public</span> ProtectedDerive &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">public_op</span>();</span><br><span class="line">        <span class="built_in">protected_op</span>();</span><br><span class="line">        <span class="comment">// private_op();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrivateDerive</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">public_op</span>();</span><br><span class="line">        <span class="built_in">protected_op</span>();</span><br><span class="line">        <span class="comment">// private_op();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondaryPrivateDerive</span> : <span class="keyword">public</span> PrivateDerive &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// public_op();</span></span><br><span class="line">        <span class="comment">// protected_op();</span></span><br><span class="line">        <span class="comment">// private_op();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecondaryPublicDerive obj_public;</span><br><span class="line">    obj_public.<span class="built_in">public_op</span>();</span><br><span class="line"></span><br><span class="line">    SecondaryProtectedDerive obj_protected;</span><br><span class="line">    <span class="comment">// obj_protected.public_op();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="372-virtual"><a class="markdownIt-Anchor" href="#372-virtual"></a> 3.7.2 virtual</h3>
<p><code>virtual</code>关键词修饰的就是虚函数，虚函数的分派发生在运行时</p>
<ol>
<li>有虚函数的每个类，维护一个虚函数表</li>
<li>有虚函数的类的对象，会包含一个指向该类的虚函数表的指针</li>
</ol>
<p><img src="/images/Cpp-Language/virtual-method-table.jpeg" alt="virtual-method-table" /></p>
<ul>
<li>图片出处：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110144589">c++虚指针和虚函数表</a></li>
</ul>
<h4 id="3721-virtual-destructor"><a class="markdownIt-Anchor" href="#3721-virtual-destructor"></a> 3.7.2.1 virtual destructor</h4>
<p>通常，我们需要将有虚函数的类的析构函数定义为<code>virtual</code>，否则很容易造成内存泄露，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;~Base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derive</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;~Derive&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derive::func&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="373-final"><a class="markdownIt-Anchor" href="#373-final"></a> 3.7.3 final</h3>
<p><code>final</code>可以修饰类或者虚函数</p>
<ul>
<li><code>final</code>修饰的类不能有子类，该类的所有虚函数不能被覆盖</li>
<li><code>final</code>修饰的虚函数，不能被覆盖
<ul>
<li>只能在虚函数的声明处进行修饰</li>
</ul>
</li>
</ul>
<p>当用具体类型的指针或者引用调用<code>final</code>修饰的虚函数时，虚函数的调用可以被编译器直接优化掉</p>
<h3 id="374-override"><a class="markdownIt-Anchor" href="#374-override"></a> 3.7.4 override</h3>
<p><code>override</code>可以修饰虚函数，表示对虚函数进行覆盖</p>
<ul>
<li>只能在虚函数的声明处进行修饰</li>
<li>加不加<code>override</code>其实没有影响</li>
</ul>
<h2 id="38-constexpr"><a class="markdownIt-Anchor" href="#38-constexpr"></a> 3.8 constexpr</h2>
<h3 id="381-if-constexpr"><a class="markdownIt-Anchor" href="#381-if-constexpr"></a> 3.8.1 if constexpr</h3>
<p>编译期分支判断，一般用于泛型。如果在分支中使用的是不同类型的不同特性，那么普通的<code>if</code>是没法通过编译的，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Condition1</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> T <span class="title">append</span><span class="params">(T left, T right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (std::is_integral&lt;T&gt;::value) &#123;</span><br><span class="line">            <span class="keyword">return</span> left + right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::is_pointer&lt;T&gt;::value) &#123;</span><br><span class="line">            <span class="built_in">return</span> (*left) + (*right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Condition2</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> T <span class="title">append</span><span class="params">(T left, T right)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> left + right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_pointer&lt;T&gt;::value) &#123;</span><br><span class="line">            <span class="built_in">return</span> (*left) + (*right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Condition1&lt;int32_t&gt;::append(1, 2);</span></span><br><span class="line">    Condition2&lt;<span class="type">int32_t</span>&gt;::<span class="built_in">append</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="39-static_assert"><a class="markdownIt-Anchor" href="#39-static_assert"></a> 3.9 static_assert</h2>
<p>编译期断言</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span>, <span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">long</span>) &gt; <span class="number">8</span>, <span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="310-noexcept"><a class="markdownIt-Anchor" href="#310-noexcept"></a> 3.10 noexcept</h2>
<p>用于声明函数不会抛异常，声明和实现都必须同时包含</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::func</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="311-throw-and-error"><a class="markdownIt-Anchor" href="#311-throw-and-error"></a> 3.11 throw and error</h2>
<p><code>throw</code>关键字可以抛出任何对象，例如可以抛出一个整数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">int</span> &amp;i) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 保护代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 能处理任何异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="312-placement-new"><a class="markdownIt-Anchor" href="#312-placement-new"></a> 3.12 placement new</h2>
<p><code>placement new</code>的功能就是在一个已经分配好的空间上，调用构造函数，创建一个对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *buf = <span class="comment">// 在这里为buf分配内存</span></span><br><span class="line">Class *pc = <span class="built_in">new</span> (buf) <span class="built_in">Class</span>();  </span><br></pre></td></tr></table></figure>
<h1 id="4-template"><a class="markdownIt-Anchor" href="#4-template"></a> 4 template</h1>
<h2 id="41-template-type"><a class="markdownIt-Anchor" href="#41-template-type"></a> 4.1 template Type</h2>
<ol>
<li>
<p><code>Function Templates</code>: These are templates that produce templated functions that can operate on a variety of data types.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Class Templates</code>: These produce templated classes. The Standard Template Library (STL) makes heavy use of this type of template for classes like <code>std::vector</code>, <code>std::map</code>, etc.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="comment">// ... class definition ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Variable Templates</code>: Introduced in C++14, these are templates that produce templated variables.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Alias Templates</code>: These are a way to define templated <code>typedef</code>, providing a way to simplify complex type names.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T, std::allocator&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Member Function Templates</code>: These are member functions within classes that are templated. The containing class itself may or may not be templated.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">myFunction</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... function implementation ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Template Template Parameters</code>: This advanced feature allows a template to have another template as a parameter.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">ContainerType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// ... class definition ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Non-type Template Parameters</code>: These are templates that take values (like integers, pointers, etc.) as parameters rather than types.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="type">int</span> elems[size];</span><br><span class="line">    <span class="comment">// ... class definition ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Nested Templates</code>: This refers to templates defined within another template. It’s not a different kind of template per se, but rather a feature where one template can be nested inside another.</p>
</li>
</ol>
<p><strong>Function and Class Templates</strong>: When you define a function template or a class template in a header, you’re not defining an actual function or class. Instead, you’re defining a blueprint from which actual functions or classes can be instantiated. Actual instantiations of these templates (the generated functions or classes) may end up in multiple translation units, but they’re identical and thus don’t violate the ODR. Only when these templates are instantiated do they become tangible entities in the object file. If multiple translation units include the same function or class template and instantiate it in the same way, they all will have the same instantiation, so it doesn’t break One Definition Rule (ODR).</p>
<p><strong>Variable Templates</strong>: A variable template is still a blueprint, like function and class templates. But the key difference lies in how the compiler treats template instantiations for variables versus functions/classes. For variables, the instantiation actually defines a variable. If this template is instantiated in multiple translation units, it results in multiple definitions of the same variable across those translation units, violating the ODR. Thus, for variable templates, the <code>inline</code> keyword is used to ensure that all instances of a variable template across multiple translation units are treated as a single entity, avoiding ODR violations.</p>
<h2 id="42-template-argument-type"><a class="markdownIt-Anchor" href="#42-template-argument-type"></a> 4.2 template Argument Type</h2>
<ol>
<li><code>template</code>模板</li>
<li><code>typename</code>模板</li>
<li><code>enum</code>模板</li>
<li>非类型模板，通常是整型、布尔等可以枚举的类型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span> V, <span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> E&amp; <span class="title">get_back_1</span><span class="params">(<span class="type">const</span> V&lt;E&gt;&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="keyword">typename</span> T::value_type&amp; <span class="title">get_back_2</span><span class="params">(<span class="type">const</span> T&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> I&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">get</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c[I];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">get_back_1</span>(v) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">get_back_2</span>(v) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(v) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="43-template-parameter-pack"><a class="markdownIt-Anchor" href="#43-template-parameter-pack"></a> 4.3 template Parameter Pack</h2>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/cppreference-language/5c04935094badaf1.md">C++ 语言构造参考手册-形参包</a></p>
<p><strong>模板形参包是接受零或更多模板实参（非类型、类型或模板）的模板形参。函数模板形参包是接受零或更多函数实参的函数形参</strong></p>
<p><strong>至少有一个形参包的模板被称作变参模板</strong></p>
<p><strong>模板形参包（出现于别名模版、类模板、变量模板及函数模板形参列表中）</strong></p>
<ul>
<li><code>类型 ... Args(可选)</code></li>
<li><code>typename|class ... Args(可选)</code></li>
<li><code>template &lt;形参列表&gt; typename(C++17)|class ... Args(可选)</code></li>
</ul>
<p><strong>函数参数包（声明符的一种形式，出现于变参函数模板的函数形参列表中）</strong></p>
<ul>
<li><code>Args ... args(可选)</code></li>
</ul>
<p><strong>形参包展开（出现于变参模板体中），展开成零或更多模式的逗号分隔列表。模式必须包含至少一个形参包</strong></p>
<ul>
<li><code>模式 ...</code></li>
</ul>
<h2 id="44-fold-expressions"><a class="markdownIt-Anchor" href="#44-fold-expressions"></a> 4.4 Fold Expressions</h2>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/cppreference-language/62e23cda3198622e.md">C++ 语言构造参考手册-折叠表达式</a></p>
<p><strong>格式如下：</strong></p>
<ul>
<li>一元右折叠：<code>( 形参包 op ... )</code></li>
<li>一元左折叠：<code>( ... op 形参包 )</code></li>
<li>二元右折叠：<code>( 形参包 op ... op 初值 )</code></li>
<li>二元左折叠：<code>( 初值 op ... op 形参包 )</code></li>
</ul>
<p><strong>形参包：含未展开的形参包且其顶层不含有优先级低于转型（正式而言，是 转型表达式）的运算符的表达式。说人话，就是表达式</strong></p>
<p><strong>31个合法<code>op</code>如下（二元折叠的两个<code>op</code>必须一样）：</strong></p>
<ol>
<li><code>+</code></li>
<li><code>-</code></li>
<li><code>/</code></li>
<li><code>%</code></li>
<li><code>^</code></li>
<li><code>&amp;</code></li>
<li><code>|</code></li>
<li><code>=</code></li>
<li><code>&lt;</code></li>
<li><code>&gt;</code></li>
<li><code>&lt;&lt;</code></li>
<li><code>&gt;&gt;</code></li>
<li><code>+=</code></li>
<li><code>-=</code></li>
<li><code>=</code></li>
<li><code>/=</code></li>
<li><code>%=</code></li>
<li><code>^=</code></li>
<li><code>&amp;=</code></li>
<li><code>|=</code></li>
<li><code>&lt;&lt;=</code></li>
<li><code>&gt;&gt;=</code></li>
<li><code>==</code></li>
<li><code>!=</code></li>
<li><code>&lt;=</code></li>
<li><code>&gt;=</code></li>
<li><code>&amp;&amp;</code></li>
<li><code>||</code></li>
<li><code>,</code></li>
<li><code>.</code></li>
<li><code>-&gt;</code></li>
</ol>
<p><strong>形参包折叠的示例1：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check_type</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>((std::is_same_v&lt;T, Args&gt; || ...), <span class="string">&quot;check failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check_type</span>&lt;<span class="type">int32_t</span>, <span class="type">int32_t</span>, <span class="type">int64_t</span>&gt;();</span><br><span class="line">    <span class="comment">// check_type&lt;int32_t, int8_t, int16_t&gt;();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>形参包折叠的示例2：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_contents</span><span class="params">(<span class="type">const</span> std::string&amp; path, Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    std::ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(path);</span><br><span class="line">    (ifs &gt;&gt; ... &gt;&gt; args);</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>);</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;1 2.3 5&quot;</span>;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    <span class="type">double</span> second;</span><br><span class="line">    <span class="type">int</span> third;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read_contents</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>, first, second, third);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; third &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="45-traverse-parameter-pack"><a class="markdownIt-Anchor" href="#45-traverse-parameter-pack"></a> 4.5 Traverse Parameter Pack</h2>
<h3 id="451-parenthesis-initializer"><a class="markdownIt-Anchor" href="#451-parenthesis-initializer"></a> 4.5.1 Parenthesis Initializer</h3>
<p>这里用到了一个技巧，<a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/cppreference-language/ae53223225119599.md#9bocdk">逗号运算符</a>：对于逗号表达式<code>E1, E2</code>中，对<code>E1</code>求值并舍弃其结果（尽管当它具有类类型时，直到包含它的全表达式的结尾之前都不会销毁它），其副作用在表达式<code>E2</code>的求值开始前完成</p>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> m = (++n, std::cout &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>, ++n, <span class="number">2</span> * n); <span class="comment">// 2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;m = &quot;</span> &lt;&lt; (++m, m) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;                     <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Values&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">read_contents</span><span class="params">(<span class="type">const</span> std::string&amp; path, Values&amp;... values)</span> </span>&#123;</span><br><span class="line">    std::ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> ok = ifs.<span class="built_in">good</span>();</span><br><span class="line">    <span class="keyword">auto</span> read_content = [&amp;ifs, &amp;ok](<span class="keyword">auto</span>&amp; value) &#123;</span><br><span class="line">        ok &amp;= ifs.<span class="built_in">good</span>();</span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ifs &gt;&gt; value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Either of the following two methods will work</span></span><br><span class="line">    <span class="comment">// ((read_content(values), ...));</span></span><br><span class="line">    [[maybe_unused]] <span class="type">int32_t</span> _[] = &#123;(<span class="built_in">read_content</span>(values), <span class="number">0</span>)...&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        ifs.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>);</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;1 2.3 5&quot;</span>;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> first = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">double</span> second = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> third = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">double</span> forth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_good: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">read_contents</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>, first, second, third)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, first: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, second: &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, third: &quot;</span> &lt;&lt; third &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    first = second = third = forth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_good: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">read_contents</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>, first, second, third, forth)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, first: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, second: &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, third: &quot;</span> &lt;&lt; third &lt;&lt; <span class="string">&quot;, forth=&quot;</span> &lt;&lt; forth</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    first = second = third = forth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_good: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">read_contents</span>(<span class="string">&quot;/tmp/test_wrong.txt&quot;</span>, first, second, third, forth)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, first: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, second: &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, third: &quot;</span> &lt;&lt; third &lt;&lt; <span class="string">&quot;, forth=&quot;</span> &lt;&lt; forth</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="452-constexpr-for"><a class="markdownIt-Anchor" href="#452-constexpr-for"></a> 4.5.2 constexpr for</h3>
<p>有时候，无法通过折叠表达式处理一些复杂的场景，我们希望能通过循环来挨个处理形参，示例如下（参考<a target="_blank" rel="noopener" href="https://artificial-mind.net/blog/2020/10/31/constexpr-for">Approximating ‘constexpr for’</a>）：</p>
<ul>
<li>由于需要在函数内用迭代变量进行形参包的提取，因此这个变量必须是编译期的常量，这里用<code>std::integral_constant</code>进行转换，这样在函数内，就可以用<code>std::get&lt;i&gt;</code>来提取第<code>i</code>个参数了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> Start, <span class="keyword">auto</span> End, <span class="keyword">auto</span> Inc, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">constexpr_for</span><span class="params">(F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(Start &lt; End)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">f</span>(std::<span class="built_in">integral_constant</span>&lt;<span class="keyword">decltype</span>(Start), Start&gt;());</span><br><span class="line">        <span class="built_in">constexpr_for</span>&lt;Start + Inc, End, Inc&gt;(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Values&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">read_contents</span><span class="params">(<span class="type">const</span> std::string&amp; path, Values&amp;... values)</span> </span>&#123;</span><br><span class="line">    std::ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> tvalues = std::forward_as_tuple(values...);</span><br><span class="line">    <span class="type">bool</span> ok = ifs.<span class="built_in">good</span>();</span><br><span class="line">    <span class="built_in">constexpr_for</span>&lt;<span class="number">0</span>, <span class="keyword">sizeof</span>...(values), <span class="number">1</span>&gt;([&amp;ifs, &amp;tvalues, &amp;ok](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">        ok &amp;= ifs.<span class="built_in">good</span>();</span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ifs &gt;&gt; std::<span class="built_in">get</span>&lt;i&gt;(tvalues);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        ifs.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>);</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;1 2.3 5&quot;</span>;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> first = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">double</span> second = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> third = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">double</span> forth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_good: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">read_contents</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>, first, second, third)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, first: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, second: &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, third: &quot;</span> &lt;&lt; third &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    first = second = third = forth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_good: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">read_contents</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>, first, second, third, forth)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, first: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, second: &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, third: &quot;</span> &lt;&lt; third &lt;&lt; <span class="string">&quot;, forth=&quot;</span> &lt;&lt; forth</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    first = second = third = forth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_good: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">read_contents</span>(<span class="string">&quot;/tmp/test_wrong.txt&quot;</span>, first, second, third, forth)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, first: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, second: &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, third: &quot;</span> &lt;&lt; third &lt;&lt; <span class="string">&quot;, forth=&quot;</span> &lt;&lt; forth</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="46-non-type-template-parameter"><a class="markdownIt-Anchor" href="#46-non-type-template-parameter"></a> 4.6 Non-Type template Parameter</h2>
<p>我们还可以在模板中定义非类型参数，一个非类型参数表示一个值而非一个类型。当一个模板被实例化时，非类型参数被编译器推断出的值所代替，这些值必须是常量表达式，从而允许编译器在编译时实例化模板。一个非类型参数可以是一个整型（枚举可以理解为整型），或是一个指向对象或函数类型的指针或引用</p>
<ul>
<li>绑定到非类型整型参数的实参必须是一个常量表达式</li>
<li>绑定到指针或引用非类型参数必须具有静态的生命周期</li>
<li>在模板定义内，模板非类型参数是一个常量值，在需要常量表达式的地方，可以使用非类型参数，例如指定数组大小</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">BasicType</span> &#123;</span><br><span class="line">    INT,</span><br><span class="line">    DOUBLE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;BasicType BT&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RuntimeTypeTraits</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RuntimeTypeTraits</span>&lt;INT&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RuntimeTypeTraits</span>&lt;DOUBLE&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="type">double</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译期类型推断，value的类型是int</span></span><br><span class="line">    RuntimeTypeTraits&lt;INT&gt;::Type value = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="47-when-template-parameters-cannot-be-inferred"><a class="markdownIt-Anchor" href="#47-when-template-parameters-cannot-be-inferred"></a> 4.7 When template parameters cannot be inferred</h2>
<p><strong>通常，在<code>::</code>左边的模板形参是无法进行推断的（这里的<code>::</code>特指用于连接两个类型），例如下面这个例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> T::type &amp;obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Long</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">long</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>); <span class="comment">// compile error</span></span><br><span class="line">    <span class="built_in">func</span>&lt;Int&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">func</span>&lt;Long&gt;(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="48-using-typename-to-disambiguate"><a class="markdownIt-Anchor" href="#48-using-typename-to-disambiguate"></a> 4.8 Using typename to Disambiguate</h2>
<p><strong>什么情况下会有歧义？。例如<code>foo* ptr;</code></strong></p>
<ul>
<li>若<code>foo</code>是个类型，那么该语句就是个声明语句，即定义了一个类型为<code>foo*</code>变量</li>
<li>若<code>foo</code>是个变量，那么该语句就是个表达式语句，即对<code>foo</code>以及<code>ptr</code>进行<code>*</code>运算</li>
<li>编译器无法分辨出是上述两种情况的哪一种，因此可以显式使用<code>typename</code>来告诉编译器<code>foo</code>是个类型</li>
</ul>
<p><strong>对于模板而言，例如<code>T::value_type</code>，编译器同样无法确定<code>T::value_type</code>是个类型还是不是类型。因为类作用域运算符<code>::</code>可以访问类型成员也可以访问静态成员。而编译器默认会认为<code>T::value_type</code>这种形式默认不是类型</strong></p>
<p><strong>示例1：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面这个会编译失败</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T::value_type <span class="title">sum</span><span class="params">(<span class="type">const</span> T &amp;container)</span> </span>&#123;</span><br><span class="line">    T::value_type res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;item: container) &#123;</span><br><span class="line">        res += item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上面的代码有2处错误：</strong></p>
<ol>
<li>需要用<code>typename</code>显式指定返回类型<code>T::value_type</code></li>
<li>需要用<code>typename</code>显式指定<code>res</code>的声明类型</li>
</ol>
<p><strong>修正后：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">sum</span><span class="params">(<span class="type">const</span> T &amp;container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::value_type res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;item: container) &#123;</span><br><span class="line">        res += item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="49-using-template-to-disambiguate"><a class="markdownIt-Anchor" href="#49-using-template-to-disambiguate"></a> 4.9 Using template to Disambiguate</h2>
<p><strong>什么情况下会有歧义？。例如<code>container.emplace&lt;int&gt;(1);</code></strong></p>
<ul>
<li>若<code>container.emplace</code>是个成员变量，那么<code>&lt;</code>可以理解成小于号</li>
<li>若<code>container.emplace</code>是个模板，那么<code>&lt;</code>可以理解成模板形参的括号</li>
</ul>
<p><strong>示例1：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">emplace</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;emplace value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个会编译失败</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T &amp;container)</span> </span>&#123;</span><br><span class="line">    container.<span class="built_in">emplace</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上面的代码有1处错误：</strong></p>
<ol>
<li>编译器无法确定<code>container.emplace</code>是什么含义</li>
</ol>
<p><strong>修正后：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T &amp;container)</span> </span>&#123;</span><br><span class="line">    container.<span class="keyword">template</span> <span class="built_in">emplace</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line">    <span class="keyword">using</span> container = std::vector&lt;C&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T::container&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上面的代码有1处错误：</strong></p>
<ol>
<li>编译器无法确定<code>T::container</code>是什么含义</li>
<li>需要用<code>typename</code>显式指定<code>T::container&lt;int&gt;</code>是个类型</li>
</ol>
<p><strong>修正后：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line">    <span class="keyword">using</span> container = std::vector&lt;C&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::<span class="keyword">template</span> container&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="410-defining-a-type-alias-in-a-template-parameter-list"><a class="markdownIt-Anchor" href="#410-defining-a-type-alias-in-a-template-parameter-list"></a> 4.10 Defining a type alias in a template parameter list</h2>
<p>语法上，我们是无法在template的参数列表中定义别名的（无法使用<code>using</code>）。但是我们可以通过定义有默认值的类型形参来实现类似类型别名的功能，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> HashMap, <span class="keyword">typename</span> KeyType = <span class="keyword">typename</span> HashMap::key_type,</span><br><span class="line">          <span class="keyword">typename</span> ValueType = <span class="keyword">typename</span> HashMap::mapped_type&gt;</span><br><span class="line">ValueType&amp; <span class="built_in">get</span>(HashMap&amp; map, <span class="type">const</span> KeyType&amp; key) &#123;</span><br><span class="line">    <span class="keyword">return</span> map[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="411-accessing-members-of-a-template-parent-class-from-a-non-template-derived-class"><a class="markdownIt-Anchor" href="#411-accessing-members-of-a-template-parent-class-from-a-non-template-derived-class"></a> 4.11 Accessing members of a template parent class from a non-template derived class</h2>
<ul>
<li>方式1：<code>MemberName</code></li>
<li>方式2：<code>this-&gt;MemberName</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derive</span> : Base&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_data_1</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; other)</span> </span>&#123; data = other; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_data_2</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; other)</span> </span>&#123; <span class="keyword">this</span>-&gt;data = other; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive t;</span><br><span class="line">    t.<span class="built_in">set_data_1</span>(<span class="number">1</span>);</span><br><span class="line">    t.<span class="built_in">set_data_2</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="412-accessing-members-of-a-template-parent-class-from-a-template-derived-class"><a class="markdownIt-Anchor" href="#412-accessing-members-of-a-template-parent-class-from-a-template-derived-class"></a> 4.12 Accessing members of a template parent class from a template derived class</h2>
<ul>
<li>访问方式1：<code>ParentClass&lt;Template Args...&gt;::MemberName</code></li>
<li>访问方式2：<code>this-&gt;MemberName</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derive</span> : Base&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_data_1</span><span class="params">(<span class="type">const</span> T&amp; data)</span> </span>&#123; Base&lt;T&gt;::data = data; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_data_2</span><span class="params">(<span class="type">const</span> T&amp; data)</span> </span>&#123; <span class="keyword">this</span>-&gt;data = data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    t.<span class="built_in">set_data_1</span>(<span class="number">5</span>);</span><br><span class="line">    t.<span class="built_in">set_data_2</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="413-template-as-a-template-parameter"><a class="markdownIt-Anchor" href="#413-template-as-a-template-parameter"></a> 4.13 template as a template Parameter</h2>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/213761/what-are-some-uses-of-template-template-parameters">What are some uses of template template parameters?</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">typename</span> V, <span class="keyword">typename</span> T, <span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_last_value</span><span class="params">(V&lt;T, A&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> T&amp; value = v.<span class="built_in">back</span>();</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span> V, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_type</span><span class="params">(<span class="type">const</span> V&lt;T&gt;&amp; value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;V&lt;T&gt;&#x27;s type=&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(V&lt;T&gt;).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;T&#x27;s type=&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">print_last_value</span>(v);</span><br><span class="line">    <span class="built_in">print_type</span>(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="414-separating-the-definition-and-implementation-of-a-template"><a class="markdownIt-Anchor" href="#414-separating-the-definition-and-implementation-of-a-template"></a> 4.14 Separating the definition and implementation of a template</h2>
<p>我们可以将模板的声明和定义分别放在两个文件中，这样可以使得代码结构更加清晰。例如，假设有两个文件<code>test.h</code>和<code>test.tpp</code>，其内容分别如下：</p>
<ul>
<li>
<p><code>test.h</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.tpp&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>test.tpp</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Demo&lt;T&gt;::<span class="built_in">func</span>() &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，<code>test.h</code>在追后引用了<code>test.tpp</code>，这样其他模块只需要引用<code>test.h</code>即可，整个模板的定义也可以通过<code>test.h</code>一个文件清晰地看到。但是，这里存在一个问题，如果我们用<code>vscode</code>或者<code>vim</code>的<code>lsp</code>插件来阅读编辑<code>test.tpp</code>文件时，会发现存在语法问题，因为<code>test.tpp</code>本身并不完整，无法进行编译</p>
<p>参考<a target="_blank" rel="noopener" href="https://github.com/StarRocks/starrocks/pull/15330">[BugFix] Fix the problem of null aware anti join</a>我们可以通过一个小技巧来解决这个问题，我们将<code>test.h</code>和<code>test.tpp</code>进行如下修改：</p>
<ul>
<li>
<p><code>test.h</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEST_TPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.tpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> TEST_H</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>test.tpp</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_TPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Demo&lt;T&gt;::<span class="built_in">func</span>() &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> TEST_TPP</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样，在独立编辑这两个文件时，<code>lsp</code>都可以正常工作，也不会造成循环引用的问题</p>
<p><code>clangd</code>在没有<code>compile_commands.json</code>文件时，处理单独的<code>tpp</code>文件会报错，错误信息是：<code>Unable to handle compilation, expected exactly one compiler job in ''</code></p>
<h2 id="415-crtp"><a class="markdownIt-Anchor" href="#415-crtp"></a> 4.15 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a></h2>
<p><code>CRTP</code>的全称是<code>Curious Recurring Template Pattern</code></p>
<h3 id="4151-static-polymorphism"><a class="markdownIt-Anchor" href="#4151-static-polymorphism"></a> 4.15.1 Static Polymorphism</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">interface</span><span class="params">()</span> </span>&#123; <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">implementation</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_func</span><span class="params">()</span> </span>&#123; T::<span class="built_in">static_sub_func</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base&lt;Derived&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">implementation</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::implementation&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_sub_func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Dericed::static_sub_func&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">interface</span>();</span><br><span class="line">    Derived::<span class="built_in">static_func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4152-object-counter"><a class="markdownIt-Anchor" href="#4152-object-counter"></a> 4.15.2 Object Counter</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">counter</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> objects_created = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> objects_alive = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">counter</span>() &#123;</span><br><span class="line">        ++objects_created;</span><br><span class="line">        ++objects_alive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">counter</span>(<span class="type">const</span> counter&amp;) &#123;</span><br><span class="line">        ++objects_created;</span><br><span class="line">        ++objects_alive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ~<span class="built_in">counter</span>() <span class="comment">// objects should never be removed through pointers of this type</span></span><br><span class="line">    &#123;</span><br><span class="line">        --objects_alive;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> : <span class="keyword">public</span> counter&lt;X&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(expr) std::cout &lt;&lt; #expr &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; expr &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        X x;</span><br><span class="line">        <span class="built_in">PRINT</span>(X::objects_created);</span><br><span class="line">        <span class="built_in">PRINT</span>(X::objects_alive);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PRINT</span>(X::objects_created);</span><br><span class="line">    <span class="built_in">PRINT</span>(X::objects_alive);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4153-polymorphic-chaining"><a class="markdownIt-Anchor" href="#4153-polymorphic-chaining"></a> 4.15.3 Polymorphic Chaining</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; red, green, yello, blue, white, black &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlainPrinter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PlainPrinter</span>(std::ostream&amp; pstream) : <span class="built_in">m_stream</span>(pstream) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">PlainPrinter&amp; <span class="title">print</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">        m_stream &lt;&lt; t;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">PlainPrinter&amp; <span class="title">println</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">        m_stream &lt;&lt; t &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::ostream&amp; m_stream;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlainCoutPrinter</span> : <span class="keyword">public</span> PlainPrinter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PlainCoutPrinter</span>() : <span class="built_in">PlainPrinter</span>(std::cout) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">PlainCoutPrinter&amp; <span class="title">SetConsoleColor</span><span class="params">(Color c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something to change color</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConcretePrinter&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Printer</span>(std::ostream&amp; pstream) : <span class="built_in">m_stream</span>(pstream) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">ConcretePrinter&amp; <span class="title">print</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">        m_stream &lt;&lt; t;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ConcretePrinter&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">ConcretePrinter&amp; <span class="title">println</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">        m_stream &lt;&lt; t &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ConcretePrinter&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::ostream&amp; m_stream;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoutPrinter</span> : <span class="keyword">public</span> Printer&lt;CoutPrinter&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CoutPrinter</span>() : <span class="built_in">Printer</span>(std::cout) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CoutPrinter&amp; <span class="title">SetConsoleColor</span><span class="params">(Color c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// PlainCoutPrinter().print(&quot;Hello &quot;).SetConsoleColor(Color::red).println(&quot;Printer!&quot;); // compile error</span></span><br><span class="line">    <span class="built_in">CoutPrinter</span>().<span class="built_in">print</span>(<span class="string">&quot;Hello &quot;</span>).<span class="built_in">SetConsoleColor</span>(Color::red).<span class="built_in">println</span>(<span class="string">&quot;Printer!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>PlainCoutPrinter().print(&quot;Hello &quot;)</code>的返回类型是<code>PlainPrinter</code>，丢失了具体的<code>PlainCoutPrinter</code>类型信息，于是再调用<code>SetConsoleColor</code>就报错了</li>
<li>而使用<code>CRTP</code>就可以避免这个问题，基类的方法返回类型永远是具体的子类</li>
</ul>
<h3 id="4154-polymorphic-copy-construction"><a class="markdownIt-Anchor" href="#4154-polymorphic-copy-construction"></a> 4.15.4 Polymorphic Copy Construction</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Base class has a pure virtual function for cloning</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractShape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractShape</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;AbstractShape&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This CRTP class implements clone() for Derived</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> : <span class="keyword">public</span> AbstractShape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;AbstractShape&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Derived&gt;(<span class="built_in">static_cast</span>&lt;Derived <span class="type">const</span>&amp;&gt;(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// We make clear Shape class needs to be inherited</span></span><br><span class="line">    <span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">const</span> Shape&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Shape</span>(Shape&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Every derived class inherits from CRTP class instead of abstract class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape&lt;Square&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape&lt;Circle&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Square s;</span><br><span class="line">    <span class="keyword">auto</span> clone = s.<span class="built_in">clone</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="416-pimpl"><a class="markdownIt-Anchor" href="#416-pimpl"></a> 4.16 PIMPL</h2>
<p>In C++, the term <code>pimpl</code> is short for <code>pointer to implementation</code> or <code>private implementation</code>. It’s an idiom used to separate the public interface of a class from its implementation details. This helps improve code modularity, encapsulation, and reduces compile-time dependencies.</p>
<p>Here’s how the pimpl idiom works:</p>
<ol>
<li><strong>Public Interface</strong>: You define a class in your header file (<code>.h</code> or <code>.hpp</code>) that contains only the public interface members (public functions, typedefs, etc.). This header file should include minimal implementation details to keep the interface clean and focused.</li>
<li><strong>Private Implementation</strong>: In the implementation file (<code>.cpp</code>), you declare a private class that holds the actual implementation details of your class. This private class is typically defined within an anonymous namespace or as a private nested class of the original class. The private class contains private data members, private functions, and any other implementation-specific details.</li>
<li><strong>Pointer to Implementation</strong>: Within the main class, you include a pointer to the private implementation class. The public functions in the main class forward calls to the corresponding functions in the private implementation class.</li>
</ol>
<p>By using the pimpl idiom, you achieve several benefits:</p>
<ul>
<li>Reduces compile-time dependencies: Changes to the private implementation do not require recompilation of the public interface, reducing compilation times.</li>
<li>Enhances encapsulation: Clients of the class only need to know about the public interface, shielding them from implementation details.</li>
<li>Minimizes header dependencies: Since the private implementation is not exposed in the header, you avoid leaking implementation details to client code.</li>
<li>Eases binary compatibility: Changing the private implementation does not require recompiling or re-linking client code, as long as the public interface remains unchanged.</li>
</ul>
<p>Here’s a simplified example of the pimpl idiom:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Widget.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Impl</span>; <span class="comment">// Forward declaration of the private implementation class</span></span><br><span class="line">    Impl* pImpl; <span class="comment">// Pointer to the private implementation</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>::Impl &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PerformAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implementation details</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() : <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">Impl</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> pImpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DoSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pImpl-&gt;<span class="built_in">PerformAction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-memory-model"><a class="markdownIt-Anchor" href="#5-memory-model"></a> 5 Memory Model</h1>
<h2 id="51-concepts"><a class="markdownIt-Anchor" href="#51-concepts"></a> 5.1 Concepts</h2>
<h3 id="511-cache-coherence-memory-consistency"><a class="markdownIt-Anchor" href="#511-cache-coherence-memory-consistency"></a> 5.1.1 Cache coherence &amp; Memory consistency</h3>
<p>Cache coherence and memory consistency are two fundamental concepts in parallel computing systems, but they address different issues:</p>
<p><strong>Cache Coherence</strong>:</p>
<ul>
<li><strong>This concept is primarily concerned with the values of copies of a single memory location that are cached at several caches (typically, in a multiprocessor system)</strong>. When multiple processors with separate caches are in a system, it’s possible for those caches to hold copies of the same memory location. <strong>Cache coherence ensures that all processors in the system observe a single, consistent value for the memory location</strong>. It focuses on maintaining a global order in which writes to each individual memory location occur.</li>
<li>For example, suppose we have two processors P1 and P2, each with its own cache. If P1 changes the value of a memory location X that’s also stored in P2’s cache, the cache coherence protocols will ensure that P2 sees the updated value if it tries to read X.</li>
</ul>
<p><strong>Memory Consistency</strong>:</p>
<ul>
<li>While cache coherence is concerned with the view of a single memory location, <strong>memory consistency is concerned about the ordering of multiply updates to different memory locations(or single memory location) from different processors. It determines when a write by one processor to a shared memory location becomes visible to all other processors.</strong></li>
<li>A memory consistency model defines the architecturally visible behavior of a memory system. Different consistency models make different guarantees about the order and visibility of memory operations across different threads or processors. For example, sequential consistency, a strict type of memory consistency model, says that all memory operations must appear to execute in some sequential order that’s consistent with the program order of each individual processor.</li>
</ul>
<p>In summary, while both are essential for correctness in multiprocessor systems, cache coherence deals with maintaining a consistent view of a single memory location, while memory consistency is concerned with the order and visibility of updates to different memory locations.</p>
<h3 id="512-happens-before"><a class="markdownIt-Anchor" href="#512-happens-before"></a> 5.1.2 Happens-before</h3>
<p>If an operation A “happens-before” another operation B, it means that A is guaranteed to be observed by B. In other words, any data or side effects produced by A will be visible to B when it executes.</p>
<p><img src="/images/Cpp-Language/happens-before.png" alt="happens-before" /></p>
<h2 id="52-memory-consistency-model"><a class="markdownIt-Anchor" href="#52-memory-consistency-model"></a> 5.2 Memory consistency model</h2>
<h3 id="521-sequential-consistency-model"><a class="markdownIt-Anchor" href="#521-sequential-consistency-model"></a> 5.2.1 Sequential consistency model</h3>
<blockquote>
<p>the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program</p>
</blockquote>
<p><strong><code>Sequential consistency model (SC)</code></strong>, also known as the sequential consistency model, essentially stipulates two things:</p>
<ol>
<li><strong>Each thread’s instructions are executed in the order specified by the program (from the perspective of a single thread)</strong></li>
<li><strong>The interleaving order of thread execution can be arbitrary, but the overall execution order of the entire program, as observed by all threads, must be the same (from the perspective of the entire program)</strong>
<ul>
<li>That is, there should not be a situation where for write operations <code>W1</code> and <code>W2</code>, processor 1 sees the order as: <code>W1 -&gt; W2</code>; while processor 2 sees the order as: <code>W2 -&gt; W1</code></li>
</ul>
</li>
</ol>
<h3 id="522-relaxed-consistency-model"><a class="markdownIt-Anchor" href="#522-relaxed-consistency-model"></a> 5.2.2 Relaxed consistency model</h3>
<p><strong><code>Relaxed consistency model</code> also known as the loose memory consistency model, is characterized by:</strong></p>
<ol>
<li><strong>Within the same thread, access to the same atomic variable cannot be reordered (from the perspective of a single thread)</strong></li>
<li><strong>Apart from ensuring the atomicity of operations, there is no stipulation on the order of preceding and subsequent instructions, and the order in which other threads observe data changes may also be different (from the perspective of the entire program)</strong>
<ul>
<li>That is, different threads may observe the relaxed operations on a single atomic value in different orders.</li>
</ul>
</li>
</ol>
<p><strong>Looseness can be measured along the following two dimensions:</strong></p>
<ul>
<li>How to relax the requirements of program order. Typically, this refers to the read and write operations of different variables; for the same variable, read and write operations cannot be reordered. Program order requirements include:
<ul>
<li><code>read-read</code></li>
<li><code>read-write</code></li>
<li><code>write-read</code></li>
<li><code>write-write</code></li>
</ul>
</li>
<li>How they relax the requirements for write atomicity. Models are differentiated based on whether they allow a read operation to return the written value of another processor before all cache copies have received the invalidation or update message produced by the write; in other words, allowing a processor to read the written value before the write is visible to all other processors.</li>
</ul>
<p><strong>Through these two dimensions, the following relaxed strategies have been introduced:</strong></p>
<ul>
<li>Relaxing the <code>write-read</code> program order. Supported by <code>TSO</code> (Total Store Order)</li>
<li>Relaxing the <code>write-write</code> program order</li>
<li>Relaxing the <code>read-read</code> and <code>read-write</code> program order</li>
<li>Allowing early reads of values written by other processors</li>
<li>Allowing early reads of values written by the current processor</li>
</ul>
<h3 id="523-total-store-order"><a class="markdownIt-Anchor" href="#523-total-store-order"></a> 5.2.3 Total Store Order</h3>
<p>otal Store Order (TSO) is a type of memory consistency model used in computer architecture to manage how memory operations (reads and writes) are ordered and observed by different parts of the system.</p>
<p>In a Total Store Order model:</p>
<ul>
<li><strong>Writes are not immediately visible to all processors</strong>: When a processor writes to memory, that write is not instantly visible to all other processors. There’s a delay because writes are first written to a store buffer unique to each processor.</li>
<li><strong>Writes are seen in order</strong>: Even though there’s a delay in visibility, writes to the memory are seen by all processors in the same order. This is the “total order” part of TSO, which means that if Processor A sees Write X followed by Write Y, Processor B will also see Write X before Write Y.</li>
<li><strong>Reads may bypass writes</strong>: If a processor reads a location that it has just written to, it may get the value from its store buffer (the most recent write) rather than the value that is currently in memory. This means a processor can see its writes immediately but may not see writes from other processors that happened after its own write.</li>
<li><strong>Writes from a single processor are seen in the order issued</strong>: Writes by a single processor are observed in the order they were issued by that processor. If Processor A writes to memory location X and then to memory location Y, all processors will see the write to X happen before the write to Y.</li>
</ul>
<p>This model is a compromise between strict ordering and performance. In a system that enforces strict ordering (like Sequential Consistency), every operation appears to happen in a strict sequence, which can be quite slow. TSO allows some operations to be reordered (like reads happening before a write is visible to all) for better performance while still maintaining a predictable order for writes, which is critical for correctness in many concurrent algorithms.</p>
<p>TSO is commonly used in x86 processors, which strikes a balance between the predictable behavior needed for programming ease and the relaxed rules that allow for high performance in practice.</p>
<h2 id="53-stdmemory_order"><a class="markdownIt-Anchor" href="#53-stdmemory_order"></a> 5.3 std::memory_order</h2>
<ol>
<li><code>std::memory_order_seq_cst</code>: <strong>Provide happens-before relationship.</strong></li>
<li><code>std::memory_order_relaxed</code>: <strong>CAN NOT Provide happens-before relationship.</strong> Which specific relaxation strategies are adopted must be determined based on the hardware platform.
<ul>
<li>When you use <code>std::memory_order_relaxed</code>, it guarantees the following:
<ol>
<li>Sequential consistency for atomic operations on a single variable: If you perform multiple atomic operations on the same atomic variable using <code>std::memory_order_relaxed</code>, the result will be as if those operations were executed in some sequential order. This means that the final value observed by any thread will be a valid result based on the ordering of the operations.</li>
<li>Coherence: All threads will eventually observe the most recent value written to an atomic variable. However, the timing of when each thread observes the value may differ due to the relaxed ordering.</li>
<li>Atomicity: Atomic operations performed with <code>std::memory_order_relaxed</code> are indivisible. They are guaranteed to be performed without interruption or interference from other threads.</li>
</ol>
</li>
</ul>
</li>
<li><code>std::memory_order_acquire</code> and <code>std::memory_order_release</code>: <strong>Provide happens-before relationship.</strong>
<ul>
<li>When used together, <code>std::memory_order_acquire</code> and <code>std::memory_order_release</code> can establish a happens-before relationship between threads, allowing for proper synchronization and communication between them
<ol>
<li><code>std::memory_order_acquire</code> is a memory ordering constraint that provides acquire semantics. It ensures that any memory operations that occur before the acquire operation in the program order will be visible to the thread performing the acquire operation.</li>
<li><code>std::memory_order_release</code> is a memory ordering constraint that provides release semantics. It ensures that any memory operations that occur after the release operation in the program order will be visible to other threads that perform subsequent acquire operations.</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="54-cases"><a class="markdownIt-Anchor" href="#54-cases"></a> 5.4 Cases</h2>
<h3 id="541-case-1-happens-before"><a class="markdownIt-Anchor" href="#541-case-1-happens-before"></a> 5.4.1 Case-1-happens-before</h3>
<p>happens-before在不同<code>std::memory_order</code>下的规则</p>
<ul>
<li><code>std::memory_order_seq_cst</code>
<ul>
<li>normal-write happens-before atomic-write</li>
<li>atomic-read happens-before normal-read</li>
<li>atomic-write happens-before atomic-read</li>
<li>可以推导出：normal-write happens-before normal-read</li>
</ul>
</li>
<li><code>std::memory_order_relaxed</code>
<ul>
<li>normal-write happens-before atomic-write</li>
<li>atomic-read happens-before normal-read</li>
<li>无法推导出：normal-write happens-before normal-read</li>
</ul>
</li>
</ul>
<p>下面的程序：</p>
<ul>
<li><code>test_atomic_visibility&lt;std::memory_order_seq_cst&gt;();</code>可以正确执行</li>
<li><code>test_atomic_visibility&lt;std::memory_order_relaxed&gt;();</code>也可以正确执行。因为x86是<code>TSO</code>模型，<code>std::memory_order_relaxed</code>同样满足<code>atomic-write happens-before atomic-read</code>规则</li>
<li><code>test_volatile_visibility</code>会报错，因为<code>volatile</code>不提供同步语义，对重排没有限制</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> INVALID_VALUE = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> EXPECTED_VALUE = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> TIMES = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> data;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">atomic_data_ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="type">bool</span> <span class="title">volatile_data_ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order read_order, std::memory_order write_order&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_atomic_happens_before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> reader_thread = []() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="comment">// atomic read</span></span><br><span class="line">            <span class="keyword">while</span> (!atomic_data_ready.<span class="built_in">load</span>(read_order))</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// normal read: atomic read happens-before normal read</span></span><br><span class="line">            <span class="built_in">assert</span>(data == EXPECTED_VALUE);</span><br><span class="line"></span><br><span class="line">            data = INVALID_VALUE;</span><br><span class="line">            atomic_data_ready.<span class="built_in">store</span>(<span class="literal">false</span>, write_order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> writer_thread = []() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (atomic_data_ready.<span class="built_in">load</span>(read_order))</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// normal write</span></span><br><span class="line">            data = EXPECTED_VALUE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// atomic write: normal write happens-before atomic write</span></span><br><span class="line">            atomic_data_ready.<span class="built_in">store</span>(<span class="literal">true</span>, write_order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    data = INVALID_VALUE;</span><br><span class="line">    atomic_data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(reader_thread)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(writer_thread)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_volatile_happens_before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> reader_thread = []() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!volatile_data_ready)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">assert</span>(data == EXPECTED_VALUE);</span><br><span class="line"></span><br><span class="line">            data = INVALID_VALUE;</span><br><span class="line">            volatile_data_ready = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> writer_thread = []() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (volatile_data_ready)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            data = EXPECTED_VALUE;</span><br><span class="line"></span><br><span class="line">            volatile_data_ready = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    data = INVALID_VALUE;</span><br><span class="line">    volatile_data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(reader_thread)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(writer_thread)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_atomic_happens_before</span>&lt;std::memory_order_seq_cst, std::memory_order_seq_cst&gt;();</span><br><span class="line">    <span class="built_in">test_atomic_happens_before</span>&lt;std::memory_order_acquire, std::memory_order_release&gt;();</span><br><span class="line">    <span class="built_in">test_atomic_happens_before</span>&lt;std::memory_order_relaxed, std::memory_order_relaxed&gt;();</span><br><span class="line">    <span class="built_in">test_volatile_happens_before</span>(); <span class="comment">// Failed assertion</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="542-case-2-write-read-reorder"><a class="markdownIt-Anchor" href="#542-case-2-write-read-reorder"></a> 5.4.2 Case-2-write-read-reorder</h3>
<p>来自<a href="/resources/paper/Shared-Memory-Consistency-Models-A-Tutorial.pdf">Shared Memory Consistency Models: A Tutorial</a>中的<code>Figure-5(a)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> TIMES = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order read_order, std::memory_order write_order&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test_reorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// control vars</span></span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">control</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">stop</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">success</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; finished_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> round_process = [&amp;control, &amp;stop, &amp;finished_num](<span class="keyword">auto</span>&amp;&amp; process) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="comment">// make t1 and t2 go through synchronously</span></span><br><span class="line">            finished_num++;</span><br><span class="line">            <span class="keyword">while</span> (!stop &amp;&amp; !control)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">process</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait for next round</span></span><br><span class="line">            finished_num++;</span><br><span class="line">            <span class="keyword">while</span> (!stop &amp;&amp; control)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> control_process = [&amp;control, &amp;success, &amp;finished_num](<span class="keyword">auto</span>&amp;&amp; clean_process, <span class="keyword">auto</span>&amp;&amp; check_process) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="comment">// wait t1 and t2 at the top of the loop</span></span><br><span class="line">            <span class="keyword">while</span> (finished_num != <span class="number">2</span>)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// clean up data</span></span><br><span class="line">            finished_num = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">clean_process</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// let t1 and t2 go start</span></span><br><span class="line">            control = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait t1 and t2 finishing write operation</span></span><br><span class="line">            <span class="keyword">while</span> (finished_num != <span class="number">2</span>)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check assumption</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check_process</span>()) &#123;</span><br><span class="line">                success = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            finished_num = <span class="number">0</span>;</span><br><span class="line">            control = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main vars</span></span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; flag1, flag2;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; critical_num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> process_1 = [&amp;flag1, &amp;flag2, &amp;critical_num]() &#123;</span><br><span class="line">        flag1.<span class="built_in">store</span>(<span class="number">1</span>, write_order);</span><br><span class="line">        <span class="keyword">if</span> (flag2.<span class="built_in">load</span>(read_order) == <span class="number">0</span>) &#123;</span><br><span class="line">            critical_num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> process_2 = [&amp;flag1, &amp;flag2, &amp;critical_num]() &#123;</span><br><span class="line">        flag2.<span class="built_in">store</span>(<span class="number">1</span>, write_order);</span><br><span class="line">        <span class="keyword">if</span> (flag1.<span class="built_in">load</span>(read_order) == <span class="number">0</span>) &#123;</span><br><span class="line">            critical_num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> clean_process = [&amp;flag1, &amp;flag2, &amp;critical_num]() &#123;</span><br><span class="line">        flag1 = <span class="number">0</span>;</span><br><span class="line">        flag2 = <span class="number">0</span>;</span><br><span class="line">        critical_num = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> check_process = [&amp;critical_num]() &#123; <span class="keyword">return</span> critical_num &lt;= <span class="number">1</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t_1</span><span class="params">(round_process, process_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_2</span><span class="params">(round_process, process_2)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_control</span><span class="params">(control_process, clean_process, check_process)</span></span>;</span><br><span class="line"></span><br><span class="line">    t_control.<span class="built_in">join</span>();</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t_1.<span class="built_in">join</span>();</span><br><span class="line">    t_2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> res;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_seq_cst, std::memory_order_seq_cst&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_seq_cst, std::memory_order_seq_cst&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_acquire, std::memory_order_release&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_acquire, std::memory_order_release&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_relaxed, std::memory_order_relaxed&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_relaxed, std::memory_order_relaxed&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>x86</code>平台（<code>TSO</code>），结果如下，只有<code>memory_order_seq_cst</code>能保证一致性，而<code>memory_order_acquire/memory_order_release</code>仅针对同一变量，不同变量的<code>Write-Read</code>仍然可能重排</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test std::memory_order_seq_cst, std::memory_order_seq_cst, res=true</span><br><span class="line">test std::memory_order_acquire, std::memory_order_release, res=false</span><br><span class="line">test std::memory_order_relaxed, std::memory_order_relaxed, res=false</span><br></pre></td></tr></table></figure>
<h3 id="543-case-3-write-write-read-read-reorder"><a class="markdownIt-Anchor" href="#543-case-3-write-write-read-read-reorder"></a> 5.4.3 Case-3-write-write-read-read-reorder</h3>
<p>来自<a href="/resources/paper/Shared-Memory-Consistency-Models-A-Tutorial.pdf">Shared Memory Consistency Models: A Tutorial</a>中的<code>Figure-5(b)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> TIMES = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order read_order, std::memory_order write_order&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test_reorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// control vars</span></span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">control</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">stop</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">success</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; finished_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> round_process = [&amp;control, &amp;stop, &amp;finished_num](<span class="keyword">auto</span>&amp;&amp; process) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="comment">// make t1 and t2 go through synchronously</span></span><br><span class="line">            finished_num++;</span><br><span class="line">            <span class="keyword">while</span> (!stop &amp;&amp; !control)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">process</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait for next round</span></span><br><span class="line">            finished_num++;</span><br><span class="line">            <span class="keyword">while</span> (!stop &amp;&amp; control)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> control_process = [&amp;control, &amp;success, &amp;finished_num](<span class="keyword">auto</span>&amp;&amp; clean_process, <span class="keyword">auto</span>&amp;&amp; check_process) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="comment">// wait t1 and t2 at the top of the loop</span></span><br><span class="line">            <span class="keyword">while</span> (finished_num != <span class="number">2</span>)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// clean up data</span></span><br><span class="line">            finished_num = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">clean_process</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// let t1 and t2 go start</span></span><br><span class="line">            control = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait t1 and t2 finishing write operation</span></span><br><span class="line">            <span class="keyword">while</span> (finished_num != <span class="number">2</span>)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check assumption</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check_process</span>()) &#123;</span><br><span class="line">                success = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            finished_num = <span class="number">0</span>;</span><br><span class="line">            control = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main vars</span></span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; data;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; head;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; read_val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> process_1 = [&amp;data, &amp;head]() &#123;</span><br><span class="line">        data.<span class="built_in">store</span>(<span class="number">2000</span>, write_order);</span><br><span class="line">        head.<span class="built_in">store</span>(<span class="number">1</span>, write_order);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> process_2 = [&amp;data, &amp;head, &amp;read_val]() &#123;</span><br><span class="line">        <span class="keyword">while</span> (head.<span class="built_in">load</span>(read_order) == <span class="number">0</span>)</span><br><span class="line">            ;</span><br><span class="line">        read_val = data.<span class="built_in">load</span>(read_order);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> clean_process = [&amp;data, &amp;head, &amp;read_val]() &#123;</span><br><span class="line">        data = <span class="number">0</span>;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        read_val = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> check_process = [&amp;read_val]() &#123; <span class="keyword">return</span> read_val == <span class="number">2000</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t_1</span><span class="params">(round_process, process_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_2</span><span class="params">(round_process, process_2)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_control</span><span class="params">(control_process, clean_process, check_process)</span></span>;</span><br><span class="line"></span><br><span class="line">    t_control.<span class="built_in">join</span>();</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t_1.<span class="built_in">join</span>();</span><br><span class="line">    t_2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> res;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_seq_cst, std::memory_order_seq_cst&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_seq_cst, std::memory_order_seq_cst&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_acquire, std::memory_order_release&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_acquire, std::memory_order_release&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_relaxed, std::memory_order_relaxed&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_relaxed, std::memory_order_relaxed&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>x86</code>平台（<code>TSO</code>），<code>Relaxed Consistency Model</code>不允许<code>Write-Write</code>以及<code>Read-Read</code>重排，结果如下（对于其他具有不同内存模型的硬件平台，由于对<code>Relaxed</code>的支持程度不同，可能会有不同的结果）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test std::memory_order_seq_cst, std::memory_order_seq_cst, res=true</span><br><span class="line">test std::memory_order_acquire, std::memory_order_release, res=true</span><br><span class="line">test std::memory_order_relaxed, std::memory_order_relaxed, res=true</span><br></pre></td></tr></table></figure>
<h3 id="544-case-4-write-order-consistency"><a class="markdownIt-Anchor" href="#544-case-4-write-order-consistency"></a> 5.4.4 Case-4-write-order-consistency</h3>
<p>来自<a href="/resources/paper/Shared-Memory-Consistency-Models-A-Tutorial.pdf">Shared Memory Consistency Models: A Tutorial</a>中的<code>Figure-10(b)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> TIMES = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order read_order, std::memory_order write_order&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test_reorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// control vars</span></span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">control</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">stop</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">success</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; finished_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> round_process = [&amp;control, &amp;stop, &amp;finished_num](<span class="keyword">auto</span>&amp;&amp; process) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="comment">// make t1 and t2 go through synchronously</span></span><br><span class="line">            finished_num++;</span><br><span class="line">            <span class="keyword">while</span> (!stop &amp;&amp; !control)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">process</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait for next round</span></span><br><span class="line">            finished_num++;</span><br><span class="line">            <span class="keyword">while</span> (!stop &amp;&amp; control)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> control_process = [&amp;control, &amp;success, &amp;finished_num](<span class="keyword">auto</span>&amp;&amp; clean_process, <span class="keyword">auto</span>&amp;&amp; check_process) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="comment">// wait t1, t2 and t3 at the top of the loop</span></span><br><span class="line">            <span class="keyword">while</span> (finished_num != <span class="number">3</span>)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// clean up data</span></span><br><span class="line">            finished_num = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">clean_process</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// let t1, t2 and t3 go start</span></span><br><span class="line">            control = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait t1, t2 and t3 finishing write operation</span></span><br><span class="line">            <span class="keyword">while</span> (finished_num != <span class="number">3</span>)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check assumption</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check_process</span>()) &#123;</span><br><span class="line">                success = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            finished_num = <span class="number">0</span>;</span><br><span class="line">            control = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main vars</span></span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; a;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; b;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; reg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> process_1 = [&amp;a]() &#123; a.<span class="built_in">store</span>(<span class="number">1</span>, write_order); &#125;;</span><br><span class="line">    <span class="keyword">auto</span> process_2 = [&amp;a, &amp;b]() &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">load</span>(read_order) == <span class="number">1</span>) &#123;</span><br><span class="line">            b.<span class="built_in">store</span>(<span class="number">1</span>, write_order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> process_3 = [&amp;a, &amp;b, &amp;reg]() &#123;</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">load</span>(read_order) == <span class="number">1</span>) &#123;</span><br><span class="line">            reg.<span class="built_in">store</span>(a.<span class="built_in">load</span>(read_order), write_order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> clean_process = [&amp;a, &amp;b, &amp;reg]() &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">        b = <span class="number">0</span>;</span><br><span class="line">        reg = <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> check_process = [&amp;reg]() &#123; <span class="keyword">return</span> reg != <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t_1</span><span class="params">(round_process, process_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_2</span><span class="params">(round_process, process_2)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_3</span><span class="params">(round_process, process_3)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_control</span><span class="params">(control_process, clean_process, check_process)</span></span>;</span><br><span class="line"></span><br><span class="line">    t_control.<span class="built_in">join</span>();</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t_1.<span class="built_in">join</span>();</span><br><span class="line">    t_2.<span class="built_in">join</span>();</span><br><span class="line">    t_3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> res;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_seq_cst, std::memory_order_seq_cst&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_seq_cst, std::memory_order_seq_cst&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_acquire, std::memory_order_release&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_acquire, std::memory_order_release&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_relaxed, std::memory_order_relaxed&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_relaxed, std::memory_order_relaxed&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>x86</code>平台（<code>TSO</code>），<code>Relaxed Consistency Model</code>要求所有核看到的<code>Write</code>顺序是一致的，结果如下（对于其他具有不同内存模型的硬件平台，由于对<code>Relaxed</code>的支持程度不同，可能会有不同的结果）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test std::memory_order_seq_cst, std::memory_order_seq_cst, res=true</span><br><span class="line">test std::memory_order_acquire, std::memory_order_release, res=true</span><br><span class="line">test std::memory_order_relaxed, std::memory_order_relaxed, res=true</span><br></pre></td></tr></table></figure>
<h3 id="545-case-5-visibility"><a class="markdownIt-Anchor" href="#545-case-5-visibility"></a> 5.4.5 Case-5-visibility</h3>
<p>进程调度也能保证可见性，我们可以让读写线程绑定到某个核上，那么读写线程会在调度的作用下交替执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> use_inc&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_concurrent_visibility</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> TIMES = <span class="number">1000000</span>;</span><br><span class="line">    T count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [&amp;count]() &#123;</span><br><span class="line">        <span class="type">pthread_t</span> thread = <span class="built_in">pthread_self</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line">        <span class="built_in">CPU_ZERO</span>(&amp;cpuset);</span><br><span class="line">        <span class="built_in">CPU_SET</span>(<span class="number">0</span>, &amp;cpuset);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_setaffinity_np</span>(thread, <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_getaffinity_np</span>(thread, <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(use_inc)</span> </span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count = count + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;T, <span class="type">int32_t</span>&gt;)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;type=int32_t, count=&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="keyword">volatile</span> <span class="type">int32_t</span>&gt;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;type=volatile int32_t, count=&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, std::atomic&lt;<span class="type">int32_t</span>&gt;&gt;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;type=std::atomic&lt;int32_t&gt;, count=&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_concurrent_visibility</span>&lt;<span class="type">int32_t</span>, <span class="literal">true</span>&gt;();</span><br><span class="line">    <span class="built_in">test_concurrent_visibility</span>&lt;<span class="keyword">volatile</span> <span class="type">int32_t</span>, <span class="literal">false</span>&gt;();</span><br><span class="line">    test_concurrent_visibility&lt;std::atomic&lt;<span class="type">int32_t</span>&gt;, <span class="literal">true</span>&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type=int32_t, count=2000000</span><br><span class="line">type=volatile int32_t, count=2000000</span><br><span class="line">type=std::atomic&lt;int32_t&gt;, count=2000000</span><br></pre></td></tr></table></figure>
<h3 id="546-case-6-eventual-consistency"><a class="markdownIt-Anchor" href="#546-case-6-eventual-consistency"></a> 5.4.6 Case-6-eventual-consistency</h3>
<p>不同的原子操作，虽然无法保证同步语义，但是可以保证变量的最终一致性</p>
<ul>
<li>
<p>无原子操作时，<code>write</code>线程的写操作无法被<code>read</code>线程的读操作看到（<code>-O3</code>优化级别）</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">read</span><span class="params">([&amp;data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int64_t</span> prev = <span class="number">-1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (prev != <span class="number">-1</span> &amp;&amp; prev != data) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;see changes, prev=&quot;</span> &lt;&lt; prev &lt;&lt; <span class="string">&quot;, data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            prev = data;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">write</span><span class="params">([&amp;data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            data++;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    read.<span class="built_in">join</span>();</span><br><span class="line">    write.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用不同的<code>std::mutex</code>可以保证变量的最终一致性</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">read</span><span class="params">([&amp;data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::mutex m_read;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int64_t</span> prev = <span class="number">-1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::lock_guard&lt;std::mutex&gt; l(m_read);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (prev != <span class="number">-1</span> &amp;&amp; prev != data) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;see changes, prev=&quot;</span> &lt;&lt; prev &lt;&lt; <span class="string">&quot;, data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            prev = data;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">write</span><span class="params">([&amp;data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::mutex m_write;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::lock_guard&lt;std::mutex&gt; l(m_write);</span></span></span><br><span class="line"><span class="params"><span class="function">            data++;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    read.<span class="built_in">join</span>();</span><br><span class="line">    write.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用不同的<code>std::atomic</code>可以保证变量的最终一致性</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">read</span><span class="params">([&amp;data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::atomic&lt;<span class="type">int32_t</span>&gt; atom_read;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int64_t</span> prev = <span class="number">-1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            atom_read.load();</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (prev != <span class="number">-1</span> &amp;&amp; prev != data) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;see changes, prev=&quot;</span> &lt;&lt; prev &lt;&lt; <span class="string">&quot;, data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            prev = data;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">write</span><span class="params">([&amp;data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::atomic&lt;<span class="type">int32_t</span>&gt; atom_write;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            data++;</span></span></span><br><span class="line"><span class="params"><span class="function">            atom_write.store(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    read.<span class="built_in">join</span>();</span><br><span class="line">    write.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="55-x86-memory-model"><a class="markdownIt-Anchor" href="#55-x86-memory-model"></a> 5.5 x86 Memory Model</h2>
<p>对于<code>std::memory_order_relaxed</code>，在不同的硬件平台上，其效果是不同的。x86属于<code>TSO</code></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lqlqlq/p/13693876.html">x86-TSO : 适用于x86体系架构并发编程的内存模型</a></p>
<h2 id="56-参考"><a class="markdownIt-Anchor" href="#56-参考"></a> 5.6 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107092432">C++11 - atomic类型和内存模型</a></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/memory_order">cppreference.com-std::memory_order</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24301047">如何理解 C++11 的六种 memory order？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiayy/p/3246157.html">并行编程——内存模型之顺序一致性</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91406250">漫谈内存一致性模型</a></li>
</ul>
<h1 id="6-lambda"><a class="markdownIt-Anchor" href="#6-lambda"></a> 6 Lambda</h1>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/lambda">Lambda expressions (since C++11)</a></p>
<blockquote>
<p>The lambda expression is a prvalue expression of unique unnamed non-union non-aggregate class type, known as closure type, which is declared (for the purposes of ADL) in the smallest block scope, class scope, or namespace scope that contains the lambda expression. The closure type has the following members, they cannot be explicitly instantiated, explicitly specialized, or (since C++14) named in a friend declaration</p>
</blockquote>
<ul>
<li>每个<code>Lambda</code>表达式都是独一无二的类型，且无法显式声明</li>
</ul>
<h2 id="61-stdfunction-and-lambda"><a class="markdownIt-Anchor" href="#61-stdfunction-and-lambda"></a> 6.1 <code>std::function</code> and Lambda</h2>
<p>在大多数场景下，<code>Lambda</code>和<code>std::function</code>可以相互替换使用，但它们之间存在一些差异（<a target="_blank" rel="noopener" href="https://www.quora.com/Whats-the-difference-between-a-lambda-expression-and-a-function-pointer-callback-in-C++">What’s the difference between a lambda expression and a function pointer (callback) in C++?</a>）：</p>
<ul>
<li><code>Lambda</code>无法显式声明类型，而<code>std::function</code>可以</li>
<li><code>Lambda</code>效率更高，参考<a href="/2021/10/15/Cpp-Performance-Optimization/" title="Cpp-Performance-Optimization">Cpp-Performance-Optimization</a>
<ul>
<li><code>std::function</code>本质上是个函数指针的封装，当传递它时，编译器很难进行内联优化</li>
<li><code>Lambda</code>本质上是传递某个匿名类的实例，有确定的类型信息，编译器可以很容易地进行内联优化</li>
</ul>
</li>
</ul>
<h1 id="7-coroutine"><a class="markdownIt-Anchor" href="#7-coroutine"></a> 7 Coroutine</h1>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=8sEe-4tig_A">C++20’s Coroutines for Beginners - Andreas Fertig - CppCon 2022</a></p>
<p>A coroutine is a generalization of a function that can be exited and later resumed at specific points. The key difference from functions is that coroutines can maintain state between suspensions.</p>
<ul>
<li><code>co_yield</code>: Produces a value and suspends the coroutine. The coroutine can be later resumed from this point.</li>
<li><code>co_return</code>: Ends the coroutine, potentially returning a final value.</li>
<li><code>co_await</code>: Suspends the coroutine until the awaited expression is ready, at which point the coroutine is resumed.</li>
</ul>
<p><strong>A coroutine consists of:</strong></p>
<ul>
<li>A wrapper type</li>
<li>A type with the exact name <code>promise_type</code> inside the return type of coroutine(the wrapper type), this type can be:
<ul>
<li>Type alias</li>
<li>A <code>typedef</code></li>
<li>Directly declare an inner class</li>
</ul>
</li>
<li>An awaitable type that comes into play once we use <code>co_await</code></li>
<li>An interator</li>
</ul>
<p><strong>Key Observation: A coroutine in C++ is an finite state machine(FSM) that can be controlled and customized by the promise_type</strong></p>
<p><strong>Coroutine Classifications:</strong></p>
<ul>
<li><code>Task</code>: A coroutine that does a job without returning a value.</li>
<li><code>Generator</code>: A coroutine that does a job and returns a value(either by <code>co_return</code> or <code>co_yield</code>)</li>
</ul>
<h2 id="71-overview-of-promise_type"><a class="markdownIt-Anchor" href="#71-overview-of-promise_type"></a> 7.1 Overview of <code>promise_type</code></h2>
<p>The <code>promise_type</code> for coroutines in C++20 can have several member functions which the coroutine machinery recognizes and calls at specific times or events. Here’s a general overview of the structure and potential member functions:</p>
<ul>
<li><strong>Stored Values or State:</strong> These are member variables to hold state, intermediate results, or final values. The nature of these depends on the intended use of your coroutine.</li>
<li><strong>Coroutine Creation:</strong>
<ul>
<li><code>auto get_return_object() -&gt; CoroutineReturnObject</code>: Defines how to obtain the return object of the coroutine (what the caller of the coroutine gets when invoking the coroutine).</li>
</ul>
</li>
<li><strong>Coroutine Lifecycle:</strong>
<ul>
<li><code>std::suspend_always/std::suspend_never initial_suspend() noexcept</code>: Dictates if the coroutine should start executing immediately or be suspended right after its creation.</li>
<li><code>std::suspend_always/std::suspend_never final_suspend() noexcept</code>: Dictates if the coroutine should be suspended after running to completion. If <code>std::suspend_never</code> is used, the coroutine ends immediately after execution.</li>
<li><code>void return_void()</code> noexcept: Used for coroutines with a <code>void</code> return type. Indicates the end of the coroutine.</li>
<li><code>void return_value(ReturnType value)</code>: For coroutines that produce a result, this function specifies how to handle the value provided with <code>co_return</code>.</li>
<li><code>void unhandled_exception()</code>: Invoked if there’s an unhandled exception inside the coroutine. Typically, you’d capture or rethrow the exception here.</li>
</ul>
</li>
<li><strong>Yielding Values:</strong>
<ul>
<li><code>std::suspend_always/std::suspend_never yield_value(YieldType value)</code>: Specifies what to do when the coroutine uses <code>co_yield</code>. You dictate here how the value should be handled or stored.</li>
</ul>
</li>
<li><strong>Awaiting Values:</strong>
<ul>
<li><code>auto await_transform(AwaitableType value) -&gt; Awaiter</code>: Transforms the expression after co_await. This is useful for custom awaitable types. For instance, it’s used to make this a valid awaitable in member functions.</li>
</ul>
</li>
</ul>
<h3 id="711-awaiter"><a class="markdownIt-Anchor" href="#711-awaiter"></a> 7.1.1 Awaiter</h3>
<p>The awaiter in the C++ coroutine framework is a mechanism that allows fine-tuned control over how asynchronous operations are managed and how results are produced once those operations are complete.</p>
<p>Here’s an overview of the awaiter:</p>
<p><strong>Role of the Awaiter:</strong></p>
<ul>
<li>The awaiter is responsible for defining the behavior of a <code>co_await</code> expression. It determines if the coroutine should suspend, what should be done upon suspension, and what value (if any) should be produced when the coroutine resumes.</li>
</ul>
<p><strong>Required Methods:</strong> The awaiter must provide the following three methods:</p>
<ul>
<li><code>await_ready</code>
<ul>
<li>Purpose: Determines if the coroutine needs to suspend at all.</li>
<li>Signature: <code>bool await_ready() const noexcept</code></li>
<li>Return:
<ul>
<li><code>true</code>: The awaited operation is already complete, and the coroutine shouldn’t suspend.</li>
<li><code>false</code>: The coroutine should suspend.</li>
</ul>
</li>
</ul>
</li>
<li><code>await_suspend</code>
<ul>
<li>Purpose: Dictates the actions that should be taken when the coroutine suspends.</li>
<li>Signature: <code>void await_suspend(std::coroutine_handle&lt;&gt; handle) noexcept</code></li>
<li>Parameters:
<ul>
<li><code>handle</code>: A handle to the currently executing coroutine. It can be used to later resume the coroutine.</li>
</ul>
</li>
</ul>
</li>
<li><code>await_resume</code>
<ul>
<li>Purpose: Produces a value once the awaited operation completes and the coroutine resumes.</li>
<li>Signature: <code>ReturnType await_resume() noexcept</code></li>
<li>Return: The result of the <code>co_await</code> expression. The type can be <code>void</code> if no value needs to be produced.</li>
</ul>
</li>
</ul>
<p><strong>Workflow of the Awaiter:</strong></p>
<ol>
<li><strong>Obtain the Awaiter</strong>: When a coroutine encounters <code>co_await someExpression</code>, it first needs to get an awaiter. The awaiter can be:
<ul>
<li>Directly from <code>someExpression</code> if it has an <code>operator co_await</code>.</li>
<li>Through an ADL (Argument Dependent Lookup) free function named <code>operator co_await</code> that takes <code>someExpression</code> as a parameter.</li>
<li>From the coroutine’s <code>promise_type</code> via <code>await_transform</code> if neither of the above methods produce an awaiter.</li>
</ul>
</li>
<li><strong>Call <code>await_ready</code></strong>: The coroutine calls the awaiter’s <code>await_ready()</code> method.
<ul>
<li>If it returns <code>true</code>, the coroutine continues without suspending.</li>
<li>If it returns <code>false</code>, the coroutine prepares to suspend.</li>
</ul>
</li>
<li><strong>Call <code>await_suspend (if needed)</code></strong>: If <code>await_ready</code> indicated the coroutine should suspend (by returning <code>false</code>), the <code>await_suspend</code> method is called with a handle to the current coroutine. This method typically arranges for the coroutine to be resumed later, often by setting up callbacks or handlers associated with the asynchronous operation.</li>
<li><strong>Operation Completion and Coroutine Resumption</strong>: Once the awaited operation is complete and the coroutine is resumed, the awaiter’s await_resume method is called. The value it produces becomes the result of the co_await expression.</li>
</ol>
<p><strong>Built-in Awaiters:</strong></p>
<ul>
<li><code>std::suspend_always</code>: The method <code>await_ready</code> always returns <code>false</code>, indicating that an await expression always suspends as it waits for its value</li>
<li><code>std::suspend_never</code>: The method <code>await_ready</code> always returns <code>true</code>, indicating that an await expression never suspends</li>
</ul>
<h2 id="72-example"><a class="markdownIt-Anchor" href="#72-example"></a> 7.2 Example</h2>
<p>The <code>Chat</code> struct acts as a wrapper around the coroutine handle. It allows the main code to interact with the coroutine - by resuming it, or by sending/receiving data to/from it.</p>
<p>The <code>promise_type</code> nested within <code>Chat</code> is what gives behavior to our coroutine. It defines:</p>
<ul>
<li>What happens when you start the coroutine (<code>initial_suspend</code>).</li>
<li>What happens when you <code>co_yield</code> a value (<code>yield_value</code>).</li>
<li>What happens when you <code>co_await</code> a value (<code>await_transform</code>).</li>
<li>What happens when you <code>co_return</code> a value (<code>return_value</code>).</li>
<li>What happens at the end of the coroutine (<code>final_suspend</code>).</li>
</ul>
<p>Functionality:</p>
<ol>
<li><strong>Creating the Coroutine:</strong>
<ul>
<li>When <code>Fun()</code> is called, a new coroutine is started. Due to <code>initial_suspend</code>, it is suspended immediately before executing any code.</li>
<li>The coroutine handle (with the promise) is wrapped inside the Chat object, which is then returned to the caller (main function in this case).</li>
</ul>
</li>
<li><strong>Interacting with the Coroutine:</strong>
<ul>
<li><code>chat.listen()</code>: Resumes the coroutine until the next suspension point. If <code>co_yield</code> is used inside the coroutine, the yielded value will be returned.</li>
<li><code>chat.answer(msg)</code>: Sends a message to the coroutine. If the coroutine is waiting for input using <code>co_await</code>, this will provide the awaited value and resume the coroutine.</li>
</ul>
</li>
<li><strong>Coroutine Flow:</strong>
<ul>
<li>The coroutine starts and immediately hits <code>co_yield &quot;Hello!\n&quot;;</code>. This suspends the coroutine and the string <code>&quot;Hello!\n&quot;</code> is made available to the caller.</li>
<li>In <code>main</code>, after <code>chat.listen()</code>, it prints this message.</li>
<li>Then, <code>chat.answer(&quot;Where are you?\n&quot;);</code> is called. Inside the coroutine, the message <code>&quot;Where are you?\n&quot;</code> is captured and printed because of the line <code>std::cout &lt;&lt; co_await std::string&#123;&#125;;</code>.</li>
<li>Finally, <code>co_return &quot;Here!\n&quot;;</code> ends the coroutine, and the string <code>&quot;Here!\n&quot;</code> is made available to the caller. This message is printed after the second chat.<code>listen()</code> in <code>main</code>.</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Chat</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="comment">// A: Storing a value from or for the coroutine</span></span><br><span class="line">        std::string _msg_out&#123;&#125;;</span><br><span class="line">        std::string _msg_in&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// B: What to do in case of an exception</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Chat::unhandled_exception&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// C: Coroutine creation</span></span><br><span class="line">        <span class="function">Chat <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::get_return_object&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Chat</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// D: Startup</span></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::initial_suspend&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// F: Value from co_yield</span></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(std::string msg)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::yield_value&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            _msg_out = std::<span class="built_in">move</span>(msg);</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// G: Value from co_await</span></span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(std::string)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::await_transform&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// H: Customized version instead of using suspend_always or suspend_never</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">awaiter</span> &#123;</span><br><span class="line">                promise_type&amp; pt;</span><br><span class="line">                <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::await_transform::await_ready&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">std::string <span class="title">await_resume</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::await_transform::await_resume&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">return</span> std::<span class="built_in">move</span>(pt._msg_in);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt;)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::await_transform::await_suspend&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> awaiter&#123;*<span class="keyword">this</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// I: Value from co_return</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(std::string msg)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::return_value&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            _msg_out = std::<span class="built_in">move</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// E: Ending</span></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::final_suspend&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A: Shortcut for the handle type</span></span><br><span class="line">    <span class="keyword">using</span> Handle = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line">    <span class="comment">// B</span></span><br><span class="line">    Handle _handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C: Get the handle from promise</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Chat</span><span class="params">(promise_type* p)</span> : _handle(Handle::from_promise(*p)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// D: Move only</span></span><br><span class="line">    <span class="built_in">Chat</span>(Chat&amp;&amp; rhs) : _handle(std::<span class="built_in">exchange</span>(rhs._handle, <span class="literal">nullptr</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// E: Care taking, destroying the handle if needed</span></span><br><span class="line">    ~<span class="built_in">Chat</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_handle) &#123;</span><br><span class="line">            _handle.<span class="built_in">destroy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// F: Active the coroutine and wait for data</span></span><br><span class="line">    <span class="function">std::string <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; -- Chat::listen&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (!_handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">            _handle.<span class="built_in">resume</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(_handle.<span class="built_in">promise</span>()._msg_out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// G Send data to the coroutine and activate it</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">answer</span><span class="params">(std::string msg)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; -- Chat::answer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _handle.<span class="built_in">promise</span>()._msg_in = msg;</span><br><span class="line">        <span class="keyword">if</span> (!_handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">            _handle.<span class="built_in">resume</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Chat <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">co_yield</span> <span class="string">&quot;Hello!\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">co_await</span> std::string&#123;&#125;;</span><br><span class="line">    <span class="keyword">co_return</span> <span class="string">&quot;Here!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Chat chat = <span class="built_in">Fun</span>();</span><br><span class="line">    std::cout &lt;&lt; chat.<span class="built_in">listen</span>();</span><br><span class="line">    chat.<span class="built_in">answer</span>(<span class="string">&quot;Where are you?\n&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; chat.<span class="built_in">listen</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> -- Chat::promise_type::get_return_object</span><br><span class="line"> -- Chat::promise_type::initial_suspend</span><br><span class="line"> -- Chat::listen</span><br><span class="line"> -- Chat::promise_type::yield_value</span><br><span class="line">Hello!</span><br><span class="line"> -- Chat::answer</span><br><span class="line"> -- Chat::promise_type::await_transform</span><br><span class="line"> -- Chat::promise_type::await_transform::await_ready</span><br><span class="line"> -- Chat::promise_type::await_transform::await_resume</span><br><span class="line">Where are you?</span><br><span class="line"> -- Chat::promise_type::return_value</span><br><span class="line"> -- Chat::promise_type::final_suspend</span><br><span class="line"> -- Chat::listen</span><br><span class="line">Here!</span><br></pre></td></tr></table></figure>
<h1 id="8-attributes"><a class="markdownIt-Anchor" href="#8-attributes"></a> 8 Attributes</h1>
<p><code>__attribute__</code>是一个<code>GCC</code>编译器特有的特性，它允许程序员向编译器提供一些指示信息，以便在编译期间进行优化或者在运行期间提供一些额外的约束条件。这些指示信息被称为属性（<code>attributes</code>），可以应用于函数、变量、类型等各种程序元素</p>
<p><code>C++11</code>引入了一种新的语言特性，称为属性（<code>attributes</code>），它们与<code>__attribute__</code>类似，但是是标准<code>C++</code>的一部分，因此在编译器支持<code>C++11</code>之后，可以在<code>C++</code>代码中使用它们。与<code>__attribute__</code>不同，<code>C++11</code>的<code>attributes</code>支持在类和命名空间级别使用，而不仅仅是在函数和变量级别</p>
<p><code>C++11</code>的<code>attributes</code>也提供了更多的灵活性和可读性。它们可以用更自然的方式嵌入到代码中，而不像<code>__attribute__</code>那样需要使用一些冗长的语法。此外，<code>C++11</code>的<code>attributes</code>还提供了一些有用的新特性，例如<code>[[noreturn]]</code>、<code>[[carries_dependency]]</code>、<code>[[deprecated]]</code>、<code>[[fallthrough]]</code></p>
<p>常用<code>__attribute__</code>清单：</p>
<ul>
<li><code>__attribute__((packed))</code>：指示编译器在分配结构体内存时尽量紧凑地排列各个字段，以减小结构体的内存占用</li>
<li><code>__attribute__((aligned(n)))</code>: 指示编译器将变量对齐到<code>n</code>字节边界</li>
<li><code>__attribute__((noreturn))</code>：指示函数不会返回，用于告诉编译器在函数调用之后不需要进行任何清理操作</li>
<li><code>__attribute__((unused))</code>：指示编译器不应发出未使用变量的警告。</li>
<li><code>__attribute__((deprecated))</code>：指示函数或变量已经过时，编译器会在使用它们时发出警告</li>
<li><code>__attribute__(alias)</code>：它允许你将一个函数或变量的名称指定为另一个已存在的函数或变量的别名。可以起到与链接器参数<code>--wrap=&lt;symbol&gt;</code>类似的作用  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE* <span class="title">my_fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* mode)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is my fopen!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* mode)</span> __<span class="title">attribute__</span><span class="params">((alias(<span class="string">&quot;my_fopen&quot;</span>)))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calling the fopen() function...\n&quot;</span>);</span><br><span class="line">    FILE* fd = <span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fopen() returned NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fopen() succeeded\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>常用<code>attributes</code>清单：</p>
<ul>
<li><code>[[noreturn]]</code>（C++11）：用于标识函数不会返回。如果一个函数被标记为<code>[[noreturn]]</code>，那么编译器会警告或者错误地处理一个函数的任何尝试返回值</li>
<li><code>[[deprecated]]</code>（C++14）：用于标识函数或变量已被弃用。编译器会在调用或使用被标记为<code>[[deprecated]]</code>的函数或变量时给出警告</li>
<li><code>[[fallthrough]]</code>（C++17）：用于标识<code>switch</code>语句中的<code>case</code>标签，以指示代码故意继续执行下一个<code>case</code>标签</li>
<li><code>[[nodiscard]]</code>（C++17）：用于标识函数的返回值需要被检查。当一个函数被标记为<code>[[nodiscard]]</code>时，如果函数返回值没有被检查，编译器会给出警告</li>
<li><code>[[maybe_unused]]</code>（C++17）：用于标识变量或函数可能未被使用。编译器不会给出未使用的变量或函数的警告</li>
<li><code>[[likely]]</code>（C++20）：提示编译器该分支大概率为<code>true</code></li>
<li><code>[[unlikely]]</code>（C++20）：提示编译器该分支大概率为<code>false</code></li>
</ul>
<h2 id="81-aligned"><a class="markdownIt-Anchor" href="#81-aligned"></a> 8.1 aligned</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOO_WITH_ALIGN(SIZE) \</span></span><br><span class="line"><span class="meta">    struct Foo_##SIZE &#123;      \</span></span><br><span class="line"><span class="meta">        int v;               \</span></span><br><span class="line"><span class="meta">    &#125; __attribute__((aligned(SIZE)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_SIZEOF_FOO(SIZE) std::cout &lt;&lt; <span class="string">&quot;Foo_##SIZE&#x27;s size=&quot;</span> &lt;&lt; sizeof(Foo_##SIZE) &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">32</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">64</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">64</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="82-参考"><a class="markdownIt-Anchor" href="#82-参考"></a> 8.2 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.keil.com/support/man/docs/armcc/armcc_chr1359124965789.htm">Compiler-specific Features</a></li>
</ul>
<h1 id="9-asm"><a class="markdownIt-Anchor" href="#9-asm"></a> 9 ASM</h1>
<p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/">gcc-online-docs</a></p>
<h2 id="91-basic-asm"><a class="markdownIt-Anchor" href="#91-basic-asm"></a> 9.1 Basic Asm</h2>
<h2 id="92-extended-asm"><a class="markdownIt-Anchor" href="#92-extended-asm"></a> 9.2 <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">Extended Asm</a></h2>
<p>GCC设计了一种特有的嵌入方式，它规定了汇编代码嵌入的形式和嵌入汇编代码需要由哪几个部分组成，格式如下：</p>
<ul>
<li>汇编语句模板是必须的，其余三部分是可选的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="keyword">asm</span>-<span class="built_in">qualifiers</span> ( AssemblerTemplate </span><br><span class="line">                 : OutputOperands </span><br><span class="line">                 [ : InputOperands</span><br><span class="line">                 [ : Clobbers ] ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> <span class="keyword">asm</span>-<span class="built_in">qualifiers</span> ( AssemblerTemplate </span><br><span class="line">                      : OutputOperands</span><br><span class="line">                      : InputOperands</span><br><span class="line">                      : Clobbers</span><br><span class="line">                      : GotoLabels)</span><br></pre></td></tr></table></figure>
<p><strong><code>Qualifiers</code>，修饰符：</strong></p>
<ul>
<li><code>volatile</code>：禁止编译器优化</li>
<li><code>inline</code></li>
<li><code>goto</code></li>
</ul>
<p><strong><code>AssemblerTemplate</code>，汇编语句模板：</strong></p>
<ul>
<li>汇编语句模板由汇编语句序列组成，语句之间使用<code>;</code>、<code>\n</code>、<code>\n\t</code>分开</li>
<li>指令中的操作数可以使用占位符，占位符可以指向<code>OutputOperands</code>、<code>InputOperands</code>、<code>GotoLabels</code></li>
<li>指令中使用占位符表示的操作数，总被视为<code>long</code>型（4个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节</li>
<li>对字节操作可以显式的指明是低字节还是次字节。方法是在<code>%</code>和序号之间插入一个字母
<ul>
<li><code>b</code>代表低字节</li>
<li><code>h</code>代表高字节</li>
<li>例如：<code>%h1</code></li>
</ul>
</li>
</ul>
<p><strong><code>OutputOperands</code>，输出操作数：</strong></p>
<ul>
<li>操作数之间用逗号分隔</li>
<li>每个操作数描述符由限定字符串（<code>Constraints</code>）和C语言变量或表达式组成</li>
</ul>
<p><strong><code>InputOperands</code>，输入操作数：</strong></p>
<ul>
<li>操作数之间用逗号分隔</li>
<li>每个操作数描述符由限定字符串（<code>Constraints</code>）和C语言变量或表达式组成</li>
</ul>
<p><strong><code>Clobbers</code>，描述部分：</strong></p>
<ul>
<li>用于通知编译器我们使用了哪些寄存器或内存，由逗号格开的字符串组成</li>
<li>每个字符串描述一种情况，一般是寄存器名；除寄存器外还有<code>memory</code>。例如：<code>%eax</code>，<code>%ebx</code>，<code>memory</code>等</li>
</ul>
<p><strong><code>Constraints</code>，限定字符串（下面仅列出常用的）：</strong></p>
<ul>
<li><code>m</code>：内存</li>
<li><code>o</code>：内存，但是其寻址方式是偏移量类型</li>
<li><code>v</code>：内存，但寻址方式不是偏移量类型</li>
<li><code>r</code>：通用寄存器</li>
<li><code>i</code>：整型立即数</li>
<li><code>g</code>：任意通用寄存器、内存、立即数</li>
<li><code>p</code>：合法指针</li>
<li><code>=</code>：write-only</li>
<li><code>+</code>：read-write</li>
<li><code>&amp;</code>：该输出操作数不能使用过和输入操作数相同的寄存器</li>
</ul>
<p><strong>示例1：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">atomic_t</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int32_t</span> a_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int32_t</span> <span class="title">atomic_read</span><span class="params">(<span class="type">const</span> <span class="type">atomic_t</span>* v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">volatile</span> <span class="type">int32_t</span>*)&amp;(v)-&gt;a_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">atomic_write</span><span class="params">(<span class="type">atomic_t</span>* v, <span class="type">int32_t</span> i)</span> </span>&#123;</span><br><span class="line">    v-&gt;a_count = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">atomic_add</span><span class="params">(<span class="type">atomic_t</span>* v, <span class="type">int32_t</span> i)</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">            <span class="string">&quot;lock;&quot;</span></span><br><span class="line">            <span class="string">&quot;addl %1,%0&quot;</span></span><br><span class="line">            : <span class="string">&quot;+m&quot;</span>(v-&gt;a_count)</span><br><span class="line">            : <span class="string">&quot;ir&quot;</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">atomic_sub</span><span class="params">(<span class="type">atomic_t</span>* v, <span class="type">int32_t</span> i)</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">            <span class="string">&quot;lock;&quot;</span></span><br><span class="line">            <span class="string">&quot;subl %1,%0&quot;</span></span><br><span class="line">            : <span class="string">&quot;+m&quot;</span>(v-&gt;a_count)</span><br><span class="line">            : <span class="string">&quot;ir&quot;</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">atomic_inc</span><span class="params">(<span class="type">atomic_t</span>* v)</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">            <span class="string">&quot;lock;&quot;</span></span><br><span class="line">            <span class="string">&quot;incl %0&quot;</span></span><br><span class="line">            : <span class="string">&quot;+m&quot;</span>(v-&gt;a_count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">atomic_dec</span><span class="params">(<span class="type">atomic_t</span>* v)</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">            <span class="string">&quot;lock;&quot;</span></span><br><span class="line">            <span class="string">&quot;decl %0&quot;</span></span><br><span class="line">            : <span class="string">&quot;+m&quot;</span>(v-&gt;a_count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">atomic_t</span> v;</span><br><span class="line">    <span class="built_in">atomic_write</span>(&amp;v, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">atomic_add</span>(&amp;v, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">atomic_sub</span>(&amp;v, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">atomic_inc</span>(&amp;v);</span><br><span class="line">    <span class="built_in">atomic_dec</span>(&amp;v);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">atomic_read</span>(&amp;v) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<ul>
<li>这个程序是没法跑的，因为<code>cli</code>指令必须在内核态执行</li>
<li><code>hal_save_flags_cli</code>：将<code>eflags</code>寄存器的值保存到内存中，然后关闭中断</li>
<li><code>hal_restore_flags_sti</code>：将<code>hal_save_flags_cli</code>保存在内存中的值恢复到<code>eflags</code>寄存器中</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">cpuflg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">hal_save_flags_cli</span><span class="params">(<span class="type">cpuflg_t</span>* flags)</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span> <span class="comment">// 把eflags寄存器的值压入当前栈顶</span></span><br><span class="line">            <span class="string">&quot;cli;&quot;</span>   <span class="comment">// 关闭中断，会改变eflags寄存器的值</span></span><br><span class="line">            <span class="string">&quot;pop %0&quot;</span> <span class="comment">// 把当前栈顶弹出到eflags为地址的内存中</span></span><br><span class="line">            : <span class="string">&quot;=m&quot;</span>(*flags)</span><br><span class="line">            :</span><br><span class="line">            : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">hal_restore_flags_sti</span><span class="params">(<span class="type">cpuflg_t</span>* flags)</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">            <span class="string">&quot;push %0;&quot;</span> <span class="comment">// 把flags为地址处的值寄存器压入当前栈顶</span></span><br><span class="line">            <span class="string">&quot;popf&quot;</span>     <span class="comment">// 把当前栈顶弹出到eflags寄存器中</span></span><br><span class="line">            :</span><br><span class="line">            : <span class="string">&quot;m&quot;</span>(*flags)</span><br><span class="line">            : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">cpuflg_t</span>* flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">hal_save_flags_cli</span>(flags);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;step1: foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">hal_restore_flags_sti</span>(flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">cpuflg_t</span> flags;</span><br><span class="line">    <span class="built_in">hal_save_flags_cli</span>(&amp;flags);</span><br><span class="line">    <span class="built_in">foo</span>(&amp;flags);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;step2: bar()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">hal_restore_flags_sti</span>(&amp;flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：linux内核大量用到了<code>asm</code>，具体可以参考<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm">linux-asm</a></strong></p>
<h1 id="10-policy"><a class="markdownIt-Anchor" href="#10-policy"></a> 10 Policy</h1>
<h2 id="101-pointer-stability"><a class="markdownIt-Anchor" href="#101-pointer-stability"></a> 10.1 Pointer Stability</h2>
<p><strong><code>pointer stability</code>通常用于描述容器。当我们说一个容器是<code>pointer stability</code>时，是指，当某个元素添加到容器之后、从容器删除之前，该元素的内存地址不变，也就是说，该元素的内存地址，不会受到容器的添加删除元素、扩缩容、或者其他操作影响</strong></p>
<ul>
<li>引用也会受到这个性质的影响，因为引用就是指针的语法糖</li>
</ul>
<p><strong><a target="_blank" rel="noopener" href="https://abseil.io/docs/cpp/guides/container">absl</a></strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Container</th>
<th style="text-align:left">Is pointer stability or not</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>std::vector</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>std::list</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>std::deque</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left">Expand may keep pointer stablity, but contract may not</td>
</tr>
<tr>
<td style="text-align:left"><code>std::map</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>std::unordered_map</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>std::set</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>std::unordered_set</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>absl::flat_hash_map</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>absl::flat_hash_set</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>absl::node_hash_map</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>absl::node_hash_set</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>phmap::flat_hash_map</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>phmap::flat_hash_set</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>phmap::node_hash_map</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>phmap::node_hash_set</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="102-exception-safe"><a class="markdownIt-Anchor" href="#102-exception-safe"></a> 10.2 Exception Safe</h2>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Exception_safety">Wiki-Exception safety</a></p>
<p><strong><code>exception safety</code>的几个级别：</strong></p>
<ol>
<li><code>No-throw guarantee</code>：承诺不会对外抛出任何异常。方法内部可能会抛异常，但都会被正确处理</li>
<li><code>Strong exception safety</code>：可能会抛出异常，但是承诺不会有副作用，所有对象都会恢复到调用方法时的初始状态</li>
<li><code>Basic exception safety</code>：可能会抛出异常，操作失败的部分可能会导致副作用，但所有不变量都会被保留。任何存储的数据都将包含可能与原始值不同的有效值。资源泄漏（包括内存泄漏）通常通过一个声明所有资源都被考虑和管理的不变量来排除</li>
<li><code>No exception safety</code>：不承诺异常安全</li>
</ol>
<h2 id="103-raii"><a class="markdownIt-Anchor" href="#103-raii"></a> 10.3 RAII</h2>
<p><code>RAII, Resource Acquisition is initialization</code>，即资源获取即初始化。典型示例包括：<code>std::lock_guard</code>、<code>defer</code>。简单来说，就是在对象的构造方法中初始化资源，在析构函数中销毁资源。而构造函数与析构函数的调用是由编译器自动插入的，减轻了开发者的心智负担</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DeferFunction</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeferOp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DeferOp</span><span class="params">(DeferFunction func)</span> : _func(std::move(func)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DeferOp</span>() &#123; _func(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DeferFunction _func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="11-tips"><a class="markdownIt-Anchor" href="#11-tips"></a> 11 Tips</h1>
<h2 id="111-class-related"><a class="markdownIt-Anchor" href="#111-class-related"></a> 11.1 Class Related</h2>
<h3 id="1111-how-to-define-static-members-in-a-class"><a class="markdownIt-Anchor" href="#1111-how-to-define-static-members-in-a-class"></a> 11.1.1 How to define static members in a class</h3>
<p><strong>在类中声明静态成员，在类外定义（赋值）静态成员，示例如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> BUFFER_LEN;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> Demo::BUFFER_LEN = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Demo::BUFFER_LEN &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1112-non-static-members-of-a-class-cannot-undergo-type-deduction"><a class="markdownIt-Anchor" href="#1112-non-static-members-of-a-class-cannot-undergo-type-deduction"></a> 11.1.2 Non-static members of a class cannot undergo type deduction</h3>
<p>类的非静态成员，无法进行类型推导，必须显式指定类型（因为类型信息必须是不可变的）；静态成员可以。例如下面示例就存在语法错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Delegate</span>(Func func) : _func(std::<span class="built_in">move</span>(func)) &#123; _func(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Func _func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() : _delegate(Foo::do_something) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> Delegate _s_delegate&#123;Foo::do_something&#125;;</span><br><span class="line">    <span class="comment">// Use of class template &#x27;Delegate&#x27; requires template arguments</span></span><br><span class="line">    <span class="comment">// Argument deduction not allowed in non-static class member (clang auto_not_allowed</span></span><br><span class="line">    Delegate _delegate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="112-initialization"><a class="markdownIt-Anchor" href="#112-initialization"></a> 11.2 Initialization</h2>
<h3 id="1121-initializer-list"><a class="markdownIt-Anchor" href="#1121-initializer-list"></a> 11.2.1 Initializer List</h3>
<ol>
<li>对于内置类型，直接进行值拷贝。使用初始化列表还是在构造函数体中进行初始化没有差别</li>
<li>对于类类型
<ul>
<li>在初始化列表中初始化：调用的是拷贝构造函数或者移动构造函数</li>
<li>在构造函数体中初始化：虽然在初始化列表中没有显式指定，但是仍然会用默认的构造函数来进行初始化，然后在构造函数体中使用拷贝或者移动赋值运算符</li>
</ul>
</li>
<li>哪些东西必须放在初始化列表中
<ul>
<li>常量成员</li>
<li>引用类型</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝或者移动构造函数初始化</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s default constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : _a(a), _b(<span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s (int) constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b) : _a(a), _b(b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s (int, int) constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a) : _a(a._a), _b(a._b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(A &amp;&amp;a) : _a(a._a), _b(a._b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s move constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="type">const</span> A &amp;a) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s copy assign operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = a._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(A &amp;&amp;a) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s move assign operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = a._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(A &amp;a) : _a(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(A &amp;a, std::<span class="type">nullptr_t</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(A &amp;&amp;a) : _a(std::<span class="built_in">move</span>(a)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(A &amp;&amp;a, std::<span class="type">nullptr_t</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = std::<span class="built_in">move</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;============(create a)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(create b1)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(a)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(create b2)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(a, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(create b3)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">B <span class="title">b3</span><span class="params">(<span class="keyword">static_cast</span>&lt;A &amp;&amp;&gt;(a))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(create b4)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">B <span class="title">b4</span><span class="params">(<span class="keyword">static_cast</span>&lt;A &amp;&amp;&gt;(a), <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">============(create a)============</span><br><span class="line">A&#x27;s (int, int) constructor</span><br><span class="line"></span><br><span class="line">============(create b1)============</span><br><span class="line">A&#x27;s copy constructor</span><br><span class="line"></span><br><span class="line">============(create b2)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line">A&#x27;s copy assign operator</span><br><span class="line"></span><br><span class="line">============(create b3)============</span><br><span class="line">A&#x27;s move constructor</span><br><span class="line"></span><br><span class="line">============(create b4)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line">A&#x27;s move assign operator</span><br></pre></td></tr></table></figure>
<h3 id="1122-various-initialization-types"><a class="markdownIt-Anchor" href="#1122-various-initialization-types"></a> 11.2.2 Various Initialization Types</h3>
<ol>
<li>默认初始化：<code>type variableName;</code></li>
<li>直接初始化/构造初始化（至少有1个参数）：<code>type variableName(args);</code></li>
<li>列表初始化：<code>type variableName&#123;args&#125;;</code>
<ul>
<li>本质上列表初始化会调用相应的构造函数（匹配参数类型以及参数数量）来进行初始化</li>
<li>它的好处之一是可以简化<code>return</code>语句，可以直接<code>return &#123;args&#125;;</code></li>
</ul>
</li>
<li>拷贝初始化：
<ul>
<li><code>type variableName = otherVariableName</code>，本质上调用了拷贝构造函数</li>
<li><code>type variableName = &lt;type (args)&gt;</code>，其中<code>&lt;type (args)&gt;</code>指的是返回类型为<code>type</code>的函数。看起来会调用拷贝构造函数，但是编译器会对这种形式的初始化进行优化，也就是只有函数内部调用了构造函数（如果有的话），而<code>=</code>并未调用任何构造函数</li>
</ul>
</li>
<li>值初始化：<code>type variableName()</code>
<ul>
<li>对于内置类型，初始化为<code>0</code>或者<code>nullptr</code></li>
<li>对于类类型，等同于默认初始化。测试发现并未调用任何构造函数</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s default constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : _a(a), _b(<span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s (int) constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b) : _a(a), _b(b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s (int, int) constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a) : _a(a._a), _b(a._b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(A &amp;&amp;a) : _a(a._a), _b(a._b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s move constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="type">const</span> A &amp;a) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s copy assign operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = a._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(A &amp;&amp;a) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s move assign operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = a._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">createA</span><span class="params">(<span class="type">int</span> argNum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argNum == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argNum == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;============(默认初始化 a1)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(直接初始化 a2)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(直接初始化 a3)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">A <span class="title">a3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(列表初始化 a4)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a4 = &#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(列表初始化 a5)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a5 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(列表初始化 a6)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a6 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(拷贝初始化 a7)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a7 = a6;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(拷贝初始化 a8)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a8 = <span class="built_in">createA</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(拷贝初始化 a9)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a9 = <span class="built_in">createA</span>(<span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(拷贝初始化 a10)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a10 = <span class="built_in">createA</span>(<span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(值初始化 a11)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">A <span class="title">a11</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">============(默认初始化 a1)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line"></span><br><span class="line">============(直接初始化 a2)============</span><br><span class="line">A&#x27;s (int) constructor</span><br><span class="line"></span><br><span class="line">============(直接初始化 a3)============</span><br><span class="line">A&#x27;s (int, int) constructor</span><br><span class="line"></span><br><span class="line">============(列表初始化 a4)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line"></span><br><span class="line">============(列表初始化 a5)============</span><br><span class="line">A&#x27;s (int) constructor</span><br><span class="line"></span><br><span class="line">============(列表初始化 a6)============</span><br><span class="line">A&#x27;s (int, int) constructor</span><br><span class="line"></span><br><span class="line">============(拷贝初始化 a7)============</span><br><span class="line">A&#x27;s copy constructor</span><br><span class="line"></span><br><span class="line">============(拷贝初始化 a8)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line"></span><br><span class="line">============(拷贝初始化 a9)============</span><br><span class="line">A&#x27;s (int) constructor</span><br><span class="line"></span><br><span class="line">============(拷贝初始化 a10)============</span><br><span class="line">A&#x27;s (int, int) constructor</span><br><span class="line"></span><br><span class="line">============(值初始化 a11)============</span><br></pre></td></tr></table></figure>
<h3 id="1123-initialization-order-of-class-members"><a class="markdownIt-Anchor" href="#1123-initialization-order-of-class-members"></a> 11.2.3 Initialization Order of class Members</h3>
<ol>
<li>初始化列表</li>
<li>成员定义处的列表初始化，当且仅当该成员未出现在初始化列表中时才会生效</li>
<li>构造函数的函数体中的初始化行为</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initialized_where_defined</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;initialized_where_defined&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initialized_at_initialization_list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;initialized_at_initialization_list&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initialized_at_construct_block</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;initialized_at_construct_block&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; _data = <span class="built_in">initialized_at_construct_block</span>(); &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) : _data(<span class="built_in">initialized_at_initialization_list</span>()) &#123; _data = <span class="built_in">initialized_at_construct_block</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _data = <span class="built_in">initialized_where_defined</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    Foo f1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n---------------------------------------\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Foo <span class="title">f2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">initialized_where_defined</span><br><span class="line">initialized_at_construct_block</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br><span class="line">initialized_at_initialization_list</span><br><span class="line">initialized_at_construct_block</span><br></pre></td></tr></table></figure>
<h3 id="1124-initialization-of-static-local-variables"><a class="markdownIt-Anchor" href="#1124-initialization-of-static-local-variables"></a> 11.2.4 Initialization of static Local Variables</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Bar bar;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化过程等效于如下程序，其中：</p>
<ul>
<li><code>guard_for_bar</code>是一个用来保证线程安全和一次性初始化的整型变量，是编译器生成的，存储在<code>bss</code>段。它的最低的一个字节被用作相应静态变量是否已被初始化的标志，若为<code>0</code>表示还未被初始化，否则表示已被初始化</li>
<li><code>__cxa_guard_acquire</code>实际上是一个加锁的过程， 相应的<code>__cxa_guard_abort</code>和 <code>__cxa_guard_release</code>释放锁</li>
<li><code>__cxa_atexit</code>注册在调用<code>exit</code>时或动态链接库(或共享库) 被卸载时执行的函数，这里注册的是Bar的析构函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((guard_for_bar &amp; <span class="number">0xff</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__cxa_guard_acquire(&amp;guard_for_bar)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Bar::<span class="built_in">Bar</span>(&amp;bar);</span><br><span class="line">            &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">                __cxa_guard_abort(&amp;guard_for_bar);</span><br><span class="line">                <span class="keyword">throw</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            __cxa_guard_release(&amp;guard_for_bar);</span><br><span class="line">            __cxa_atexit(Bar::~Bar, &amp;bar, &amp;__dso_handle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1125-initialization-of-non-static-class-members"><a class="markdownIt-Anchor" href="#1125-initialization-of-non-static-class-members"></a> 11.2.5 Initialization of non-static class Members</h3>
<p>非静态成员不允许使用构造初始化，但是允许使用列表初始化（本质上还是调用了对应的构造函数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val) &#123; std::cout &lt;&lt; <span class="string">&quot;Foo(int)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Foo foo&#123;<span class="number">5</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bar bar;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="113-pointer"><a class="markdownIt-Anchor" href="#113-pointer"></a> 11.3 Pointer</h2>
<h3 id="1131-member-function-pointer"><a class="markdownIt-Anchor" href="#1131-member-function-pointer"></a> 11.3.1 Member Function Pointer</h3>
<p>成员函数指针需要通过<code>.*</code>或者<code>-&gt;*</code>运算符进行调用</p>
<ul>
<li>类内调用：<code>(this-&gt;*&lt;name&gt;)(args...)</code></li>
<li>类外调用：<code>(obj.*obj.&lt;name&gt;)(args...)</code>或者<code>(pointer-&gt;*pointer-&gt;&lt;name&gt;)(args...)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Demo</span><span class="params">(<span class="type">bool</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            say_hi = &amp;Demo::say_hi_1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            say_hi = &amp;Demo::say_hi_2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invoke_say_hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">this</span>-&gt;*say_hi)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (Demo::*say_hi)() = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say_hi_1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say_hi_2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo::say_hi_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;say_hi_1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo::say_hi_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;say_hi_2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Demo <span class="title">demo1</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke inside class</span></span><br><span class="line">    demo1.<span class="built_in">invoke_say_hi</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke outside class with obj</span></span><br><span class="line">    (demo1.*demo1.say_hi)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke outside class with pointer</span></span><br><span class="line">    Demo *p1 = &amp;demo1;</span><br><span class="line">    (p1-&gt;*p1-&gt;say_hi)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke outside class with pointer</span></span><br><span class="line">    std::shared_ptr&lt;Demo&gt; sp1 = std::<span class="built_in">make_shared</span>&lt;Demo&gt;(<span class="literal">false</span>);</span><br><span class="line">    (sp1.<span class="built_in">get</span>()-&gt;*sp1-&gt;say_hi)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1132-how-to-pass-multi-dimensional-pointer-parameters"><a class="markdownIt-Anchor" href="#1132-how-to-pass-multi-dimensional-pointer-parameters"></a> 11.3.2 How to pass multi-dimensional pointer parameters</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Using a pointer to a 2D array</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yourFunction1</span><span class="params">(<span class="type">bool</span> (*rows)[<span class="number">9</span>])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Access elements of the 2D array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            std::cout &lt;&lt; rows[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using a reference to a 2D array</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yourFunction2</span><span class="params">(<span class="type">bool</span> (&amp;rows)[<span class="number">9</span>][<span class="number">9</span>])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Access elements of the 2D array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            std::cout &lt;&lt; rows[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> rows[<span class="number">9</span>][<span class="number">9</span>] = &#123;</span><br><span class="line">            <span class="comment">// Initialize the array as needed</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass the local variable to the functions</span></span><br><span class="line">    <span class="built_in">yourFunction1</span>(rows);</span><br><span class="line">    <span class="built_in">yourFunction2</span>(rows);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="114-reference"><a class="markdownIt-Anchor" href="#114-reference"></a> 11.4 Reference</h2>
<h3 id="1141-reference-initialization"><a class="markdownIt-Anchor" href="#1141-reference-initialization"></a> 11.4.1 Reference Initialization</h3>
<p><strong>引用只能在定义处初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> &amp;ref = a;</span><br><span class="line">    ref = b; <span class="comment">// a的值变为2</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ref=&quot;</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=2</span><br><span class="line">b=2</span><br><span class="line">ref=2</span><br></pre></td></tr></table></figure>
<h2 id="115-mock-class"><a class="markdownIt-Anchor" href="#115-mock-class"></a> 11.5 Mock class</h2>
<p>有时在测试的时候，我们需要mock一个类的实现，我们可以在测试的cpp文件中实现这个类的所有方法（<strong>注意，必须是所有方法</strong>），就能够覆盖原有库文件中的实现。下面以一个例子来说明</p>
<p><strong>目录结构如下</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── lib</span><br><span class="line">│   ├── libperson.a</span><br><span class="line">│   ├── person.cpp</span><br><span class="line">│   ├── person.h</span><br><span class="line">│   └── person.o</span><br><span class="line">└── main.cpp</span><br></pre></td></tr></table></figure>
<p><strong><code>lib/person.h</code>内容如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><code>lib/person.cpp</code>内容如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;work&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sleep&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;eat&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译<code>person.cpp</code>生成链接文件，并生成<code>.a</code>归档文件</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定-c参数，只生成目标文件（person.o），不进行链接</span></span><br><span class="line">g++ person.cpp -c -std=gnu++11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成归档文件</span></span><br><span class="line">ar crv libperson.a person.o</span><br></pre></td></tr></table></figure>
<p><strong><code>main.cpp</code>内容如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib/person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.<span class="built_in">work</span>();</span><br><span class="line">    person.<span class="built_in">sleep</span>();</span><br><span class="line">    person.<span class="built_in">eat</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>编译<code>main.cpp</code>并执行</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="comment"># -L参数将lib目录加入到库文件的扫描路径</span></span><br><span class="line"><span class="comment"># -l参数指定需要链接的库文件</span></span><br><span class="line">g++ -o main main.cpp -std=gnu++11 -L lib -lperson</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行，输出如下</span></span><br><span class="line">./main</span><br><span class="line"></span><br><span class="line">work</span><br><span class="line"><span class="built_in">sleep</span></span><br><span class="line">eat</span><br></pre></td></tr></table></figure>
<p><strong>接下来，我们修改<code>main.cpp</code>，覆盖原有的<code>work</code>、<code>sleep</code>、<code>eat</code>方法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib/person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock work&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock sleep&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock eat&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.<span class="built_in">work</span>();</span><br><span class="line">    person.<span class="built_in">sleep</span>();</span><br><span class="line">    person.<span class="built_in">eat</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>编译<code>main.cpp</code>并执行</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="comment"># -L参数将lib目录加入到库文件的扫描路径</span></span><br><span class="line"><span class="comment"># -l参数指定需要链接的库文件</span></span><br><span class="line">g++ -o main main.cpp -std=gnu++11 -L lib -lperson</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行，输出如下，可以发现，都变成了mock版本</span></span><br><span class="line">./main</span><br><span class="line"></span><br><span class="line">mock work</span><br><span class="line">mock <span class="built_in">sleep</span></span><br><span class="line">mock eat</span><br></pre></td></tr></table></figure>
<p><strong>然后，我们继续修改<code>main.cpp</code>，删去其中一个方法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib/person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock work&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock sleep&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void Person::eat() &#123;</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; &quot;mock eat&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.<span class="built_in">work</span>();</span><br><span class="line">    person.<span class="built_in">sleep</span>();</span><br><span class="line">    person.<span class="built_in">eat</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>编译<code>main.cpp</code>（编译会失败）</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="comment"># -L参数将lib目录加入到库文件的扫描路径</span></span><br><span class="line"><span class="comment"># -l参数指定需要链接的库文件</span></span><br><span class="line">g++ -o main main.cpp -std=gnu++11 -L lib -lperson</span><br><span class="line"></span><br><span class="line">lib/libperson.a(person.o)：在函数‘Person::work()’中：</span><br><span class="line">person.cpp:(.text+0x0): Person::work() 的多重定义</span><br><span class="line">/tmp/ccfhnlz4.o:main.cpp:(.text+0x0)：第一次在此定义</span><br><span class="line">lib/libperson.a(person.o)：在函数‘Person::<span class="built_in">sleep</span>()’中：</span><br><span class="line">person.cpp:(.text+0x2a): Person::<span class="built_in">sleep</span>() 的多重定义</span><br><span class="line">/tmp/ccfhnlz4.o:main.cpp:(.text+0x2a)：第一次在此定义</span><br><span class="line">collect2: 错误：ld 返回 1</span><br></pre></td></tr></table></figure>
<h2 id="116-non-template-parameter-pack"><a class="markdownIt-Anchor" href="#116-non-template-parameter-pack"></a> 11.6 Non-template parameter pack</h2>
<p><strong>非模板参数包有如下几个特点：</strong></p>
<ul>
<li>只能独立出现。<code>int nums...</code>也是合法的，但是不是参数包</li>
<li>无法知道其长度，只能显式传递其个数，比如<code>printf</code>通过占位符来隐式传递参数个数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        result += <span class="built_in">va_arg</span>(args, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;            <span class="comment">// Output: 6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>) &lt;&lt; std::endl; <span class="comment">// Output: 150</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="117-variable-length-array"><a class="markdownIt-Anchor" href="#117-variable-length-array"></a> 11.7 Variable-length Array</h2>
<p>Variable-length array (VLA), which is a feature not supported by standard C++. However, some compilers, particularly in C and as extensions in C++, do provide support for VLAs.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> array[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int32_t</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> num1;</span><br><span class="line">    <span class="type">int32_t</span> num2;</span><br><span class="line">    <span class="type">int32_t</span> array1[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int32_t</span> num3;</span><br><span class="line">    <span class="type">int32_t</span> array2[std::<span class="built_in">atoi</span>(argv[<span class="number">1</span>])];</span><br><span class="line">    <span class="type">int32_t</span> num4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> offset = [&amp;num1](<span class="type">void</span>* p) &#123; <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int8_t</span>*&gt;(p) - <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int8_t</span>*&gt;(&amp;num1); &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num1: &quot;</span> &lt;&lt; <span class="built_in">offset</span>(&amp;num1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num2: &quot;</span> &lt;&lt; <span class="built_in">offset</span>(&amp;num2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;array1: &quot;</span> &lt;&lt; <span class="built_in">offset</span>(&amp;array1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num3: &quot;</span> &lt;&lt; <span class="built_in">offset</span>(&amp;num3) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;array2: &quot;</span> &lt;&lt; <span class="built_in">offset</span>(&amp;array2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num4: &quot;</span> &lt;&lt; <span class="built_in">offset</span>(&amp;num4) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">./main 1</span><br><span class="line">num1: 0</span><br><span class="line">num2: -4</span><br><span class="line">array1: -8</span><br><span class="line">num3: -12</span><br><span class="line">array2: -148</span><br><span class="line">num4: -32</span><br><span class="line"></span><br><span class="line">./main 100</span><br><span class="line">num1: 0</span><br><span class="line">num2: -4</span><br><span class="line">array1: -8</span><br><span class="line">num3: -12</span><br><span class="line">array2: -532</span><br><span class="line">num4: -32</span><br></pre></td></tr></table></figure>
<h2 id="118-container"><a class="markdownIt-Anchor" href="#118-container"></a> 11.8 Container</h2>
<h3 id="1181-vectorpush_back"><a class="markdownIt-Anchor" href="#1181-vectorpush_back"></a> 11.8.1 vector::push_back</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Default Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp; foo) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(Foo&amp;&amp; foo) &#123; std::cout &lt;&lt; <span class="string">&quot;Move Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Foo <span class="title">getFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;Foo&gt; v;</span><br><span class="line">    <span class="comment">// Avoid scale up</span></span><br><span class="line">    v.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Without std::move&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// This move operation is possible because the object returned by getFoo() is an rvalue, which is eligible for move semantics.</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">getFoo</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;With std::move (1)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(<span class="built_in">getFoo</span>()));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;With std::move (2)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Foo foo = <span class="built_in">getFoo</span>();</span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(foo));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="12-faq"><a class="markdownIt-Anchor" href="#12-faq"></a> 12 FAQ</h1>
<h2 id="121-why-is-it-unnecessary-to-specify-the-size-when-releasing-memory-with-free-and-delete"><a class="markdownIt-Anchor" href="#121-why-is-it-unnecessary-to-specify-the-size-when-releasing-memory-with-free-and-delete"></a> 12.1 Why is it unnecessary to specify the size when releasing memory with free and delete</h2>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1518711/how-does-free-know-how-much-to-free">How does free know how much to free?</a></p>
<p>分配内存时，除了分配指定的内存之外，还会分配一个<code>header</code>，用于存储一些信息，例如</p>
<ul>
<li><strong><code>size</code></strong></li>
<li><code>special marker</code></li>
<li><code>checksum</code></li>
<li><code>pointers to next/previous block</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">____ The allocated block ____</span><br><span class="line">/                             \</span><br><span class="line">+--------+--------------------+</span><br><span class="line">| Header | Your data area ... |</span><br><span class="line">+--------+--------------------+</span><br><span class="line">          ^</span><br><span class="line">          |</span><br><span class="line">          +-- The address you are given</span><br></pre></td></tr></table></figure>
<h2 id="122-do-parameter-types-require-lvalue-or-rvalue-references"><a class="markdownIt-Anchor" href="#122-do-parameter-types-require-lvalue-or-rvalue-references"></a> 12.2 Do parameter types require lvalue or rvalue references</h2>
<h2 id="123-does-the-return-type-require-lvalue-or-rvalue-references"><a class="markdownIt-Anchor" href="#123-does-the-return-type-require-lvalue-or-rvalue-references"></a> 12.3 Does the return type require lvalue or rvalue references</h2>
<h1 id="13-参考"><a class="markdownIt-Anchor" href="#13-参考"></a> 13 参考</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8c4952e9edec">C++11\14\17\20 特性介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://www.codenong.com/1563897/">关于C++：静态常量字符串(类成员)</a></li>
<li><a target="_blank" rel="noopener" href="https://hownot2code.com/2016/12/05/do-while-0-in-macros/">do {…} while (0) in macros</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/c/PRE10-C.+Wrap+multistatement+macros+in+a+do-while+loop">PRE10-C. Wrap multistatement macros in a do-while loop</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-const-keyword.html">C++ const 关键字小结</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-casting-operators.html">C++ 强制转换运算符</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used">When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12566228/candidate-template-ignored-because-template-argument-could-not-be-inferred">Candidate template ignored because template argument could not be inferred</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/60438079/calling-a-member-function-pointer-from-outside-the-class-is-it-possible">calling a member function pointer from outside the class - is it possible?</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83449008">带你深入理解内存对齐最底层原理</a></li>
<li><a target="_blank" rel="noopener" href="https://light-city.club/sc/">C++那些事</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ethernut.de/en/documents/arm-inline-asm.html">ARM GCC Inline Assembler Cookbook</a></li>
<li><a target="_blank" rel="noopener" href="https://www.felixcloutier.com/documents/gcc-asm.html#constraints">GCC’s assembler syntax</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag"># 原创</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/09/06/Cpp-Meta-Programming/" rel="prev" title="Cpp-Meta-Programming">
      <i class="fa fa-chevron-left"></i> Cpp-Meta-Programming
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/06/Cpp-Standard-Library/" rel="next" title="Cpp-Standard-Library">
      Cpp-Standard-Library <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-valine">valine</a></li>
            <li class="tab"><a href="#comment-livere">livere</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzY0My8xMDE5OA=="></div>
  </div>
  
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-features"><span class="nav-text"> 1 Features</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-preprocessor-directives"><span class="nav-text"> 2 Preprocessor Directives</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#21-conditions"><span class="nav-text"> 2.1 Conditions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-define"><span class="nav-text"> 2.2 #define</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#221-work-with-compiler"><span class="nav-text"> 2.2.1 Work with compiler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#222-tips"><span class="nav-text"> 2.2.2 Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2221-do-while0-in-macros"><span class="nav-text"> 2.2.2.1 do while(0) in macros</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2222-variant"><span class="nav-text"> 2.2.2.2 Variant</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2223-comma-problem"><span class="nav-text"> 2.2.2.3 Comma Problem</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-variadic-macros"><span class="nav-text"> 2.3 Variadic Macros</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-pragma"><span class="nav-text"> 2.4 #pragma</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-error"><span class="nav-text"> 2.5 #error</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-%E5%8F%82%E8%80%83"><span class="nav-text"> 2.6 参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-key-word"><span class="nav-text"> 3 Key Word</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#31-type-qualifier"><span class="nav-text"> 3.1 Type Qualifier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#311-const"><span class="nav-text"> 3.1.1 const</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3111-topbottom-level-const"><span class="nav-text"> 3.1.1.1 Top&#x2F;Bottom Level const</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3112-const-actual-and-formal-parameters"><span class="nav-text"> 3.1.1.2 const Actual and Formal Parameters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3113-const-member"><span class="nav-text"> 3.1.1.3 const Member</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3114-const-member-function"><span class="nav-text"> 3.1.1.4 const Member Function</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#312-volatile"><span class="nav-text"> 3.1.2 volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3121-visibility-verification"><span class="nav-text"> 3.1.2.1 Visibility Verification</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3122-atomicity-verification"><span class="nav-text"> 3.1.2.2 Atomicity Verification</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#313-mutable"><span class="nav-text"> 3.1.3 mutable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-other-specifiers"><span class="nav-text"> 3.2 Other Specifiers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#321-inline"><span class="nav-text"> 3.2.1 inline</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-type-length"><span class="nav-text"> 3.3 Type Length</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#331-memory-alignment"><span class="nav-text"> 3.3.1 Memory Alignment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#332-sizeof"><span class="nav-text"> 3.3.2 sizeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#333-alignof"><span class="nav-text"> 3.3.3 alignof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#334-alignas"><span class="nav-text"> 3.3.4 alignas</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-type-inference"><span class="nav-text"> 3.4 Type Inference</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#341-auto"><span class="nav-text"> 3.4.1 auto</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#342-decltype"><span class="nav-text"> 3.4.2 decltype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#343-typeof"><span class="nav-text"> 3.4.3 typeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#344-typeid"><span class="nav-text"> 3.4.4 typeid</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-type-conversion"><span class="nav-text"> 3.5 Type Conversion</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#351-static_cast"><span class="nav-text"> 3.5.1 static_cast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#352-dynamic_cast"><span class="nav-text"> 3.5.2 dynamic_cast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#353-const_cast"><span class="nav-text"> 3.5.3 const_cast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#354-reinterpret_cast"><span class="nav-text"> 3.5.4 reinterpret_cast</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-storage-class-specifiers"><span class="nav-text"> 3.6 Storage Class Specifiers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#361-static"><span class="nav-text"> 3.6.1 static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#362-extern"><span class="nav-text"> 3.6.2 extern</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3621-shared-global-variable"><span class="nav-text"> 3.6.2.1 Shared Global Variable</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#363-thread_local"><span class="nav-text"> 3.6.3 thread_local</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3631-initialization"><span class="nav-text"> 3.6.3.1 Initialization</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-inheritance-and-polymorphism"><span class="nav-text"> 3.7 Inheritance and Polymorphism</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#371-inheritance-modes"><span class="nav-text"> 3.7.1 Inheritance Modes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#372-virtual"><span class="nav-text"> 3.7.2 virtual</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3721-virtual-destructor"><span class="nav-text"> 3.7.2.1 virtual destructor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#373-final"><span class="nav-text"> 3.7.3 final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#374-override"><span class="nav-text"> 3.7.4 override</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-constexpr"><span class="nav-text"> 3.8 constexpr</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#381-if-constexpr"><span class="nav-text"> 3.8.1 if constexpr</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-static_assert"><span class="nav-text"> 3.9 static_assert</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#310-noexcept"><span class="nav-text"> 3.10 noexcept</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#311-throw-and-error"><span class="nav-text"> 3.11 throw and error</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#312-placement-new"><span class="nav-text"> 3.12 placement new</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-template"><span class="nav-text"> 4 template</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#41-template-type"><span class="nav-text"> 4.1 template Type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-template-argument-type"><span class="nav-text"> 4.2 template Argument Type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-template-parameter-pack"><span class="nav-text"> 4.3 template Parameter Pack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-fold-expressions"><span class="nav-text"> 4.4 Fold Expressions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-traverse-parameter-pack"><span class="nav-text"> 4.5 Traverse Parameter Pack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#451-parenthesis-initializer"><span class="nav-text"> 4.5.1 Parenthesis Initializer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#452-constexpr-for"><span class="nav-text"> 4.5.2 constexpr for</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-non-type-template-parameter"><span class="nav-text"> 4.6 Non-Type template Parameter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-when-template-parameters-cannot-be-inferred"><span class="nav-text"> 4.7 When template parameters cannot be inferred</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-using-typename-to-disambiguate"><span class="nav-text"> 4.8 Using typename to Disambiguate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49-using-template-to-disambiguate"><span class="nav-text"> 4.9 Using template to Disambiguate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#410-defining-a-type-alias-in-a-template-parameter-list"><span class="nav-text"> 4.10 Defining a type alias in a template parameter list</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#411-accessing-members-of-a-template-parent-class-from-a-non-template-derived-class"><span class="nav-text"> 4.11 Accessing members of a template parent class from a non-template derived class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#412-accessing-members-of-a-template-parent-class-from-a-template-derived-class"><span class="nav-text"> 4.12 Accessing members of a template parent class from a template derived class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#413-template-as-a-template-parameter"><span class="nav-text"> 4.13 template as a template Parameter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#414-separating-the-definition-and-implementation-of-a-template"><span class="nav-text"> 4.14 Separating the definition and implementation of a template</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#415-crtp"><span class="nav-text"> 4.15 CRTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4151-static-polymorphism"><span class="nav-text"> 4.15.1 Static Polymorphism</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4152-object-counter"><span class="nav-text"> 4.15.2 Object Counter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4153-polymorphic-chaining"><span class="nav-text"> 4.15.3 Polymorphic Chaining</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4154-polymorphic-copy-construction"><span class="nav-text"> 4.15.4 Polymorphic Copy Construction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#416-pimpl"><span class="nav-text"> 4.16 PIMPL</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-memory-model"><span class="nav-text"> 5 Memory Model</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#51-concepts"><span class="nav-text"> 5.1 Concepts</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#511-cache-coherence-memory-consistency"><span class="nav-text"> 5.1.1 Cache coherence &amp; Memory consistency</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#512-happens-before"><span class="nav-text"> 5.1.2 Happens-before</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-memory-consistency-model"><span class="nav-text"> 5.2 Memory consistency model</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#521-sequential-consistency-model"><span class="nav-text"> 5.2.1 Sequential consistency model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#522-relaxed-consistency-model"><span class="nav-text"> 5.2.2 Relaxed consistency model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#523-total-store-order"><span class="nav-text"> 5.2.3 Total Store Order</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-stdmemory_order"><span class="nav-text"> 5.3 std::memory_order</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54-cases"><span class="nav-text"> 5.4 Cases</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#541-case-1-happens-before"><span class="nav-text"> 5.4.1 Case-1-happens-before</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#542-case-2-write-read-reorder"><span class="nav-text"> 5.4.2 Case-2-write-read-reorder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#543-case-3-write-write-read-read-reorder"><span class="nav-text"> 5.4.3 Case-3-write-write-read-read-reorder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#544-case-4-write-order-consistency"><span class="nav-text"> 5.4.4 Case-4-write-order-consistency</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#545-case-5-visibility"><span class="nav-text"> 5.4.5 Case-5-visibility</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#546-case-6-eventual-consistency"><span class="nav-text"> 5.4.6 Case-6-eventual-consistency</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55-x86-memory-model"><span class="nav-text"> 5.5 x86 Memory Model</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56-%E5%8F%82%E8%80%83"><span class="nav-text"> 5.6 参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-lambda"><span class="nav-text"> 6 Lambda</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#61-stdfunction-and-lambda"><span class="nav-text"> 6.1 std::function and Lambda</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-coroutine"><span class="nav-text"> 7 Coroutine</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#71-overview-of-promise_type"><span class="nav-text"> 7.1 Overview of promise_type</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#711-awaiter"><span class="nav-text"> 7.1.1 Awaiter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72-example"><span class="nav-text"> 7.2 Example</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-attributes"><span class="nav-text"> 8 Attributes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#81-aligned"><span class="nav-text"> 8.1 aligned</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#82-%E5%8F%82%E8%80%83"><span class="nav-text"> 8.2 参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-asm"><span class="nav-text"> 9 ASM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#91-basic-asm"><span class="nav-text"> 9.1 Basic Asm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#92-extended-asm"><span class="nav-text"> 9.2 Extended Asm</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-policy"><span class="nav-text"> 10 Policy</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#101-pointer-stability"><span class="nav-text"> 10.1 Pointer Stability</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#102-exception-safe"><span class="nav-text"> 10.2 Exception Safe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#103-raii"><span class="nav-text"> 10.3 RAII</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-tips"><span class="nav-text"> 11 Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#111-class-related"><span class="nav-text"> 11.1 Class Related</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1111-how-to-define-static-members-in-a-class"><span class="nav-text"> 11.1.1 How to define static members in a class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1112-non-static-members-of-a-class-cannot-undergo-type-deduction"><span class="nav-text"> 11.1.2 Non-static members of a class cannot undergo type deduction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#112-initialization"><span class="nav-text"> 11.2 Initialization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1121-initializer-list"><span class="nav-text"> 11.2.1 Initializer List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1122-various-initialization-types"><span class="nav-text"> 11.2.2 Various Initialization Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1123-initialization-order-of-class-members"><span class="nav-text"> 11.2.3 Initialization Order of class Members</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1124-initialization-of-static-local-variables"><span class="nav-text"> 11.2.4 Initialization of static Local Variables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1125-initialization-of-non-static-class-members"><span class="nav-text"> 11.2.5 Initialization of non-static class Members</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#113-pointer"><span class="nav-text"> 11.3 Pointer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1131-member-function-pointer"><span class="nav-text"> 11.3.1 Member Function Pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1132-how-to-pass-multi-dimensional-pointer-parameters"><span class="nav-text"> 11.3.2 How to pass multi-dimensional pointer parameters</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#114-reference"><span class="nav-text"> 11.4 Reference</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1141-reference-initialization"><span class="nav-text"> 11.4.1 Reference Initialization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#115-mock-class"><span class="nav-text"> 11.5 Mock class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#116-non-template-parameter-pack"><span class="nav-text"> 11.6 Non-template parameter pack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#117-variable-length-array"><span class="nav-text"> 11.7 Variable-length Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#118-container"><span class="nav-text"> 11.8 Container</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1181-vectorpush_back"><span class="nav-text"> 11.8.1 vector::push_back</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-faq"><span class="nav-text"> 12 FAQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#121-why-is-it-unnecessary-to-specify-the-size-when-releasing-memory-with-free-and-delete"><span class="nav-text"> 12.1 Why is it unnecessary to specify the size when releasing memory with free and delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122-do-parameter-types-require-lvalue-or-rvalue-references"><span class="nav-text"> 12.2 Do parameter types require lvalue or rvalue references</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#123-does-the-return-type-require-lvalue-or-rvalue-references"><span class="nav-text"> 12.3 Does the return type require lvalue or rvalue references</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-%E5%8F%82%E8%80%83"><span class="nav-text"> 13 参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liuyehcf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Liuyehcf</p>
  <div class="site-description" itemprop="description">大音希声，大象无形</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">287</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liuyehcf</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qhEhLuMeMOy1zgcBhkqUS6P8-gzGzoHsz',
      appKey     : 'uhkruDLNLNdL5rQjRBY2X9Ke',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
