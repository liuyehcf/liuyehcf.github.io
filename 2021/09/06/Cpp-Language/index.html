<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="阅读更多">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp-Language">
<meta property="og:url" content="http://example.com/2021/09/06/Cpp-Language/index.html">
<meta property="og:site_name" content="Liuye Notebook">
<meta property="og:description" content="阅读更多">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/Cpp-Language/virtual-method-table.jpeg">
<meta property="og:image" content="http://example.com/images/Cpp-Language/happens-before.png">
<meta property="article:published_time" content="2021-09-06T02:53:48.000Z">
<meta property="article:modified_time" content="2025-04-03T15:30:58.000Z">
<meta property="article:author" content="Liuyehcf">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Cpp-Language/virtual-method-table.jpeg">

<link rel="canonical" href="http://example.com/2021/09/06/Cpp-Language/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Cpp-Language | Liuye Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Liuye Notebook</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-explore">

    <a href="/explore/" rel="section"><i class="fa fa-sitemap fa-fw"></i>发现</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/06/Cpp-Language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Liuyehcf">
      <meta itemprop="description" content="大音希声，大象无形">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liuye Notebook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Cpp-Language
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-06 10:53:48" itemprop="dateCreated datePublished" datetime="2021-09-06T10:53:48+08:00">2021-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-03 23:30:58" itemprop="dateModified" datetime="2025-04-03T23:30:58+08:00">2025-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          
            <span id="/2021/09/06/Cpp-Language/" class="post-meta-item leancloud_visitors" data-flag-title="Cpp-Language" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/06/Cpp-Language/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/06/Cpp-Language/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>阅读更多</strong></p>
<span id="more"></span>
<h1 id="1-features"><a class="markdownIt-Anchor" href="#1-features"></a> 1 Features</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/AnthonyCalandra/modern-cpp-features">modern-cpp-features</a></p>
<h1 id="2-preprocessor-directives"><a class="markdownIt-Anchor" href="#2-preprocessor-directives"></a> 2 Preprocessor Directives</h1>
<h2 id="21-conditions"><a class="markdownIt-Anchor" href="#21-conditions"></a> 2.1 Conditions</h2>
<p>预处理器支持有条件地编译源文件的某些部分。这一行为由<code>#if</code>、<code>#else</code>、<code>#elif</code>、<code>#ifdef</code>、<code>#ifndef</code>与<code>#endif</code>指令所控制</p>
<h2 id="22-define"><a class="markdownIt-Anchor" href="#22-define"></a> 2.2 <code>#define</code></h2>
<p><strong><code>ANSI C</code>标准中有几个标准预定义宏（也是常用的）：</strong></p>
<ul>
<li><code>__LINE__</code>：在源代码中插入当前源代码行号</li>
<li><code>__FILE__</code>：在源文件中插入当前源文件名</li>
<li><code>__FUNCTION__</code>：函数名</li>
<li><code>__PRETTY_FUNCTION__</code>：函数签名</li>
<li><code>__DATE__</code>：在源文件中插入当前的编译日期</li>
<li><code>__TIME__</code>：在源文件中插入当前编译时间</li>
<li><code>__STDC__</code>：当要求程序严格遵循<code>ANSI C</code>标准时该标识被赋值为1</li>
<li><code>__cplusplus</code>：当编写<code>C++</code>程序时该标识符被定义</li>
</ul>
<p><strong>语法：</strong></p>
<ul>
<li><code>#</code>：字符串化操作符</li>
<li><code>##</code>：连接操作符</li>
<li><code>\</code>：续行操作符</li>
</ul>
<h3 id="221-work-with-compiler"><a class="markdownIt-Anchor" href="#221-work-with-compiler"></a> 2.2.1 Work with compiler</h3>
<p>macros are preprocessor directives, and they get processed before the actual compilation phase. One of the most common preprocessor directives is <code>#define</code> which is used to define macros.</p>
<p>If you want to change a macro definition at compile time, there are several ways to do it:</p>
<p><strong>Using Compiler Flags</strong>: You can use the <code>-D</code> flag (for most compilers like GCC and Clang) to define macros.</p>
<ul>
<li>
<p>For example, suppose you have the following code:</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_MACRO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MACRO <span class="string">&quot;Default Value&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; MY_MACRO &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>You can change <code>MY_MACRO</code> at compile time as:</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ your_file.cpp -o output -DMY_MACRO=<span class="string">&#x27;&quot;Compile Time Value&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>When you run the output, it will print “Compile Time Value”.</p>
</li>
</ul>
<p><strong>Using Conditional Compilation:</strong> This is where you use <code>#ifdef</code>, <code>#ifndef</code>, <code>#else</code>, and <code>#endif</code> directives to conditionally compile parts of your code based on whether a certain macro is defined or not.</p>
<ul>
<li>
<p>Here’s an example:</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="comment">// code for debugging</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// regular code</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>You can then define or not define DEBUG using the -D flag at compile time:</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ your_file.cpp -o output -DDEBUG</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="222-tips"><a class="markdownIt-Anchor" href="#222-tips"></a> 2.2.2 Tips</h3>
<h4 id="2221-do-while0-in-macros"><a class="markdownIt-Anchor" href="#2221-do-while0-in-macros"></a> 2.2.2.1 do while(0) in macros</h4>
<p>考虑下面的宏定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(x) bar(x); baz(x)</span></span><br></pre></td></tr></table></figure>
<p>然后我们调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foo</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>会被展开为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bar</span>(wolf); <span class="built_in">baz</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>看起来没有问题，我们接着考虑另一个情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) </span><br><span class="line">    <span class="built_in">foo</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>会被展开为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) </span><br><span class="line">    <span class="built_in">bar</span>(wolf);</span><br><span class="line"><span class="built_in">baz</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>这并不符合我们的预期，为了避免出现这种问题，需要用一个作用域将宏包围起来，避免语句的作用域发生偏移，于是我们进一步将宏表示为如下形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(x) &#123; bar(x); baz(x); &#125;</span></span><br></pre></td></tr></table></figure>
<p>然后我们调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    <span class="built_in">foo</span>(wolf);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">bin</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>会被展开为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="built_in">bar</span>(wolf);</span><br><span class="line">    <span class="built_in">baz</span>(wolf);</span><br><span class="line">&#125;; <span class="comment">// syntax error</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">bin</span>(wolf);</span><br></pre></td></tr></table></figure>
<p>最终，我们将宏优化成如下形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> foo(x) do &#123; bar(x); baz(x); &#125; while (0)</span></span><br></pre></td></tr></table></figure>
<h4 id="2222-variant"><a class="markdownIt-Anchor" href="#2222-variant"></a> 2.2.2.2 Variant</h4>
<p>借助宏的嵌套，以及约定命名规则，我们可以实现自动生成<code>else if</code>分支，示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APPLY_FOR_PARTITION_VARIANT_ALL(M) \</span></span><br><span class="line"><span class="meta">    M(_int)                                \</span></span><br><span class="line"><span class="meta">    M(_long)                               \</span></span><br><span class="line"><span class="meta">    M(_double)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">HashMapVariantType</span> &#123; _int, _long, _double &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashMapVariant</span> &#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; _int;</span><br><span class="line">    std::map&lt;<span class="type">long</span>, <span class="type">long</span>&gt; _long;</span><br><span class="line">    std::map&lt;<span class="type">double</span>, <span class="type">double</span>&gt; _double;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HashMapVariant hash_map_variant;</span><br><span class="line">HashMapVariantType type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_int_map</span><span class="params">(std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; map)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;handle int map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_long_map</span><span class="params">(std::map&lt;<span class="type">long</span>, <span class="type">long</span>&gt;&amp; map)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;handle long map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_double_map</span><span class="params">(std::map&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&amp; map)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;handle double map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dispatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_MAP_METHOD(NAME)                      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> <span class="keyword">if</span> (type == HashMapVariantType::NAME) &#123;   \</span></span><br><span class="line"><span class="meta">        handle##NAME##_map(hash_map_variant.NAME); \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line">    <span class="built_in">APPLY_FOR_PARTITION_VARIANT_ALL</span>(HASH_MAP_METHOD)</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HASH_MAP_METHOD</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    type = HashMapVariantType::_int;</span><br><span class="line">    <span class="built_in">dispatch</span>();</span><br><span class="line">    type = HashMapVariantType::_long;</span><br><span class="line">    <span class="built_in">dispatch</span>();</span><br><span class="line">    type = HashMapVariantType::_double;</span><br><span class="line">    <span class="built_in">dispatch</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述功能完全可以由<code>std::variant</code>实现，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::variant&lt;std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::map&lt;<span class="type">long</span>, <span class="type">long</span>&gt;, std::map&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt; hash_map_variant;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; map)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;handle int map&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::map&lt;<span class="type">long</span>, <span class="type">long</span>&gt;&amp; map)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;handle long map&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::map&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&amp; map)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;handle double map&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lambda_visitor = [](<span class="keyword">auto</span>&amp; map) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(map)&gt;, std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;handle int map by lambda&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(map)&gt;, std::map&lt;<span class="type">long</span>, <span class="type">long</span>&gt;&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;handle long map by lambda&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(map)&gt;, std::map&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;handle double map by lambda&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Visitor visitor;</span><br><span class="line"></span><br><span class="line">    hash_map_variant = std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">    std::<span class="built_in">visit</span>(visitor, hash_map_variant);</span><br><span class="line">    std::<span class="built_in">visit</span>(lambda_visitor, hash_map_variant);</span><br><span class="line"></span><br><span class="line">    hash_map_variant = std::map&lt;<span class="type">long</span>, <span class="type">long</span>&gt;&#123;&#125;;</span><br><span class="line">    std::<span class="built_in">visit</span>(visitor, hash_map_variant);</span><br><span class="line">    std::<span class="built_in">visit</span>(lambda_visitor, hash_map_variant);</span><br><span class="line"></span><br><span class="line">    hash_map_variant = std::map&lt;<span class="type">double</span>, <span class="type">double</span>&gt;&#123;&#125;;</span><br><span class="line">    std::<span class="built_in">visit</span>(visitor, hash_map_variant);</span><br><span class="line">    std::<span class="built_in">visit</span>(lambda_visitor, hash_map_variant);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2223-comma-problem"><a class="markdownIt-Anchor" href="#2223-comma-problem"></a> 2.2.2.3 Comma Problem</h4>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4496842/pass-method-with-template-arguments-to-a-macro">pass method with template arguments to a macro</a></p>
<p>示例如下，我们定义了一个参数的宏<code>MY_MACRO</code>：</p>
<ul>
<li><code>MY_MACRO(func&lt;flag1, flag2&gt;())</code>：这个调用会报错，因为逗号会被认为用于分隔两个宏参数</li>
<li><code>MY_MACRO((func&lt;flag1, flag2&gt;()))</code>：这个调用正常，因为用<code>()</code>将表达式包围后，会被认为是一个宏参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MACRO(stmt) \</span></span><br><span class="line"><span class="meta">    do &#123;               \</span></span><br><span class="line"><span class="meta">        &#123; stmt; &#125;      \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> flag1, <span class="type">bool</span> flag2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> flag1, <span class="type">bool</span> flag2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MY_MACRO(func&lt;flag1, flag2&gt;());</span></span><br><span class="line">    <span class="built_in">MY_MACRO</span>((<span class="built_in">func</span>&lt;flag1, flag2&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">call_func</span>&lt;<span class="literal">true</span>, <span class="literal">true</span>&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="223-macro-expansion"><a class="markdownIt-Anchor" href="#223-macro-expansion"></a> 2.2.3 Macro Expansion</h3>
<p><strong>Macro replacement proceeds left-to-right (<a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/1_85_0/libs/wave/doc/macro_expansion_process.html">The Macro Expansion Process</a>):</strong></p>
<ol>
<li>If, during scanning (or rescanning) an identifier is found, it is looked up in the symbol table. If the identifier is not found in the symbol table, it is not a macro and scanning continues.</li>
<li>If the identifier is found, the value of a flag associated with the identifier is used to determine if the identifier is available for expansion. If it is not, the specific token (i.e. the specific instance of the identifier) is marked as disabled and is not expanded. If the identifier is available for expansion, the value of a different flag associated with the identifier in the symbol table is used to determine if the identifier is an object-like or function-like macro. If it is an object-like macro, it is expanded. If it is a function-like macro, it is only expanded if the next token is an left parenthesis.</li>
<li>An identifier is available for expansion if it is not marked as disabled and if the the value of the flag associated with the identifier is not set, which is used to determine if the identifier is available for expansion.</li>
<li>If a macro is an object-like macro, skip past the next two paragraphs.</li>
<li>If a macro to be expanded is a function-like macro, it must have the exact number of actual arguments as the number of formal parameters required by the definition of the macro. Each argument is recursively scanned and expanded. Each parameter name found in the replacement list is replaced by the expanded actual argument after leading and trailing whitespace and all placeholder tokens are removed <strong>unless the parameter name immediately follows the stringizing operator (<code>#</code>) or is adjacent to the token-pasting operator (<code>##</code>)</strong>.</li>
<li><strong>If the parameter name immediately follows the stringizing operator (<code>#</code>), a stringized version of the unexpanded actual argument is inserted</strong>. If the parameter name is adjacent to the token-pasting operator (<code>##</code>), the unexpanded actual argument is inserted after all placeholder tokens are removed.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Concat x and y, both parameters won&#x27;t be expanded before concatenation, and the result of concatenation can be expanded if possible</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOKEN_CONCAT(x, y) x##y</span></span><br><span class="line"><span class="comment">// Make sure x and y are fully expanded</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOKEN_CONCAT_FORWARD(x, y) TOKEN_CONCAT(x, y)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_INT_1 int prefix_1_##__LINE__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_INT_2 int TOKEN_CONCAT(prefix_2_, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_INT_3 int TOKEN_CONCAT_FORWARD(prefix_3_, __LINE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINE_NUMBER_AS_VALUE TOKEN_CONCAT(__LINE, __)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DEFINE_INT_1 = <span class="number">1</span>;</span><br><span class="line">    DEFINE_INT_2 = <span class="number">2</span>;</span><br><span class="line">    DEFINE_INT_3 = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> i4 = LINE_NUMBER_AS_VALUE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>For <code>DEFINE_INT_1</code>, <code>DEFINE_INT_2</code> and <code>DEFINE_INT_3</code>, only <code>DEFINE_INT_3</code> works as we expected.
<ul>
<li>when you use <code>TOKEN_CONCAT</code> or <code>#</code> directly with macro arguments, it won’t expand those arguments before concatenation. This means if <code>x</code> or <code>y</code> are themselves macros, they will not be expanded before concatenation.</li>
<li>The <code>TOKEN_CONCAT_FORWARD</code> macro is a forward macro that ensures its arguments are fully expanded before passing them to <code>TOKEN_CONCAT</code></li>
</ul>
</li>
<li>For <code>LINE_NUMBER_AS_VALUE</code>, the expansion happens after the concatenation.</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.cpp</span><br><span class="line"><span class="comment"># 0 &quot;main.cpp&quot;</span></span><br><span class="line"><span class="comment"># 0 &quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"><span class="comment"># 0 &quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"><span class="comment"># 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4</span></span><br><span class="line"><span class="comment"># 0 &quot;&lt;command-line&gt;&quot; 2</span></span><br><span class="line"><span class="comment"># 1 &quot;main.cpp&quot;</span></span><br><span class="line"><span class="comment"># 11 &quot;main.cpp&quot;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    int prefix_1___LINE__ = 1;</span><br><span class="line">    int prefix_2___LINE__ = 2;</span><br><span class="line">    int prefix_3_14 = 3;</span><br><span class="line">    int i4 = 15;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="23-variadic-macros"><a class="markdownIt-Anchor" href="#23-variadic-macros"></a> 2.3 Variadic Macros</h2>
<p>宏也支持可变参数，通过<code>__VA_ARGS__</code>引用这些参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW_SUM_UP(...) std::cout &lt;&lt; sum(__VA_ARGS__) &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nums[] = &#123;args...&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>...(args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SHOW_SUM_UP</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="24-pragma"><a class="markdownIt-Anchor" href="#24-pragma"></a> 2.4 <code>#pragma</code></h2>
<p>在<code>C++</code>中，<code>#pragma</code>是一个预处理器指令（<code>preprocessor directive</code>），它用于向编译器发出一些特定的命令或提示，从而控制编译器的行为。<code>#pragma</code>通常用于开启或关闭某些编译器的特性、设置编译器选项、指定链接库等</p>
<p><code>#pragma</code>指令不是<code>C++</code>的标准特性，而是编译器提供的扩展。不同的编译器可能支持不同的<code>#pragma</code>指令，而且它们的行为也可能不同。因此在编写可移植的<code>C++</code>代码时应尽量避免使用它们</p>
<p>不同的编译器可能支持不同的<code>#pragma</code>指令，以下是一些常用的<code>#pragma</code>指令及其作用</p>
<ul>
<li>
<p><code>#pragma once</code>：该指令用于避免头文件被多次包含，以解决头文件重复包含的问题。它告诉编译器只包含一次该头文件</p>
</li>
<li>
<p><code>#pragma pack</code>：该<code>pragma</code>族控制后继定义的结构体、联合体、类的最大对齐</p>
<ul>
<li><code>#pragma pack(&lt;arg&gt;)</code>：设置当前对齐为值<code>&lt;arg&gt;</code></li>
<li><code>#pragma pack()</code>：设置当前对齐为默认值（由命令行选项指定）</li>
<li><code>#pragma pack(push)</code>：推入当前对齐的值到内部栈</li>
<li><code>#pragma pack(push, &lt;arg&gt;)</code>：推入当前对齐的值到内部栈然后设置当前对齐为值<code>&lt;arg&gt;</code></li>
<li><code>#pragma pack(pop)</code>：从内部栈弹出顶条目然后设置（恢复）当前对齐为该值</li>
<li>其中<code>&lt;arg&gt;</code>实参是小的<code>2</code>的幂，指定以字节计的新对齐</li>
</ul>
</li>
<li>
<p><code>#pragma message</code>：该指令用于在编译时输出一条消息</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> message(<span class="string">&quot;Compiling &quot;</span> __FILE__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>#pragma GCC diagnostic</code>：该指令用于控制编译器的警告和错误信息。可以用它来控制特定的警告或错误信息是否应该被忽略或显示</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">something</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic ignored <span class="string">&quot;-Wunused-result&quot;</span></span></span><br><span class="line">    <span class="built_in">something</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>#pragma omp</code>：该指令用于<code>OpenMP</code>并行编程，用于指定并行执行的方式</p>
</li>
</ul>
<h2 id="25-error"><a class="markdownIt-Anchor" href="#25-error"></a> 2.5 <code>#error</code></h2>
<p>显示给定的错误消息，并终止编译过程</p>
<h2 id="26-reference"><a class="markdownIt-Anchor" href="#26-reference"></a> 2.6 Reference</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://bot-man-jl.github.io/articles/?post=2020/Macro-Programming-Art">C/C++ 宏编程的艺术</a></li>
</ul>
<h1 id="3-key-word"><a class="markdownIt-Anchor" href="#3-key-word"></a> 3 Key Word</h1>
<h2 id="31-type-qualifier"><a class="markdownIt-Anchor" href="#31-type-qualifier"></a> 3.1 Type Qualifier</h2>
<h3 id="311-const"><a class="markdownIt-Anchor" href="#311-const"></a> 3.1.1 const</h3>
<p>默认状态下，<code>const</code>对象仅在文件内有效。编译器将在编译过程中把用到该变量的地方都替代成对应的值，也就是说，编译器会找到代码中所有用到该<code>const</code>变量的地方，然后将其替换成定义的值</p>
<p>为了执行上述替换，编译器必须知道变量的初始值，如果程序包含多个文件，则每个用了<code>const</code>对象的文件都必须能访问到它的初始值才行。要做到这一点，就必须在每一个用到该变量的文件中都对它有定义（将定义该<code>const</code>变量的语句放在头文件中，然后用到该变量的源文件包含头文件即可），为了支持这一用法，同时避免对同一变量的重复定义，默认情况下<code>const</code>被设定为尽在文件内有效（<code>const</code>的全局变量，其实只是在每个文件中都定义了一边而已）</p>
<p>有时候出现这样的情况：<code>const</code>变量的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件生成独立的变量，相反，我们想让这类<code>const</code>对象像其他对象一样工作。<strong>即：在一个文件中定义<code>const</code>，在多个文件中声明并使用它，无论声明还是定 义都添加<code>extern</code>关键字</strong></p>
<ul>
<li><code>.h</code>文件中：<code>extern const int a;</code></li>
<li><code>.cpp</code>文件中：<code>extern const int a=f();</code></li>
</ul>
<h4 id="3111-topbottom-level-const"><a class="markdownIt-Anchor" href="#3111-topbottom-level-const"></a> 3.1.1.1 Top/Bottom Level const</h4>
<p><strong>只有指针和引用才有顶层底层之分</strong></p>
<ul>
<li>顶层<code>const</code>属性表示对象本身不可变</li>
<li>底层<code>const</code>属性表示指向的对象不可变</li>
<li>引用的<code>const</code>属性只能是底层。因为引用本身不是对象，没法指定顶层的<code>const</code>属性</li>
<li>指针的<code>const</code>属性既可以是顶层又可以是底层
<ul>
<li>注意，只有<code>const</code>与<code>变量名</code>相邻时（中间不能有<code>*</code>），才算顶层<code>const</code>。例如下面例子中的<code>p1</code>和<code>p2</code>都是顶层<code>const</code></li>
</ul>
</li>
<li>指针的底层<code>const</code>是可以重新绑定的，例如下面例子中的<code>p1</code>和<code>p2</code></li>
<li>引用的底层<code>const</code>是无法重新绑定的，这是因为引用本身就不支持重新绑定，而非<code>const</code>的限制</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bottom level const</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* p1 = &amp;a;</span><br><span class="line">    p1 = &amp;c;</span><br><span class="line">    <span class="comment">// *p1 += 1; // compile error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// bottom level const</span></span><br><span class="line">    <span class="type">int</span> <span class="type">const</span>* p2 = &amp;b;</span><br><span class="line">    p2 = &amp;c;</span><br><span class="line">    <span class="comment">// *p2 += 1; // compile error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// top level const</span></span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> p3 = &amp;c;</span><br><span class="line">    <span class="comment">// p3 = &amp;a; // compile error</span></span><br><span class="line">    *p3 += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; r1 = a;</span><br><span class="line">    <span class="comment">// r1 = b; // compile error</span></span><br><span class="line">    <span class="comment">// r1 += 1; // compile error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>const</code>遵循如下规则：</strong></p>
<ul>
<li>顶层<code>const</code>可以访问<code>const</code>和非<code>const</code>的成员</li>
<li>底层<code>const</code>只能访问<code>const</code>的成员</li>
</ul>
<p>示例如下，可以发现：</p>
<ul>
<li><code>const Container* container</code>以及<code>const Container&amp; container</code>都只能访问<code>const</code>成员，而无法访问非<code>const</code>成员</li>
<li><code>Container* const container</code>可以访问<code>const</code>成员以及非<code>const</code>成员</li>
<li>特别地，<code>const ContainerPtr&amp; container</code>可以访问非<code>const</code>成员，这是因为<code>container-&gt;push_back(num)</code>是一个两级调用
<ul>
<li>第一级：访问的是<code>std::shared_ptr::operator-&gt;</code>运算符，该运算符是<code>const</code>的，且返回类型为<code>element_type*</code></li>
<li>第二级：通过返回的<code>element_type*</code>访问<code>std::vector::push_back</code>，因此与上述结论并不矛盾</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Container = std::vector&lt;<span class="type">int32_t</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> ContainerPtr = std::shared_ptr&lt;Container&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append_by_const_reference_shared_ptr</span><span class="params">(<span class="type">const</span> ContainerPtr&amp; container, <span class="type">const</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// can calling non-const member function</span></span><br><span class="line">    container-&gt;<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append_by_const_reference</span><span class="params">(<span class="type">const</span> Container&amp; container, <span class="type">const</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cannot calling non-const member function</span></span><br><span class="line">    <span class="comment">// container.push_back(num);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append_by_bottom_const_pointer</span><span class="params">(<span class="type">const</span> Container* container, <span class="type">const</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cannot calling non-const member function</span></span><br><span class="line">    <span class="comment">// container-&gt;push_back(num);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append_by_top_const_pointer</span><span class="params">(Container* <span class="type">const</span> container, <span class="type">const</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// can calling non-const member function</span></span><br><span class="line">    container-&gt;<span class="built_in">push_back</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3112-const-actual-and-formal-parameters"><a class="markdownIt-Anchor" href="#3112-const-actual-and-formal-parameters"></a> 3.1.1.2 const Actual and Formal Parameters</h4>
<p>实参初始化形参时会自动忽略掉顶层<code>const</code>属性</p>
<p>顶层<code>const</code>不影响形参的类型，例如下面的代码，编译会失败，错误信息是函数重定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> value)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3113-const-member"><a class="markdownIt-Anchor" href="#3113-const-member"></a> 3.1.1.3 const Member</h4>
<p>构造函数中显式初始化：在初始化部分进行初始化，而不能在函数体内初始化；如果没有显式初始化，就调用定义时的初始值进行初始化</p>
<h4 id="3114-const-member-function"><a class="markdownIt-Anchor" href="#3114-const-member-function"></a> 3.1.1.4 const Member Function</h4>
<p><strong><code>const</code>关键字修饰的成员函数，不能修改当前类的任何字段的值，如果字段是对象类型，也不能调用非<code>const</code>修饰的成员方法。（有一个特例，就是当持有的是某个类型的指针时，可以通过该指针调用非<code>const</code>方法）</strong></p>
<p>常量对象以及常量对象的引用或指针都只能调用常量成员函数</p>
<p>常量对象以及常量对象的引用或指针都可以调用常量成员函数以及非常量成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello1</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello world, const version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello world, non const version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Demo d;</span><br><span class="line">    d.<span class="built_in">sayHello1</span>();</span><br><span class="line">    d.<span class="built_in">sayHello2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Demo cd;</span><br><span class="line">    cd.<span class="built_in">sayHello1</span>();</span><br><span class="line">    <span class="comment">// the following statement will lead to compile error</span></span><br><span class="line">    <span class="comment">// cd.sayHello2();</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="312-volatile"><a class="markdownIt-Anchor" href="#312-volatile"></a> 3.1.2 volatile</h3>
<p><code>volatile</code>关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改（程序之外的因素），比如：操作系统、硬件等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问</p>
<ul>
<li><strong>仅从<code>C/C++</code>标准的角度来说（不考虑平台以及编译器扩展），<code>volatile</code>并不保证线程间的可见性</strong>。在实际场景中，例如<code>x86</code>平台，在<code>MESI</code>协议的支持下，<code>volatile</code>是可以保证可见性的，这可以理解为一个巧合，利用了平台相关性，因此不具备平台可移植性</li>
</ul>
<p><code>Java</code>中也有<code>volatile</code>关键字，但作用完全不同，<code>Java</code>在语言层面就保证了<code>volatile</code>具有线程可见性</p>
<ul>
<li><code>x86</code>
<ul>
<li>仅依赖<code>MESI</code>协议，可能也无法实现可见性。举个例子，当<code>CPU1</code>执行写操作时，要等到其他<code>CPU</code>将对应的缓存行设置成<code>I</code>状态后，写入才能完成，性能较差，于是<code>CPU</code>又引入了<code>Store Buffer</code>（<code>MESI</code>协议不感知<code>Store Buffer</code>），<code>CPU1</code>只需要将数据写入<code>Store Buffer</code>而不用等待其他<code>CPU</code>将缓存行设置成<code>I</code>状态就可以干其他事了</li>
<li>为了解决上述问题，<code>JVM</code>使用了<code>lock</code>前缀的汇编指令，将当前<code>Store Buffer</code>中的所有数据（不仅仅是<code>volatile</code>修饰的变量）都通过<code>MESI</code>写入</li>
</ul>
</li>
<li>其他架构，采用其他方式来保证线程可见性这一承诺</li>
</ul>
<p><strong>参考：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://isocpp.org/blog/2018/06/is-volatile-useful-with-threads-isvolatileusefulwiththreads.com">Is volatile useful with threads?</a>
<ul>
<li><a target="_blank" rel="noopener" href="http://isvolatileusefulwiththreads.com/">isvolatileusefulwiththreads</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18695120/volatile-and-cache-behaviour">Volatile and cache behaviour</a></li>
<li><a target="_blank" rel="noopener" href="https://www.hitzhangjie.pro/blog/2019-01-07-%E4%BD%A0%E4%B8%8D%E8%AE%A4%E8%AF%86%E7%9A%84cc++-volatile/">你不认识的cc++ volatile</a></li>
</ul>
<p><strong>示例如下：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; volatile.cpp &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#include &lt;atomic&gt;</span></span><br><span class="line"></span><br><span class="line">void read_from_normal(int32_t&amp; src, int32_t&amp; target) &#123;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void read_from_volatile(volatile int32_t&amp; src, int32_t&amp; target) &#123;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void read_from_atomic(std::atomic&lt;int32_t&gt;&amp; src, int32_t&amp; target) &#123;</span><br><span class="line">    target = src.load(std::memory_order_seq_cst);</span><br><span class="line">    target = src.load(std::memory_order_relaxed);</span><br><span class="line">    target = src.load(std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write_to_normal(int32_t&amp; src, int32_t&amp; target) &#123;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write_to_volatile(int32_t&amp; src, volatile int32_t&amp; target) &#123;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">    target = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void write_to_atomic(int32_t&amp; src, std::atomic&lt;int32_t&gt;&amp; target) &#123;</span><br><span class="line">    target.store(src, std::memory_order_seq_cst);</span><br><span class="line">    target.store(src, std::memory_order_relaxed);</span><br><span class="line">    target.store(src, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">gcc -o volatile.o -c volatile.cpp -O3 -lstdc++ -std=gnu++17</span><br><span class="line">objdump -drwCS volatile.o</span><br></pre></td></tr></table></figure>
<p><strong>输出如下：</strong></p>
<ul>
<li><code>read_from_normal</code>的三次操作被优化成了一次</li>
<li><code>write_to_normal</code>的三次操作被优化成了一次</li>
<li><code>write_to_atomic</code>中，<code>std::memory_order_seq_cst</code>使用的是<a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/xchg"><code>xchg</code>指令</a>，当有一个操作数是内存地址时，会自动启用<code>locking protocol</code>，确保写操作的串行化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">volatile.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;read_from_normal(int&amp;, int&amp;)&gt;:</span><br><span class="line">   0:	f3 0f 1e fa          	endbr64</span><br><span class="line">   4:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">   6:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">   8:	c3                   	ret</span><br><span class="line">   9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000000010 &lt;read_from_volatile(int volatile&amp;, int&amp;)&gt;:</span><br><span class="line">  10:	f3 0f 1e fa          	endbr64</span><br><span class="line">  14:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  16:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  18:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  1a:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  1c:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  1e:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  20:	c3                   	ret</span><br><span class="line">  21:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 cs nopw 0x0(%rax,%rax,1)</span><br><span class="line">  2c:	0f 1f 40 00          	nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000000030 &lt;read_from_atomic(std::atomic&lt;int&gt;&amp;, int&amp;)&gt;:</span><br><span class="line">  30:	f3 0f 1e fa          	endbr64</span><br><span class="line">  34:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  36:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  38:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  3a:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  3c:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  3e:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  40:	c3                   	ret</span><br><span class="line">  41:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 cs nopw 0x0(%rax,%rax,1)</span><br><span class="line">  4c:	0f 1f 40 00          	nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000000050 &lt;write_to_normal(int&amp;, int&amp;)&gt;:</span><br><span class="line">  50:	f3 0f 1e fa          	endbr64</span><br><span class="line">  54:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  56:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  58:	c3                   	ret</span><br><span class="line">  59:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000000060 &lt;write_to_volatile(int&amp;, int volatile&amp;)&gt;:</span><br><span class="line">  60:	f3 0f 1e fa          	endbr64</span><br><span class="line">  64:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  66:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  68:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  6a:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  6c:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  6e:	c3                   	ret</span><br><span class="line">  6f:	90                   	nop</span><br><span class="line"></span><br><span class="line">0000000000000070 &lt;write_to_atomic(int&amp;, std::atomic&lt;int&gt;&amp;)&gt;:</span><br><span class="line">  70:	f3 0f 1e fa          	endbr64</span><br><span class="line">  74:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  76:	87 06                	xchg   %eax,(%rsi)</span><br><span class="line">  78:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  7a:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  7c:	8b 07                	mov    (%rdi),%eax</span><br><span class="line">  7e:	89 06                	mov    %eax,(%rsi)</span><br><span class="line">  80:	c3                   	ret</span><br></pre></td></tr></table></figure>
<h4 id="3121-visibility-verification"><a class="markdownIt-Anchor" href="#3121-visibility-verification"></a> 3.1.2.1 Visibility Verification</h4>
<p>首先明确一下<code>visibility</code>的概念，这里我对它的定义是：当<code>A</code>和<code>B</code>两个线程，<code>A</code>对变量<code>x</code>进行写操作，<code>B</code>对变量<code>x</code>进行读操作，若时间上写操作先发生于读操作时，读操作能够读取到写操作写入的值</p>
<p>这个问题比较难直接验证，我们打算用一种间接的方式来验证：</p>
<ul>
<li>假设读操作和写操作的性能开销之比为<code>α</code></li>
<li>开两个线程，分别循环执行读操作和写操作，读执行<code>n</code>次（期间持续进行写操作）。统计读线程，相邻两次读操作，读取数值不同的次数为<code>m</code>，<code>β=m/n</code>。
<ul>
<li>若<code>α &gt; 1</code>，即读比写更高效。如果满足可见性，那么<code>β</code>应该大致接近<code>1/α</code></li>
<li>若<code>α &lt;= 1</code>，即读比写更低效。如果满足可见性，那么<code>β</code>应该接近1（写的值大概率被看见）</li>
</ul>
</li>
</ul>
<p>首先，测试<code>atomic</code>与<code>volatile</code>的读写性能</p>
<ul>
<li>测试时，会有一个额外的线程对<code>atomic</code>或<code>volatile</code>变量进行持续的读写操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;benchmark/benchmark.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">uint64_t</span>&gt; atomic_value&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">uint64_t</span> <span class="keyword">volatile</span> volatile_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> RAND_ROUND_SIZE = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">volatile_random_write</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint64_t</span>&amp; value, std::atomic&lt;<span class="type">bool</span>&gt;&amp; stop)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stop.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; RAND_ROUND_SIZE; i++) &#123;</span><br><span class="line">            value = tmp;</span><br><span class="line">            tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">volatile_random_read</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint64_t</span>&amp; value, std::atomic&lt;<span class="type">bool</span>&gt;&amp; stop)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (!stop.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; RAND_ROUND_SIZE; i++) &#123;</span><br><span class="line">            tmp = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    benchmark::<span class="built_in">DoNotOptimize</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order order&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">atomic_random_write</span><span class="params">(std::atomic&lt;<span class="type">uint64_t</span>&gt;&amp; value, std::atomic&lt;<span class="type">bool</span>&gt;&amp; stop)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stop.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; RAND_ROUND_SIZE; i++) &#123;</span><br><span class="line">            value.<span class="built_in">store</span>(tmp, order);</span><br><span class="line">            tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order order&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">atomic_random_read</span><span class="params">(std::atomic&lt;<span class="type">uint64_t</span>&gt;&amp; value, std::atomic&lt;<span class="type">bool</span>&gt;&amp; stop)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (!stop.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; RAND_ROUND_SIZE; i++) &#123;</span><br><span class="line">            tmp = value.<span class="built_in">load</span>(order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    benchmark::<span class="built_in">DoNotOptimize</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order order&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">atomic_read</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> tmp = <span class="number">0</span>;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;]() &#123; atomic_random_write&lt;order&gt;(atomic_value, stop); &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        tmp = atomic_value.<span class="built_in">load</span>(order);</span><br><span class="line">    &#125;</span><br><span class="line">    benchmark::<span class="built_in">DoNotOptimize</span>(tmp);</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order order&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">atomic_write</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> tmp = <span class="number">0</span>;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;]() &#123; atomic_random_read&lt;order&gt;(atomic_value, stop); &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        atomic_value.<span class="built_in">store</span>(tmp, order);</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">volatile_read</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> tmp = <span class="number">0</span>;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;]() &#123; volatile_random_write(volatile_value, stop); &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        tmp = volatile_value;</span><br><span class="line">    &#125;</span><br><span class="line">    benchmark::<span class="built_in">DoNotOptimize</span>(tmp);</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">volatile_write</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> tmp = <span class="number">0</span>;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;]() &#123; volatile_random_read(volatile_value, stop); &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">        volatile_value = tmp;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BENCHMARK</span>(atomic_read&lt;std::memory_order_seq_cst&gt;);</span><br><span class="line"><span class="built_in">BENCHMARK</span>(atomic_write&lt;std::memory_order_seq_cst&gt;);</span><br><span class="line"><span class="built_in">BENCHMARK</span>(atomic_read&lt;std::memory_order_relaxed&gt;);</span><br><span class="line"><span class="built_in">BENCHMARK</span>(atomic_write&lt;std::memory_order_relaxed&gt;);</span><br><span class="line"><span class="built_in">BENCHMARK</span>(volatile_read);</span><br><span class="line"><span class="built_in">BENCHMARK</span>(volatile_write);</span><br><span class="line"></span><br><span class="line"><span class="built_in">BENCHMARK_MAIN</span>();</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<ul>
<li>对于<code>atomic&lt;uint64_t&gt;, std::memory_order_seq_cst</code>
<ul>
<li><code>α = 28.9/1.24 = 23.30 &gt; 1</code></li>
<li><code>β</code>的预期值为<code>1/α = 0.043</code></li>
</ul>
</li>
<li>对于<code>atomic&lt;uint64_t&gt;, std::memory_order_relaxed</code>
<ul>
<li><code>α = 0.391/1.38 = 0.28 &lt; 1</code></li>
<li><code>β</code>的预期值为<code>1</code></li>
</ul>
</li>
<li>对于<code>volatile</code>
<ul>
<li><code>α = 0.331/1.33 = 0.25 &lt; 1</code></li>
<li><code>β</code>的预期值为<code>1</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">Benchmark                                        Time             CPU   Iterations</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">atomic_read&lt;std::memory_order_seq_cst&gt;        1.24 ns         1.24 ns    577159059</span><br><span class="line">atomic_write&lt;std::memory_order_seq_cst&gt;       28.9 ns         28.9 ns     23973114</span><br><span class="line">atomic_read&lt;std::memory_order_relaxed&gt;        1.38 ns         1.38 ns    595494132</span><br><span class="line">atomic_write&lt;std::memory_order_relaxed&gt;      0.391 ns        0.391 ns   1000000000</span><br><span class="line">volatile_read                                 1.33 ns         1.33 ns    551154517</span><br><span class="line">volatile_write                               0.331 ns        0.331 ns   1000000000</span><br></pre></td></tr></table></figure>
<p>同一个环境，测试程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint64_t</span> SIZE = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_volatile</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint64_t</span>&amp; value, <span class="type">const</span> std::string&amp; description)</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">write_thread</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!stop.load(std::memory_order_relaxed)) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                value = i;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">read_thread</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> prev_value = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> non_diff_cnt = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> diff_cnt = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> cur_value;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            cur_value = value;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// These two statements have little overhead which can be ignored if enable -03</span></span></span></span><br><span class="line"><span class="params"><span class="function">            cur_value == prev_value ? non_diff_cnt++ : diff_cnt++;</span></span></span><br><span class="line"><span class="params"><span class="function">            prev_value = cur_value;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; description &lt;&lt; <span class="string">&quot;, β=&quot;</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="type">double</span>&gt;(diff_cnt) / SIZE &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    read_thread.<span class="built_in">join</span>();</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    write_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order order&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_atomic</span><span class="params">(std::atomic&lt;<span class="type">uint64_t</span>&gt;&amp; value, <span class="type">const</span> std::string&amp; description)</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">write_thread</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!stop.load(std::memory_order_relaxed)) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                value.store(i, order);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">read_thread</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> prev_value = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> non_diff_cnt = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> diff_cnt = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> cur_value;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">uint64_t</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            cur_value = value.load(order);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// These two statements have little overhead which can be ignored if enable -03</span></span></span></span><br><span class="line"><span class="params"><span class="function">            cur_value == prev_value ? non_diff_cnt++ : diff_cnt++;</span></span></span><br><span class="line"><span class="params"><span class="function">            prev_value = cur_value;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; description &lt;&lt; <span class="string">&quot;, β=&quot;</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="type">double</span>&gt;(diff_cnt) / SIZE &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    read_thread.<span class="built_in">join</span>();</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    write_thread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::atomic&lt;<span class="type">uint64_t</span>&gt; value = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">test_atomic</span>&lt;std::memory_order_seq_cst&gt;(value, <span class="string">&quot;atomic&lt;uint64_t&gt;, std::memory_order_seq_cst&quot;</span>);</span><br><span class="line">        <span class="built_in">test_atomic</span>&lt;std::memory_order_relaxed&gt;(value, <span class="string">&quot;atomic&lt;uint64_t&gt;, std::memory_order_relaxed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint64_t</span> <span class="keyword">volatile</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">test_volatile</span>(value, <span class="string">&quot;volatile&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下（<code>volatile</code>以及<code>std::memory_order_relaxed</code>的行为是平台相关的，测试环境是x86，实验结果不具备平台扩展性）：</p>
<ul>
<li><code>std::memory_order_seq_cst</code>符合预期</li>
<li><code>std::memory_order_relaxed</code>、<code>volatile</code>都不符合预期。这两者都不具备<code>visibility</code></li>
<li>导致这一现象的原因，我的猜想如下：
<ul>
<li>x86会用到一种硬件优化，<code>Store Buffer</code>用于加速写操作</li>
<li><code>std::memory_order_seq_cst</code>的写操作，会立即将<code>Store Buffer</code>刷入内存</li>
<li><code>std::memory_order_relaxed</code>、<code>volatile</code>的写操作，会写入<code>Store Buffer</code>，当容量满了之后，刷入内存</li>
<li>将<code>Store Buffer</code>填充满所需的时间很短。于是上述代码等价于<code>std::memory_order_seq_cst</code>每次写操作写一次内存，<code>std::memory_order_relaxed</code>、<code>volatile</code>的一批写操作写一次内存。写内存的频率接近。于是这三种情况下，<code>β</code>相近</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;uint64_t&gt;, std::memory_order_seq_cst, β=0.0283726</span><br><span class="line">atomic&lt;uint64_t&gt;, std::memory_order_relaxed, β=0.0276697</span><br><span class="line">volatile, β=0.0271394</span><br></pre></td></tr></table></figure>
<p><strong>如果用Java进行上述等价验证，会发现实际结果与预期吻合，这里不再赘述</strong></p>
<h4 id="3122-atomicity-verification"><a class="markdownIt-Anchor" href="#3122-atomicity-verification"></a> 3.1.2.2 Atomicity Verification</h4>
<p><code>std::atomic</code>可以为其他非原子变量提供<code>happens-before</code>关系</p>
<ul>
<li><code>normal-write happens-before atomic-write</code></li>
<li><code>atomic-write happens-before atomic-read</code></li>
<li><code>atomic-read happens-before normal-read</code></li>
<li>推导出<code>normal-write happens-before normal-read</code></li>
</ul>
<p>此外，由于测试机器是x86的，x86是<code>TSO</code>模型，<code>std::memory_order_relaxed</code>同样满足<code>atomic-write happens-before atomic-read</code>规则，只不过生成的指令更接近<code>volatile</code>，因此这里使用<code>std::memory_order_relaxed</code>，便于对比两者指令的差异</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> INVALID_VALUE = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> EXPECTED_VALUE = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> TIMES = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> data;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">atomic_data_ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="type">bool</span> <span class="title">volatile_data_ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!atomic_data_ready.<span class="built_in">load</span>(std::memory_order_relaxed))</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(data == EXPECTED_VALUE);</span><br><span class="line"></span><br><span class="line">        data = INVALID_VALUE;</span><br><span class="line">        atomic_data_ready.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (atomic_data_ready.<span class="built_in">load</span>(std::memory_order_relaxed))</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">        data = EXPECTED_VALUE;</span><br><span class="line"></span><br><span class="line">        atomic_data_ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_atomic_visibility</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data = INVALID_VALUE;</span><br><span class="line">    atomic_data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(atomic_reader)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(atomic_writer)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">volatile_reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!volatile_data_ready)</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(data == EXPECTED_VALUE);</span><br><span class="line"></span><br><span class="line">        data = INVALID_VALUE;</span><br><span class="line">        volatile_data_ready = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">volatile_writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (volatile_data_ready)</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">        data = EXPECTED_VALUE;</span><br><span class="line"></span><br><span class="line">        volatile_data_ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_volatile_visibility</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    data = INVALID_VALUE;</span><br><span class="line">    volatile_data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(volatile_reader)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(volatile_writer)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_atomic_visibility</span>();</span><br><span class="line">    <span class="built_in">test_volatile_visibility</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以<code>-O3</code>优化级别进行编译，查看其汇编指令，可以发现：</p>
<ul>
<li><code>volatile_writer</code>中，<code>data</code>的赋值被优化到了循环外，<code>volatile_data_ready</code>每次循环都会进行一次赋值（这种优化破坏了程序的本意）</li>
<li><code>atomic_writer</code>中，由于内存屏障的存在（<code>std::atomic</code>的写操作），<code>data</code>的赋值并未被优化到循环外。<code>data</code>和<code>atomic_data_ready</code>每次循环都会被赋值（符合程序本意）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">00000000000013c0 &lt;volatile_writer()&gt;:</span><br><span class="line">    13c0:	f3 0f 1e fa          	endbr64</span><br><span class="line">    13c4:	ba 40 42 0f 00       	mov    $0xf4240,%edx</span><br><span class="line">    13c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)</span><br><span class="line">    13d0:	0f b6 05 45 2c 00 00 	movzbl 0x2c45(%rip),%eax        # 401c &lt;volatile_data_ready&gt;</span><br><span class="line">    13d7:	84 c0                	test   %al,%al</span><br><span class="line">    13d9:	75 f5                	jne    13d0 &lt;volatile_writer()+0x10&gt;</span><br><span class="line">    13db:	c6 05 3a 2c 00 00 01 	movb   $0x1,0x2c3a(%rip)        # 401c &lt;volatile_data_ready&gt;</span><br><span class="line">    13e2:	83 ea 01             	sub    $0x1,%edx</span><br><span class="line">    13e5:	75 e9                	jne    13d0 &lt;volatile_writer()+0x10&gt;</span><br><span class="line">    13e7:	c7 05 2f 2c 00 00 63 00 00 00 	movl   $0x63,0x2c2f(%rip)        # 4020 &lt;data&gt;</span><br><span class="line">    13f1:	c6 05 24 2c 00 00 01 	movb   $0x1,0x2c24(%rip)        # 401c &lt;volatile_data_ready&gt;</span><br><span class="line">    13f8:	c3                   	ret</span><br><span class="line">    13f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000001400 &lt;atomic_writer()&gt;:</span><br><span class="line">    1400:	f3 0f 1e fa          	endbr64</span><br><span class="line">    1404:	ba 40 42 0f 00       	mov    $0xf4240,%edx</span><br><span class="line">    1409:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)</span><br><span class="line">    1410:	0f b6 05 06 2c 00 00 	movzbl 0x2c06(%rip),%eax        # 401d &lt;atomic_data_ready&gt;</span><br><span class="line">    1417:	84 c0                	test   %al,%al</span><br><span class="line">    1419:	75 f5                	jne    1410 &lt;atomic_writer()+0x10&gt;</span><br><span class="line">    141b:	c7 05 fb 2b 00 00 63 00 00 00 	movl   $0x63,0x2bfb(%rip)        # 4020 &lt;data&gt;</span><br><span class="line">    1425:	c6 05 f1 2b 00 00 01 	movb   $0x1,0x2bf1(%rip)        # 401d &lt;atomic_data_ready&gt;</span><br><span class="line">    142c:	83 ea 01             	sub    $0x1,%edx</span><br><span class="line">    142f:	75 df                	jne    1410 &lt;atomic_writer()+0x10&gt;</span><br><span class="line">    1431:	c3                   	ret</span><br><span class="line">    1432:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 cs nopw 0x0(%rax,%rax,1)</span><br><span class="line">    143d:	0f 1f 00             	nopl   (%rax)</span><br></pre></td></tr></table></figure>
<p>如果以<code>-O0</code>优化级别进行编译，则上述程序中的断言不会报错</p>
<h3 id="313-mutable"><a class="markdownIt-Anchor" href="#313-mutable"></a> 3.1.3 mutable</h3>
<p>容许常量类类型对象修改相应类成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int32_t</span> data)</span> <span class="type">const</span> </span>&#123; <span class="keyword">this</span>-&gt;data = data; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int32_t</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="32-other-specifiers"><a class="markdownIt-Anchor" href="#32-other-specifiers"></a> 3.2 Other Specifiers</h2>
<h3 id="321-inline"><a class="markdownIt-Anchor" href="#321-inline"></a> 3.2.1 inline</h3>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/keyword/inline">C++ 关键词：inline</a></p>
<ul>
<li>在用于函数的声明说明符序列时，将函数声明为一个内联函数
<ul>
<li>整个定义都在<code>class/struct/union</code>的定义内且被附着到全局模块（C++20 起）的函数是隐式的内联函数，无论它是成员函数还是非成员<code>friend</code>函数</li>
<li><code>inline</code>关键词的本意是作为给优化器的指示器，以指示优先采用函数的内联替换而非进行函数调用，即并不执行将控制转移到函数体内的函数调用CPU指令，而是代之以执行函数体的一份副本而无需生成调用。这会避免函数调用的开销（传递实参及返回结果），但它可能导致更大的可执行文件，因为函数体必须被复制多次</li>
<li>因为关键词<code>inline</code>的含义是非强制的，编译器拥有对任何未标记为<code>inline</code>的函数使用内联替换的自由，和对任何标记为<code>inline</code>的函数生成函数调用的自由。这些优化选择不改变上述关于多个定义和共享静态变量的规则</li>
<li>声明有<code>constexpr</code>的函数是隐式的内联函数</li>
</ul>
</li>
<li>在用于具有静态存储期的变量（静态类成员或命名空间作用域变量）的声明说明符序列时，将变量声明为内联变量
<ul>
<li>声明为<code>constexpr</code>的静态成员变量（但不是命名空间作用域变量）是隐式的内联变量</li>
</ul>
</li>
</ul>
<h2 id="33-type-length"><a class="markdownIt-Anchor" href="#33-type-length"></a> 3.3 Type Length</h2>
<h3 id="331-memory-alignment"><a class="markdownIt-Anchor" href="#331-memory-alignment"></a> 3.3.1 Memory Alignment</h3>
<p><strong>内存对齐最最底层的原因是内存的IO是以<code>8</code>个字节<code>64bit</code>为单位进行的</strong></p>
<p>假如你指定要获取的是<code>0x0001-0x0008</code>，也是8字节，但是不是0开头的，内存需要怎么工作呢？没有好办法，内存只好先工作一次把<code>0x0000-0x0007</code>取出来，然后再把<code>0x0008-0x0015</code>取出来，把两次的结果都返回给你。CPU和内存IO的硬件限制导致没办法一次跨在两个数据宽度中间进行IO。这样你的应用程序就会变慢，算是计算机因为你不懂内存对齐而给你的一点点惩罚</p>
<p><strong>内存对齐规则</strong></p>
<ol>
<li><strong>结构体第一个成员的偏移量<code>offset</code>为<code>0</code>，以后每个成员相对于结构体首地址的<code>offset</code>都是该成员大小与<code>有效对齐值</code>中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节</strong></li>
<li><strong>结构体的总大小为<code>有效对齐值</code>的整数倍，如有需要编译器会在最末一个成员之后加上填充字节</strong></li>
</ol>
<ul>
<li><strong>有效对齐值：是给定值<code>#pragma pack(n)</code>和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。gcc中默认<code>#pragma pack(4)</code>，可以通过预编译命令<code>#pragma pack(n)，n = 1,2,4,8,16</code>来改变这一系数</strong></li>
</ul>
<p><strong>下面以一个例子来说明</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Align1</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> f1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Align2</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> f1;</span><br><span class="line">    <span class="type">int16_t</span> f2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Align3</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> f1;</span><br><span class="line">    <span class="type">int16_t</span> f2;</span><br><span class="line">    <span class="type">int32_t</span> f3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Align4</span> &#123;</span><br><span class="line">    <span class="type">int8_t</span> f1;</span><br><span class="line">    <span class="type">int16_t</span> f2;</span><br><span class="line">    <span class="type">int32_t</span> f3;</span><br><span class="line">    <span class="type">int64_t</span> f4;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Align1&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf1&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align1, f1) &lt;&lt; <span class="string">&quot;, f1&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align1::f1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Align2&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf1&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align2, f1) &lt;&lt; <span class="string">&quot;, f1&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align2::f1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf2&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align2, f2) &lt;&lt; <span class="string">&quot;, f2&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align2::f2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Align3&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align3) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf1&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align3, f1) &lt;&lt; <span class="string">&quot;, f1&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align3::f1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf2&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align3, f2) &lt;&lt; <span class="string">&quot;, f2&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align3::f2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf3&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align3, f3) &lt;&lt; <span class="string">&quot;, f3&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align3::f3) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Align4&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align4) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf1&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align4, f1) &lt;&lt; <span class="string">&quot;, f1&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align4::f1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf2&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align4, f2) &lt;&lt; <span class="string">&quot;, f2&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align4::f2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf3&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align4, f3) &lt;&lt; <span class="string">&quot;, f3&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align4::f3) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\tf4&#x27;s offset = &quot;</span> &lt;&lt; <span class="built_in">offsetof</span>(Align4, f4) &lt;&lt; <span class="string">&quot;, f4&#x27;s size = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Align4::f4) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果如下</strong></p>
<ul>
<li>由于每个成员的offset必须是该成员与<code>有效对齐值</code>中较小的那个值的整数倍，下面称较小的这个值为<code>成员有效对齐值</code></li>
<li><code>Align1</code>：最长数据类型的长度是<code>1</code>，pack=<code>4</code>，因此，<code>有效对齐值</code>是<code>min(1, 4) = 1</code>
<ul>
<li>规则1：
<ul>
<li><code>f1</code>，第一个成员的<code>offset = 0</code></li>
</ul>
</li>
<li>规则2：
<ul>
<li>类型总长度为<code>1</code>，是<code>有效对齐值（1）</code>的整数倍</li>
</ul>
</li>
</ul>
</li>
<li><code>Align2</code>：最长数据类型的长度是<code>2</code>，pack=<code>4</code>，因此，<code>有效对齐值</code>是<code>min(2, 4) = 2</code>
<ul>
<li>规则1：
<ul>
<li><code>f1</code>，第一个成员的<code>offset = 0</code></li>
<li><code>f2</code>，类型长度为<code>2</code>，因此，<code>成员有效对齐值</code>是<code>min(2, 2) = 2</code>。<code>offset = 2</code>是<code>成员有效对齐值（2)</code>的整数倍</li>
</ul>
</li>
<li>规则2：
<ul>
<li>类型总长度为<code>4</code>，是<code>有效对齐值（2）</code>的整数倍</li>
</ul>
</li>
</ul>
</li>
<li><code>Align3</code>：最长数据类型的长度是<code>4</code>，pack=<code>4</code>，因此，<code>有效对齐值</code>是<code>min(4, 4) = 4</code>
<ul>
<li>规则1：
<ul>
<li><code>f1</code>，第一个成员的<code>offset = 0</code></li>
<li><code>f2</code>，类型长度为<code>2</code>，因此，<code>成员有效对齐值</code>是<code>min(2, 4) = 2</code>。<code>offset = 2</code>是<code>成员有效对齐值（2)</code>的整数倍</li>
<li><code>f3</code>，类型长度为<code>4</code>，因此，<code>成员有效对齐值</code>是<code>min(4, 4) = 4</code>。<code>offset = 4</code>是<code>成员有效对齐值（4)</code>的整数倍</li>
</ul>
</li>
<li>规则2：
<ul>
<li>类型总长度为<code>8</code>，是<code>有效对齐值（4）</code>的整数倍</li>
</ul>
</li>
</ul>
</li>
<li><code>Align4</code>：最长数据类型的长度是<code>8</code>，pack=<code>4</code>，因此，<code>有效对齐值</code>是<code>min(8, 4) = 4</code>
<ul>
<li>规则1：
<ul>
<li><code>f1</code>，第一个成员的<code>offset = 0</code></li>
<li><code>f2</code>，类型长度为<code>2</code>，因此，<code>成员有效对齐值</code>是<code>min(2, 4) = 2</code>。<code>offset = 2</code>是<code>成员有效对齐值（2)</code>的整数倍</li>
<li><code>f3</code>，类型长度为<code>4</code>，因此，<code>成员有效对齐值</code>是<code>min(4, 4) = 4</code>。<code>offset = 4</code>是<code>成员有效对齐值（4)</code>的整数倍</li>
<li><code>f4</code>，类型长度为<code>8</code>，因此，<code>成员有效对齐值</code>是<code>min(8, 4) = 4</code>。<code>offset = 8</code>是<code>成员有效对齐值（4)</code>的整数倍</li>
</ul>
</li>
<li>规则2：
<ul>
<li>类型总长度为<code>16</code>，是<code>有效对齐值（4）</code>的整数倍</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Align1&#x27;s size = 1</span><br><span class="line">    f1&#x27;s offset = 0, f1&#x27;s size = 1</span><br><span class="line"></span><br><span class="line">Align2&#x27;s size = 4</span><br><span class="line">    f1&#x27;s offset = 0, f1&#x27;s size = 1</span><br><span class="line">    f2&#x27;s offset = 2, f2&#x27;s size = 2</span><br><span class="line"></span><br><span class="line">Align3&#x27;s size = 8</span><br><span class="line">    f1&#x27;s offset = 0, f1&#x27;s size = 1</span><br><span class="line">    f2&#x27;s offset = 2, f2&#x27;s size = 2</span><br><span class="line">    f3&#x27;s offset = 4, f3&#x27;s size = 4</span><br><span class="line"></span><br><span class="line">Align4&#x27;s size = 16</span><br><span class="line">    f1&#x27;s offset = 0, f1&#x27;s size = 1</span><br><span class="line">    f2&#x27;s offset = 2, f2&#x27;s size = 2</span><br><span class="line">    f3&#x27;s offset = 4, f3&#x27;s size = 4</span><br><span class="line">    f4&#x27;s offset = 8, f4&#x27;s size = 8</span><br></pre></td></tr></table></figure>
<h3 id="332-sizeof"><a class="markdownIt-Anchor" href="#332-sizeof"></a> 3.3.2 sizeof</h3>
<p><strong><code>sizeof</code>用于获取对象的内存大小</strong></p>
<ul>
<li><code>sizeof(int32_t)</code>：4</li>
<li><code>sizeof(char[2][2][2])</code>：8</li>
</ul>
<h3 id="333-alignof"><a class="markdownIt-Anchor" href="#333-alignof"></a> 3.3.3 alignof</h3>
<p><strong><code>alignof</code>用于获取对象的有效对齐值。<code>alignas</code>用于设置有效对其值（不允许小于默认的有效对齐值）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo1</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int32_t</span> i32;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile error</span></span><br><span class="line"><span class="comment">// Requested alignment is less than minimum int alignment of 4 for type &#x27;Foo2&#x27;</span></span><br><span class="line"><span class="comment">// struct alignas(1) Foo2 &#123;</span></span><br><span class="line"><span class="comment">//     char c;</span></span><br><span class="line"><span class="comment">//     int32_t i32;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile error</span></span><br><span class="line"><span class="comment">// Requested alignment is less than minimum int alignment of 4 for type &#x27;Foo3&#x27;</span></span><br><span class="line"><span class="comment">// struct alignas(2) Foo3 &#123;</span></span><br><span class="line"><span class="comment">//     char c;</span></span><br><span class="line"><span class="comment">//     int32_t i32;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">4</span>) Foo4 &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int32_t</span> i32;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">8</span>) Foo5 &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int32_t</span> i32;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>) Foo6 &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int32_t</span> i32;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_SIZE(name)                                                                                      \</span></span><br><span class="line"><span class="meta">    std::cout &lt;&lt; <span class="string">&quot;sizeof(&quot;</span> &lt;&lt; #name &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; sizeof(name) &lt;&lt; <span class="string">&quot;, alignof(&quot;</span> &lt;&lt; #name &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; alignof(name) \</span></span><br><span class="line"><span class="meta">              &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">PRINT_SIZE</span>(Foo1);</span><br><span class="line">    <span class="built_in">PRINT_SIZE</span>(Foo4);</span><br><span class="line">    <span class="built_in">PRINT_SIZE</span>(Foo5);</span><br><span class="line">    <span class="built_in">PRINT_SIZE</span>(Foo6);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Foo1)=8, alignof(Foo1)=4</span><br><span class="line">sizeof(Foo4)=8, alignof(Foo4)=4</span><br><span class="line">sizeof(Foo5)=8, alignof(Foo5)=8</span><br><span class="line">sizeof(Foo6)=16, alignof(Foo6)=16</span><br></pre></td></tr></table></figure>
<h3 id="334-alignas"><a class="markdownIt-Anchor" href="#334-alignas"></a> 3.3.4 alignas</h3>
<p><code>alignas</code>类型说明符是一种可移植的<code>C++</code>标准方法，用于指定变量和自定义类型的对齐方式，可以在定义 <code>class</code>、<code>struct</code>、<code>union</code>或声明变量时使用。如果遇到多个<code>alignas</code>说明符，编译器会选择最严格的那个（最大对齐值）</p>
<p>内存对齐可以使处理器更好地利用<code>cache</code>，包括减少<code>cache line</code>访问，以及避免多核一致性问题引发的 <code>cache miss</code>。具体来说，在多线程程序中，一种常用的优化手段是将需要高频并发访问的数据按<code>cache line</code>大小（通常为<code>64</code>字节）对齐。一方面，对于小于<code>64</code>字节的数据可以做到只触及一个<code>cache line</code>，减少访存次数；另一方面，相当于独占了整个<code>cache line</code>，避免其他数据可能修改同一<code>cache line</code>导致其他核<code>cache miss</code>的开销</p>
<p><strong>数组：对数组使用<code>alignas</code>，对齐的是数组的首地址，而不是每个数组元素。也就是说，下面这个数组并不是每个<code>int</code>都占<code>64</code>字节。如果一定要让每个元素都对齐，可以定义一个<code>struct</code>，如<code>int_align_64</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> array1[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) int_align_64 &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">int_align_64 array2[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_SIZEOF(element) std::cout &lt;&lt; <span class="string">&quot;sizeof(&quot;</span> &lt;&lt; #element &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; sizeof(element) &lt;&lt; std::endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_ALIGNOF(element) std::cout &lt;&lt; <span class="string">&quot;alignof(&quot;</span> &lt;&lt; #element &lt;&lt; <span class="string">&quot;)=&quot;</span> &lt;&lt; alignof(element) &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF</span>(array1[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF</span>(array2[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PRINT_ALIGNOF</span>(<span class="keyword">decltype</span>(array1));</span><br><span class="line">    <span class="built_in">PRINT_ALIGNOF</span>(<span class="keyword">decltype</span>(array2));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PRINT_ALIGNOF</span>(<span class="keyword">decltype</span>(array1[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">PRINT_ALIGNOF</span>(<span class="keyword">decltype</span>(array2[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sizeof(array1[1])=4</span><br><span class="line">sizeof(array2[1])=64</span><br><span class="line">alignof(decltype(array1))=4</span><br><span class="line">alignof(decltype(array2))=64</span><br><span class="line">alignof(decltype(array1[1]))=4</span><br><span class="line">alignof(decltype(array2[1]))=64</span><br></pre></td></tr></table></figure>
<h2 id="34-type-inference"><a class="markdownIt-Anchor" href="#34-type-inference"></a> 3.4 Type Inference</h2>
<h3 id="341-auto"><a class="markdownIt-Anchor" href="#341-auto"></a> 3.4.1 auto</h3>
<p><strong><code>auto</code>会忽略顶层<code>const</code>，保留底层的<code>const</code>，但是当设置一个类型为<code>auto</code>的引用时，初始值中的顶层常量属性仍然保留</strong></p>
<h3 id="342-decltype"><a class="markdownIt-Anchor" href="#342-decltype"></a> 3.4.2 decltype</h3>
<ul>
<li><strong><code>decltype</code>会保留变量的所有类型信息（包括顶层<code>const</code>和引用在内）</strong></li>
<li>如果表达式的内容是解引用操作，得到的将是引用类型
<ul>
<li><code>int i = 42;</code></li>
<li><code>int *p = &amp;i;</code></li>
<li><code>decltype(*p)</code>得到的是<code>int&amp;</code></li>
</ul>
</li>
<li><strong><code>decltype((c))</code>会得到<code>c</code>的引用类型（无论<code>c</code>本身是不是引用）</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> print_type_info(exp)                                                                     \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                                         \</span></span><br><span class="line"><span class="meta">        std::cout &lt;&lt; #exp &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; std::endl;                                                  \</span></span><br><span class="line"><span class="meta">        std::cout <span class="string">&lt;&lt; &quot;\tis_reference_v=&quot; &lt;&lt; std::is_reference_v&lt;exp&gt;</span> &lt;&lt; std::endl;               \</span></span><br><span class="line"><span class="meta">        std::cout <span class="string">&lt;&lt; &quot;\tis_lvalue_reference_v=&quot; &lt;&lt; std::is_lvalue_reference_v&lt;exp&gt;</span> &lt;&lt; std::endl; \</span></span><br><span class="line"><span class="meta">        std::cout <span class="string">&lt;&lt; &quot;\tis_rvalue_reference_v=&quot; &lt;&lt; std::is_rvalue_reference_v&lt;exp&gt;</span> &lt;&lt; std::endl; \</span></span><br><span class="line"><span class="meta">        std::cout <span class="string">&lt;&lt; &quot;\tis_const_v=&quot; &lt;&lt; std::is_const_v&lt;exp&gt;</span> &lt;&lt; std::endl;                       \</span></span><br><span class="line"><span class="meta">        std::cout <span class="string">&lt;&lt; &quot;\tis_pointer_v=&quot; &lt;&lt; std::is_pointer_v&lt;exp&gt;</span> &lt;&lt; std::endl;                   \</span></span><br><span class="line"><span class="meta">        std::cout &lt;&lt; std::endl;                                                                  \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>&amp; num2 = num1;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; num3 = num1;</span><br><span class="line">    <span class="type">int</span>&amp;&amp; num4 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* ptr1 = &amp;num1;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> ptr2 = &amp;num1;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr3 = &amp;num1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>((<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(num1));</span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>((num1)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(num2));</span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(num3));</span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(num4));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(ptr1));</span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(*ptr1));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(ptr2));</span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(*ptr2));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(ptr3));</span><br><span class="line">    <span class="built_in">print_type_info</span>(<span class="keyword">decltype</span>(*ptr3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">decltype(0):</span><br><span class="line">    is_reference_v=0</span><br><span class="line">    is_lvalue_reference_v=0</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype((0)):</span><br><span class="line">    is_reference_v=0</span><br><span class="line">    is_lvalue_reference_v=0</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype(num1):</span><br><span class="line">    is_reference_v=0</span><br><span class="line">    is_lvalue_reference_v=0</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype((num1)):</span><br><span class="line">    is_reference_v=1</span><br><span class="line">    is_lvalue_reference_v=1</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype(num2):</span><br><span class="line">    is_reference_v=1</span><br><span class="line">    is_lvalue_reference_v=1</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype(num3):</span><br><span class="line">    is_reference_v=1</span><br><span class="line">    is_lvalue_reference_v=1</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype(num4):</span><br><span class="line">    is_reference_v=1</span><br><span class="line">    is_lvalue_reference_v=0</span><br><span class="line">    is_rvalue_reference_v=1</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype(ptr1):</span><br><span class="line">    is_reference_v=0</span><br><span class="line">    is_lvalue_reference_v=0</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=1</span><br><span class="line"></span><br><span class="line">decltype(*ptr1):</span><br><span class="line">    is_reference_v=1</span><br><span class="line">    is_lvalue_reference_v=1</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype(ptr2):</span><br><span class="line">    is_reference_v=0</span><br><span class="line">    is_lvalue_reference_v=0</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=1</span><br><span class="line">    is_pointer_v=1</span><br><span class="line"></span><br><span class="line">decltype(*ptr2):</span><br><span class="line">    is_reference_v=1</span><br><span class="line">    is_lvalue_reference_v=1</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br><span class="line"></span><br><span class="line">decltype(ptr3):</span><br><span class="line">    is_reference_v=0</span><br><span class="line">    is_lvalue_reference_v=0</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=1</span><br><span class="line"></span><br><span class="line">decltype(*ptr3):</span><br><span class="line">    is_reference_v=1</span><br><span class="line">    is_lvalue_reference_v=1</span><br><span class="line">    is_rvalue_reference_v=0</span><br><span class="line">    is_const_v=0</span><br><span class="line">    is_pointer_v=0</span><br></pre></td></tr></table></figure>
<p>此外，<code>decltype</code>发生在编译期，即它不会产生任何运行时的代码。示例如下，编译执行后，可以发现<code>say_hello</code>并未执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">say_hello</span>()) a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="343-typeof"><a class="markdownIt-Anchor" href="#343-typeof"></a> 3.4.3 typeof</h3>
<p><strong>非<code>C++</code>标准</strong></p>
<h3 id="344-typeid"><a class="markdownIt-Anchor" href="#344-typeid"></a> 3.4.4 typeid</h3>
<p><strong><code>typeid</code>运算符允许在运行时确定对象的类型。若要判断是父类还是子类的话，那么父类必须包含虚函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_TYPE(left, right)                                                            \</span></span><br><span class="line"><span class="meta">    std::cout &lt;&lt; <span class="string">&quot;typeid(&quot;</span> &lt;&lt; #left &lt;&lt; <span class="string">&quot;) == typeid(&quot;</span> &lt;&lt; #right &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; std::boolalpha \</span></span><br><span class="line"><span class="meta">              &lt;&lt; (typeid(left) == typeid(right)) &lt;&lt; std::noboolalpha &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseWithoutVirtualFunc</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeriveWithoutVirtualFunc</span> : <span class="keyword">public</span> BaseWithoutVirtualFunc &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseWithVirtualFunc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeriveWithVirtualFunc</span> : <span class="keyword">public</span> BaseWithVirtualFunc &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(str, std::string);</span><br><span class="line"></span><br><span class="line">    BaseWithoutVirtualFunc* ptr1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr1, BaseWithoutVirtualFunc);</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr1, DeriveWithoutVirtualFunc);</span><br><span class="line"></span><br><span class="line">    BaseWithoutVirtualFunc* ptr2 = <span class="keyword">new</span> <span class="built_in">BaseWithoutVirtualFunc</span>();</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr2, BaseWithoutVirtualFunc);</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr2, DeriveWithoutVirtualFunc);</span><br><span class="line"></span><br><span class="line">    BaseWithoutVirtualFunc* ptr3 = <span class="keyword">new</span> <span class="built_in">DeriveWithoutVirtualFunc</span>();</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr3, BaseWithoutVirtualFunc);</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr3, DeriveWithoutVirtualFunc);</span><br><span class="line"></span><br><span class="line">    BaseWithVirtualFunc* ptr4 = <span class="keyword">new</span> <span class="built_in">BaseWithVirtualFunc</span>();</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr4, BaseWithVirtualFunc);</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr4, DeriveWithVirtualFunc);</span><br><span class="line"></span><br><span class="line">    BaseWithVirtualFunc* ptr5 = <span class="keyword">new</span> <span class="built_in">DeriveWithVirtualFunc</span>();</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr5, BaseWithVirtualFunc);</span><br><span class="line">    <span class="built_in">CHECK_TYPE</span>(*ptr5, DeriveWithVirtualFunc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typeid(str) == typeid(std::string): true</span><br><span class="line">typeid(*ptr1) == typeid(BaseWithoutVirtualFunc): true</span><br><span class="line">typeid(*ptr1) == typeid(DeriveWithoutVirtualFunc): false</span><br><span class="line">typeid(*ptr2) == typeid(BaseWithoutVirtualFunc): true</span><br><span class="line">typeid(*ptr2) == typeid(DeriveWithoutVirtualFunc): false</span><br><span class="line">typeid(*ptr3) == typeid(BaseWithoutVirtualFunc): true</span><br><span class="line">typeid(*ptr3) == typeid(DeriveWithoutVirtualFunc): false</span><br><span class="line">typeid(*ptr4) == typeid(BaseWithVirtualFunc): true</span><br><span class="line">typeid(*ptr4) == typeid(DeriveWithVirtualFunc): false</span><br><span class="line">typeid(*ptr5) == typeid(BaseWithVirtualFunc): false</span><br><span class="line">typeid(*ptr5) == typeid(DeriveWithVirtualFunc): true</span><br></pre></td></tr></table></figure>
<p><strong>此外，还可以使用<code>dynamic_cast</code>来判断指针指向子类还是父类</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_TYPE(left, right)                                                                   \</span></span><br><span class="line"><span class="meta">    std::cout <span class="string">&lt;&lt; &quot;dynamic_cast&lt;&quot; &lt;&lt; #right &lt;&lt; &quot;&gt;</span>(<span class="string">&quot; &lt;&lt; #left &lt;&lt; &quot;</span>) != nullptr: <span class="string">&quot; &lt;&lt; std::boolalpha \</span></span></span><br><span class="line"><span class="string"><span class="meta">              &lt;&lt; (dynamic_cast&lt;right&gt;(left) != nullptr) &lt;&lt; std::noboolalpha &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">class Base &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">public:</span></span></span><br><span class="line"><span class="string"><span class="meta">    virtual ~Base() &#123;&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">class Derive : public Base &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    virtual ~Derive() &#123;&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">int main() &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    Base* ptr1 = nullptr;</span></span></span><br><span class="line"><span class="string"><span class="meta">    CHECK_TYPE(ptr1, Base*);</span></span></span><br><span class="line"><span class="string"><span class="meta">    CHECK_TYPE(ptr1, Derive*);</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    Base* ptr2 = new Base();</span></span></span><br><span class="line"><span class="string"><span class="meta">    CHECK_TYPE(ptr2, Base*);</span></span></span><br><span class="line"><span class="string"><span class="meta">    CHECK_TYPE(ptr2, Derive*);</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    Base* ptr3 = new Derive();</span></span></span><br><span class="line"><span class="string"><span class="meta">    CHECK_TYPE(ptr3, Base*);</span></span></span><br><span class="line"><span class="string"><span class="meta">    CHECK_TYPE(ptr3, Derive*);</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dynamic_cast&lt;Base*&gt;(ptr1) != nullptr: false</span><br><span class="line">dynamic_cast&lt;Derive*&gt;(ptr1) != nullptr: false</span><br><span class="line">dynamic_cast&lt;Base*&gt;(ptr2) != nullptr: true</span><br><span class="line">dynamic_cast&lt;Derive*&gt;(ptr2) != nullptr: false</span><br><span class="line">dynamic_cast&lt;Base*&gt;(ptr3) != nullptr: true</span><br><span class="line">dynamic_cast&lt;Derive*&gt;(ptr3) != nullptr: true</span><br></pre></td></tr></table></figure>
<h2 id="35-type-conversion"><a class="markdownIt-Anchor" href="#35-type-conversion"></a> 3.5 Type Conversion</h2>
<h3 id="351-static_cast"><a class="markdownIt-Anchor" href="#351-static_cast"></a> 3.5.1 static_cast</h3>
<p><strong>用法：<code>static_cast&lt;type&gt; (expr)</code></strong></p>
<p><code>static_cast</code>运算符执行非动态转换，没有运行时类检查来保证转换的安全性。例如，它可以用来把一个基类指针转换为派生类指针。任何具有明确意义的类型转换，只要不包含底层<code>const</code>，都可以使用<code>static_cast</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *cc = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> s = <span class="built_in">static_cast</span>&lt;std::string&gt;(cc);</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compile error</span></span><br><span class="line">    <span class="comment">// auto i = static_cast&lt;int&gt;(cc);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，若待转换类型既不是引用类型，也不是指针类型时，会调用该类型的拷贝构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Foo&#x27;s default ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp; foo) &#123; std::cout &lt;&lt; <span class="string">&quot;Foo&#x27;s copy ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">something</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo* f = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Foo&gt;(*f).<span class="built_in">something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="352-dynamic_cast"><a class="markdownIt-Anchor" href="#352-dynamic_cast"></a> 3.5.2 dynamic_cast</h3>
<p><strong>用法：<code>dynamic_cast&lt;type&gt; (expr)</code></strong></p>
<p><code>dynamic_cast</code>通常用于在继承结构之间进行转换，在运行时执行转换，验证转换的有效性。<code>type</code>必须是类的指针、类的引用或者<code>void*</code>。若指针转换失败，则得到的是<code>nullptr</code>；若引用转换失败，那么会抛出<code>std::bad_cast</code>类型的异常</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base&#x27;s func&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive&#x27;s func&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> Base &amp;b = Derive&#123;&#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;d = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derive &amp;&gt;(b);</span><br><span class="line">        d.<span class="built_in">func</span>();</span><br><span class="line">        <span class="keyword">auto</span> &amp;s = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> std::string &amp;&gt;(b); <span class="comment">// error case</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::bad_cast &amp;err) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;err=&quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> Base *pb = &amp;b;</span><br><span class="line">    <span class="keyword">auto</span> *pd = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derive *&gt;(pb);</span><br><span class="line">    pd-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">auto</span> *ps = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> std::string *&gt;(pb); <span class="comment">// error case</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ps=&quot;</span> &lt;&lt; ps &lt;&lt; std::endl; <span class="comment">// print nullptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="353-const_cast"><a class="markdownIt-Anchor" href="#353-const_cast"></a> 3.5.3 const_cast</h3>
<p><strong>用法：<code>const_cast&lt;type&gt; (expr)</code></strong></p>
<p>这种类型的转换主要是用来操作所传对象的<code>const</code>属性，可以加上<code>const</code>属性，也可以去掉<code>const</code>属性（顶层底层均可）。其中，<code>type</code>只能是如下几类（必须是引用或者指针类型）</p>
<ul>
<li><code>T &amp;</code></li>
<li><code>const T &amp;</code></li>
<li><code>T &amp;&amp;</code></li>
<li><code>T *</code></li>
<li><code>const T *</code></li>
<li><code>T *const</code></li>
<li><code>const T *const</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;const T &amp; -&gt; T &amp;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;v1 = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v1&#x27;s address=&quot;</span> &lt;&lt; &amp;v1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> &amp;v2 = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> &amp;&gt;(v1);</span><br><span class="line">    v2 = <span class="number">200</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v2&#x27;s address=&quot;</span> &lt;&lt; &amp;v2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nT &amp; -&gt; T &amp;&amp;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> &amp;&amp;v3 = <span class="built_in">const_cast</span>&lt; <span class="type">int</span> &amp;&amp;&gt;(v2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v3&#x27;s address=&quot;</span> &lt;&lt; &amp;v3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nT * -&gt; const T *const&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> *p1 = &amp;v2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1=&quot;</span> &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p2 = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> &gt;(p1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2=&quot;</span> &lt;&lt; p2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="354-reinterpret_cast"><a class="markdownIt-Anchor" href="#354-reinterpret_cast"></a> 3.5.4 reinterpret_cast</h3>
<p><strong>用法：<code>reinterpret_cast&lt;type&gt; (expr)</code></strong></p>
<p><code>reinterpret_cast</code>是最危险的类型转换，它能够直接将一种类型的指针转换为另一种类型的指针，应该非常谨慎地使用。在很大程度上，使用<code>reinterpret_cast</code>获得的唯一保证是，通常如果你将结果转换回原始类型，您将获得完全相同的值（但如果中间类型小于原始类型，则不会）。也有许多<code>reinterpret_cast</code>不能做的转换。它主要用于特别奇怪的转换和位操作，例如将原始数据流转换为实际数据，或将数据存储在指向对齐数据的指针的低位中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> i = <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">    <span class="type">int32_t</span> *pi = &amp;i;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> *pl = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int64_t</span> *&gt; (pi);</span><br><span class="line">        std::cout &lt;&lt; *pl &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">auto</span> *rebuild_pi = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int32_t</span> *&gt; (pl);</span><br><span class="line">        std::cout &lt;&lt; *rebuild_pi &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="36-storage-class-specifiers"><a class="markdownIt-Anchor" href="#36-storage-class-specifiers"></a> 3.6 Storage Class Specifiers</h2>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/storage_duration">Storage class specifiers</a></p>
<p>In C++, storage classes determine the scope, visibility, and lifetime of variables. There are four storage classes in C++:</p>
<ol>
<li><strong>Automatic Storage Class (default)</strong>: Variables declared within a block or function without specifying a storage class are considered to have automatic storage class. These variables are created when the block or function is entered and destroyed when the block or function is exited. The keyword “auto” can also be used explicitly, although it is optional.</li>
<li><strong>Static Storage Class</strong>: Variables with static storage class are created and initialized only once, and their values persist across function calls. They are initialized to zero by default. Static variables can be declared within a block or function, but their scope is limited to that block or function. The keyword “static” is used to specify static storage class.</li>
<li><strong>Register Storage Class (deprecated)</strong>: The register storage class is used to suggest that a variable be stored in a register instead of memory. The keyword “register” is used to specify register storage class. However, the compiler is free to ignore this suggestion.</li>
<li><strong>Extern Storage Class</strong>: The extern storage class is used to declare a variable that is defined in another translation unit (source file). It is often used to provide a global variable declaration that can be accessed from multiple files. When using extern, the variable is not allocated any storage, as it is assumed to be defined elsewhere. The keyword “extern” is used to specify extern storage class.</li>
</ol>
<p>Here’s an example illustrating the usage of different storage classes:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVariable; <span class="comment">// extern storage class by default</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVariable; <span class="comment">// static storage class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> autoVariable;              <span class="comment">// automatic storage class</span></span><br><span class="line">        <span class="keyword">register</span> <span class="type">int</span> registerVariable; <span class="comment">// register storage class</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Auto: &quot;</span> &lt;&lt; autoVariable &lt;&lt; <span class="string">&quot;, Static: &quot;</span> &lt;&lt; staticVariable &lt;&lt; <span class="string">&quot;, Register: &quot;</span> &lt;&lt; registerVariable</span><br><span class="line">                  &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        ++autoVariable;</span><br><span class="line">        ++staticVariable;</span><br><span class="line">        ++registerVariable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    globalVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="361-static"><a class="markdownIt-Anchor" href="#361-static"></a> 3.6.1 static</h3>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/keyword/static">C++ 关键词：static</a></p>
<ol>
<li>声明具有静态存储期和内部链接的命名空间成员（全局静态变量/函数，其他编译单元不可见）
<ul>
<li>表示该编译单元不导出这个函数/变量的符号，因此无法再别的编译单元里使用</li>
</ul>
</li>
<li>定义具有静态存储期且仅初始化一次的块作用域变量（函数的静态变量）
<ul>
<li>变量的存储方式和全局变量一样，但仍然不导出符号</li>
</ul>
</li>
<li>声明不绑定到特定实例的类成员（类的静态成员）</li>
</ol>
<h3 id="362-extern"><a class="markdownIt-Anchor" href="#362-extern"></a> 3.6.2 extern</h3>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/keyword/extern">C++ 关键词：extern</a></p>
<ul>
<li>Static storage duration specifier with external linkage
<ul>
<li>This symbol is defined in another compilation unit, which means it needs to be placed in the unresolved symbol table (external linkage)</li>
</ul>
</li>
<li>Language linkage specification, to avoid name mangling
<ul>
<li><code>extern &quot;C&quot; &#123;&#125;</code></li>
</ul>
</li>
<li>Explicit template instantiation declaration
<ul>
<li>For class templates</li>
<li>For function templates</li>
</ul>
</li>
</ul>
<h4 id="3621-shared-global-variable"><a class="markdownIt-Anchor" href="#3621-shared-global-variable"></a> 3.6.2.1 Shared Global Variable</h4>
<p><strong>每个源文件中都得有该变量的声明，但是只有一个源文件中可以包含该变量的定义，通常可以采用如下做法</strong></p>
<ul>
<li>定义一个头文件<code>xxx.h</code>，声明该变量（需要用extern关键字）</li>
<li>所有源文件包含该头文件<code>xxx.h</code></li>
<li>在某个源文件中定义该变量</li>
</ul>
<p><strong>示例如下：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建头文件</span></span><br><span class="line"><span class="built_in">cat</span> &gt; extern.h &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#pragma once</span></span><br><span class="line"></span><br><span class="line">extern int extern_value;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建源文件</span></span><br><span class="line"><span class="built_in">cat</span> &gt; extern.cpp &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#include &quot;extern.h&quot;</span></span><br><span class="line"></span><br><span class="line">int extern_value = 5;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建源文件</span></span><br><span class="line"><span class="built_in">cat</span> &gt; main.cpp &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &quot;extern.h&quot;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">extern_value &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 编译</span></span><br><span class="line"><span class="string">gcc -o main main.cpp extern.cpp -lstdc++ -Wall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 执行</span></span><br><span class="line"><span class="string">./main</span></span><br></pre></td></tr></table></figure>
<h3 id="363-thread_local"><a class="markdownIt-Anchor" href="#363-thread_local"></a> 3.6.3 thread_local</h3>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/keyword/thread_local">C++ 关键词：thread_local (C++11 起)</a></p>
<ul>
<li>线程局域存储期指定符</li>
</ul>
<p>实现原理（猜测）：在每个线程的栈空间起始位置（高位，栈是从上往下分配内存的）存储由<code>thread_local</code>修饰的变量。下面由一个程序来验证一下这个猜想：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int32_t</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_address</span><span class="params">(<span class="type">const</span> std::string name, <span class="type">int32_t</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::mutex m;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; &amp;value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> addr_t1;</span><br><span class="line">    <span class="type">uint64_t</span> addr_t2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_address</span>(<span class="string">&quot;main_thread_local&quot;</span>, value);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">print_address</span>(<span class="string">&quot;main_local&quot;</span>, i);</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;addr_t1]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        addr_t1 = <span class="keyword">reinterpret_cast</span>&lt;<span class="type">uint64_t</span>&gt;(&amp;value);</span></span></span><br><span class="line"><span class="params"><span class="function">        print_address(<span class="string">&quot;t1_thread_local&quot;</span>, value);</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> i;</span></span></span><br><span class="line"><span class="params"><span class="function">        print_address(<span class="string">&quot;t1_local&quot;</span>, i);</span></span></span><br><span class="line"><span class="params"><span class="function">        assert(&amp;i &lt; &amp;value);</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;addr_t2]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        addr_t2 = <span class="keyword">reinterpret_cast</span>&lt;<span class="type">uint64_t</span>&gt;(&amp;value);</span></span></span><br><span class="line"><span class="params"><span class="function">        print_address(<span class="string">&quot;t2_thread_local&quot;</span>, value);</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> i;</span></span></span><br><span class="line"><span class="params"><span class="function">        print_address(<span class="string">&quot;t2_local&quot;</span>, i);</span></span></span><br><span class="line"><span class="params"><span class="function">        assert(&amp;i &lt; &amp;value);</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> distance = addr_t1 - addr_t2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;addr distance between t1 and t2 is: &quot;</span> &lt;&lt; distance &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我的环境中，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main_thread_local: 0x7f190e1a573c</span><br><span class="line">main_local: 0x7fff425e1dd4</span><br><span class="line">t1_thread_local: 0x7f190e1a463c</span><br><span class="line">t1_local: 0x7f190e1a3ddc</span><br><span class="line">t2_thread_local: 0x7f190d9a363c</span><br><span class="line">t2_local: 0x7f190d9a2ddc</span><br><span class="line">addr distance between t1 and t2 is: 8392704</span><br></pre></td></tr></table></figure>
<p>可以发现，在不同的线程中，<code>value</code>的内存地址是不同的，且处于高位。相邻两个线程，<code>value</code>地址的差值差不多就是栈空间的大小（<code>ulimit -s</code>）</p>
<h4 id="3631-initialization"><a class="markdownIt-Anchor" href="#3631-initialization"></a> 3.6.3.1 Initialization</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::mutex m;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="type">int</span> _[] = &#123;(std::cout &lt;&lt; args, <span class="number">0</span>)...&#125;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;default ctor&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp; foo) &#123; <span class="built_in">print</span>(<span class="string">&quot;copy ctor&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(Foo&amp;&amp; foo) &#123; <span class="built_in">print</span>(<span class="string">&quot;move ctor&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;dtor&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> Foo foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo.value = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main: foo&#x27;address=&quot;</span>, &amp;foo, <span class="string">&quot;, value=&quot;</span>, foo.value);</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;]() &#123; print(<span class="string">&quot;t1: foo&#x27;address=&quot;</span>, &amp;foo, <span class="string">&quot;, value=&quot;</span>, foo.value); &#125;)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<ul>
<li>构造方法调用了2次，因为这两个线程都经过了<code>foo</code>这个变量的声明，因此都会分配存储空间并进行初始化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default ctor</span><br><span class="line">main: foo&#x27;address=0x7f5fd6b0c77c, value=1</span><br><span class="line">default ctor</span><br><span class="line">t1: foo&#x27;address=0x7f5fd5a3c6fc, value=0</span><br><span class="line">dtor</span><br><span class="line">dtor</span><br></pre></td></tr></table></figure>
<p>修改一下，我们将<code>thread_local</code>移动到<code>main</code>函数内部</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::mutex m;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="type">int</span> _[] = &#123;(std::cout &lt;&lt; args, <span class="number">0</span>)...&#125;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;default ctor&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp; foo) &#123; <span class="built_in">print</span>(<span class="string">&quot;copy ctor&quot;</span>); &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(Foo&amp;&amp; foo) &#123; <span class="built_in">print</span>(<span class="string">&quot;move ctor&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; <span class="built_in">print</span>(<span class="string">&quot;dtor&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> Foo foo;</span><br><span class="line">    foo.value = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main: foo&#x27;address=&quot;</span>, &amp;foo, <span class="string">&quot;, value=&quot;</span>, foo.value);</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([&amp;]() &#123; print(<span class="string">&quot;t1: foo&#x27;address=&quot;</span>, &amp;foo, <span class="string">&quot;, value=&quot;</span>, foo.value); &#125;)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<ul>
<li>构造方法调用了1次，只有<code>main</code>线程经过了<code>foo</code>这个变量的声明，因此会分配存储空间并进行初始化。而<code>t1</code>线程并未经过<code>foo</code>这个变量的声明，因此只分配了存储空间，并未进行初始化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default ctor</span><br><span class="line">main: foo&#x27;address=0x7f2d690e6778, value=1</span><br><span class="line">t1: foo&#x27;address=0x7f2d680166f8, value=0</span><br><span class="line">dtor</span><br></pre></td></tr></table></figure>
<h2 id="37-inheritance-and-polymorphism"><a class="markdownIt-Anchor" href="#37-inheritance-and-polymorphism"></a> 3.7 Inheritance and Polymorphism</h2>
<h3 id="371-inheritance-modes"><a class="markdownIt-Anchor" href="#371-inheritance-modes"></a> 3.7.1 Inheritance Modes</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Inheritance mode\member permissions</th>
<th style="text-align:left">public</th>
<th style="text-align:left">protected</th>
<th style="text-align:left">private</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>public inherit</strong></td>
<td style="text-align:left">public</td>
<td style="text-align:left">protected</td>
<td style="text-align:left">invisible</td>
</tr>
<tr>
<td style="text-align:left"><strong>protected inherit</strong></td>
<td style="text-align:left">protected</td>
<td style="text-align:left">protected</td>
<td style="text-align:left">invisible</td>
</tr>
<tr>
<td style="text-align:left"><strong>private inherit</strong></td>
<td style="text-align:left">private</td>
<td style="text-align:left">private</td>
<td style="text-align:left">invisible</td>
</tr>
</tbody>
</table>
<p>Regardless of the inheritance method, you can access the <code>public</code> and <code>protected</code> members of the parent class, but their access rights will be modified according to the inheritance method, thus affecting the access rights of the derived class.</p>
<p><strong>Most importantly, only public inheritance can achieve polymorphism</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">public_op</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;public_op&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">protected_op</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;protected_op&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">private_op</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;private_op&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PublicDerive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">public_op</span>();</span><br><span class="line">        <span class="built_in">protected_op</span>();</span><br><span class="line">        <span class="comment">// private_op();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondaryPublicDerive</span> : <span class="keyword">public</span> PublicDerive &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">public_op</span>();</span><br><span class="line">        <span class="built_in">protected_op</span>();</span><br><span class="line">        <span class="comment">// private_op();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProtectedDerive</span> : <span class="keyword">protected</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">public_op</span>();</span><br><span class="line">        <span class="built_in">protected_op</span>();</span><br><span class="line">        <span class="comment">// private_op();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondaryProtectedDerive</span> : <span class="keyword">public</span> ProtectedDerive &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">public_op</span>();</span><br><span class="line">        <span class="built_in">protected_op</span>();</span><br><span class="line">        <span class="comment">// private_op();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrivateDerive</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">public_op</span>();</span><br><span class="line">        <span class="built_in">protected_op</span>();</span><br><span class="line">        <span class="comment">// private_op();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondaryPrivateDerive</span> : <span class="keyword">public</span> PrivateDerive &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// public_op();</span></span><br><span class="line">        <span class="comment">// protected_op();</span></span><br><span class="line">        <span class="comment">// private_op();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecondaryPublicDerive obj_public;</span><br><span class="line">    obj_public.<span class="built_in">public_op</span>();</span><br><span class="line"></span><br><span class="line">    SecondaryProtectedDerive obj_protected;</span><br><span class="line">    <span class="comment">// obj_protected.public_op();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="372-virtual"><a class="markdownIt-Anchor" href="#372-virtual"></a> 3.7.2 virtual</h3>
<p><code>virtual</code>关键词修饰的就是虚函数，虚函数的分派发生在运行时</p>
<ol>
<li>有虚函数的每个类，维护一个虚函数表</li>
<li>有虚函数的类的对象，会包含一个指向该类的虚函数表的指针</li>
</ol>
<p><img src="/images/Cpp-Language/virtual-method-table.jpeg" alt="virtual-method-table" /></p>
<ul>
<li>图片出处：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110144589">c++虚指针和虚函数表</a></li>
</ul>
<h4 id="3721-virtual-destructor"><a class="markdownIt-Anchor" href="#3721-virtual-destructor"></a> 3.7.2.1 virtual destructor</h4>
<p>通常，我们需要将有虚函数的类的析构函数定义为<code>virtual</code>，否则很容易造成内存泄露，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;~Base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derive</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;~Derive&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derive::func&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* ptr = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="373-final"><a class="markdownIt-Anchor" href="#373-final"></a> 3.7.3 final</h3>
<p><code>final</code>可以修饰类或者虚函数</p>
<ul>
<li><code>final</code>修饰的类不能有子类，该类的所有虚函数不能被覆盖</li>
<li><code>final</code>修饰的虚函数，不能被覆盖
<ul>
<li>只能在虚函数的声明处进行修饰</li>
</ul>
</li>
</ul>
<p>当用具体类型的指针或者引用调用<code>final</code>修饰的虚函数时，虚函数的调用可以被编译器直接优化掉</p>
<h3 id="374-override"><a class="markdownIt-Anchor" href="#374-override"></a> 3.7.4 override</h3>
<p><code>override</code>可以修饰虚函数，表示对虚函数进行覆盖</p>
<ul>
<li>只能在虚函数的声明处进行修饰</li>
<li>加不加<code>override</code>其实没有影响</li>
</ul>
<h2 id="38-constexpr"><a class="markdownIt-Anchor" href="#38-constexpr"></a> 3.8 constexpr</h2>
<h3 id="381-if-constexpr"><a class="markdownIt-Anchor" href="#381-if-constexpr"></a> 3.8.1 if constexpr</h3>
<p>编译期分支判断，一般用于泛型。如果在分支中使用的是不同类型的不同特性，那么普通的<code>if</code>是没法通过编译的，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Condition1</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> T <span class="title">append</span><span class="params">(T left, T right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (std::is_integral&lt;T&gt;::value) &#123;</span><br><span class="line">            <span class="keyword">return</span> left + right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::is_pointer&lt;T&gt;::value) &#123;</span><br><span class="line">            <span class="built_in">return</span> (*left) + (*right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Condition2</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> T <span class="title">append</span><span class="params">(T left, T right)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> left + right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_pointer&lt;T&gt;::value) &#123;</span><br><span class="line">            <span class="built_in">return</span> (*left) + (*right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Condition1&lt;int32_t&gt;::append(1, 2);</span></span><br><span class="line">    Condition2&lt;<span class="type">int32_t</span>&gt;::<span class="built_in">append</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="39-static_assert"><a class="markdownIt-Anchor" href="#39-static_assert"></a> 3.9 static_assert</h2>
<p>编译期断言</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span>, <span class="string">&quot;test1&quot;</span>);</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">long</span>) &gt; <span class="number">8</span>, <span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="310-noexcept"><a class="markdownIt-Anchor" href="#310-noexcept"></a> 3.10 noexcept</h2>
<p>Specifies whether a function could throw exceptions.</p>
<ul>
<li><code>noexcept(true)</code></li>
<li><code>noexcept(false)</code></li>
<li><code>noexcept</code> same as <code>noexcept(true)</code></li>
</ul>
<p><strong>Non-throwing functions are permitted to call potentially-throwing functions. Whenever an exception is thrown and the search for a handler encounters the outermost block of a non-throwing function, the function std::terminate is called:</strong></p>
<ul>
<li>An exception throw by a <code>noexcept</code> function cannot be normally catched.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;funcA&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;funA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;funcB&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;funcB&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">funcA</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;catch funcA&#x27;s exception&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">funcB</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;catch funcB&#x27;s exception&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3101-destructor"><a class="markdownIt-Anchor" href="#3101-destructor"></a> 3.10.1 destructor</h3>
<p>In practice, implicit destructors are <code>noexcept</code> unless the class is “poisoned” by a base or member whose destructor is <code>noexcept(false)</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Poison</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Poison</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Poison</span>() <span class="built_in">noexcept</span>(<span class="literal">false</span>)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoisionedFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PoisionedFoo</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">    Poison p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">Foo</span>()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">noexcept</span>(<span class="built_in">PoisionedFoo</span>()) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="311-throw-and-error"><a class="markdownIt-Anchor" href="#311-throw-and-error"></a> 3.11 throw and error</h2>
<p><code>throw</code>关键字可以抛出任何对象，例如可以抛出一个整数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">int</span> &amp;i) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 保护代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">// 能处理任何异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="312-placement-new"><a class="markdownIt-Anchor" href="#312-placement-new"></a> 3.12 placement new</h2>
<p><code>placement new</code>的功能就是在一个已经分配好的空间上，调用构造函数，创建一个对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *buf = <span class="comment">// 在这里为buf分配内存</span></span><br><span class="line">Class *pc = <span class="built_in">new</span> (buf) <span class="built_in">Class</span>();  </span><br></pre></td></tr></table></figure>
<h1 id="4-syntax"><a class="markdownIt-Anchor" href="#4-syntax"></a> 4 Syntax</h1>
<h2 id="41-initialization"><a class="markdownIt-Anchor" href="#41-initialization"></a> 4.1 Initialization</h2>
<h3 id="411-initialization-types"><a class="markdownIt-Anchor" href="#411-initialization-types"></a> 4.1.1 Initialization Types</h3>
<ol>
<li>Default initialization: <code>type variableName;</code></li>
<li>Direct initialization / Constructor initialization (with at least one argument): <code>type variableName(args);</code></li>
<li>List initialization: <code>type variableName&#123;args&#125;;</code>
<ul>
<li>Essentially, list initialization calls the corresponding constructor (matching the argument types and number) for initialization.</li>
<li>One of its advantages is that it can simplify the <code>return</code> statement, allowing <code>return &#123;args&#125;;</code> directly.</li>
</ul>
</li>
<li>Copy initialization:
<ul>
<li><code>type variableName = otherVariableName</code>, essentially calls the copy constructor.</li>
<li><code>type variableName = &lt;type (args)&gt;</code>, where <code>&lt;type (args)&gt;</code> refers to a function that returns a <code>type</code>. It seems like the copy constructor would be called, but the compiler optimizes this form of initialization, meaning only the constructor is called within the function (if applicable), and the <code>=</code> does not call any constructor.</li>
</ul>
</li>
<li>Value initialization: <code>type variableName()</code>
<ul>
<li>For built-in types, initialized to <code>0</code> or <code>nullptr</code>.</li>
<li>For class types, equivalent to default initialization. Testing shows that no constructor is actually called.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A&#x27;s default constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : _a(a), _b(<span class="number">0</span>) &#123; std::cout &lt;&lt; <span class="string">&quot;A&#x27;s (int) constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b) : _a(a), _b(b) &#123; std::cout &lt;&lt; <span class="string">&quot;A&#x27;s (int, int) constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a) : _a(a._a), _b(a._b) &#123; std::cout &lt;&lt; <span class="string">&quot;A&#x27;s copy constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a) : _a(a._a), _b(a._b) &#123; std::cout &lt;&lt; <span class="string">&quot;A&#x27;s move constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s copy assign operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = a._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(A&amp;&amp; a) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s move assign operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = a._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">createA</span><span class="params">(<span class="type">int</span> argNum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argNum == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argNum == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;============(a1)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(a2)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(a3)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">A <span class="title">a3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(a4)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a4 = &#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(a5)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a5 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(a6)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a6 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(a7)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a7 = a6;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(a8)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a8 = <span class="built_in">createA</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(a9)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a9 = <span class="built_in">createA</span>(<span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(a10)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    A a10 = <span class="built_in">createA</span>(<span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(a11)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">A <span class="title">a11</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">============(a1)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line"></span><br><span class="line">============(a2)============</span><br><span class="line">A&#x27;s (int) constructor</span><br><span class="line"></span><br><span class="line">============(a3)============</span><br><span class="line">A&#x27;s (int, int) constructor</span><br><span class="line"></span><br><span class="line">============(a4)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line"></span><br><span class="line">============(a5)============</span><br><span class="line">A&#x27;s (int) constructor</span><br><span class="line"></span><br><span class="line">============(a6)============</span><br><span class="line">A&#x27;s (int, int) constructor</span><br><span class="line"></span><br><span class="line">============(a7)============</span><br><span class="line">A&#x27;s copy constructor</span><br><span class="line"></span><br><span class="line">============(a8)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line"></span><br><span class="line">============(a9)============</span><br><span class="line">A&#x27;s (int) constructor</span><br><span class="line"></span><br><span class="line">============(a10)============</span><br><span class="line">A&#x27;s (int, int) constructor</span><br><span class="line"></span><br><span class="line">============(a11)============</span><br></pre></td></tr></table></figure>
<h3 id="412-initialization-of-static-local-variables"><a class="markdownIt-Anchor" href="#412-initialization-of-static-local-variables"></a> 4.1.2 Initialization of static Local Variables</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> Bar bar;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The initialization process is equivalent to the following program, where:</p>
<ul>
<li><code>guard_for_bar</code> is an integer variable used to ensure thread safety and one-time initialization. It is generated by the compiler and stored in the <code>bss</code> segment. The lowest byte of this variable serves as a flag indicating whether the corresponding static variable has been initialized. If it is <code>0</code>, it means the variable has not been initialized yet; otherwise, it means it has been initialized.</li>
<li><code>__cxa_guard_acquire</code> is essentially a locking process, while <code>__cxa_guard_abort</code> and <code>__cxa_guard_release</code> release the lock.</li>
<li><code>__cxa_atexit</code> registers a function to be executed when <code>exit</code> is called or when a dynamic library (or shared library) is unloaded. In this case, the destructor of <code>Bar</code> is registered.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((guard_for_bar &amp; <span class="number">0xff</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__cxa_guard_acquire(&amp;guard_for_bar)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Bar::<span class="built_in">Bar</span>(&amp;bar);</span><br><span class="line">            &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">                __cxa_guard_abort(&amp;guard_for_bar);</span><br><span class="line">                <span class="keyword">throw</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            __cxa_guard_release(&amp;guard_for_bar);</span><br><span class="line">            __cxa_atexit(Bar::~Bar, &amp;bar, &amp;__dso_handle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="413-list-initialization"><a class="markdownIt-Anchor" href="#413-list-initialization"></a> 4.1.3 List-initialization</h3>
<p>Initializes an object from braced-init-list.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/list_initialization">List-initialization (since C++11)</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18009628/why-is-a-braced-init-list-not-an-expression">Why is a braced-init-list not an expression？</a></li>
</ul>
<p><strong>Direct-list-initialization:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">T object &#123; arg1, arg2, ... &#125;;</span><br><span class="line">T object &#123; .des1 = arg1, .des2 &#123; arg2 &#125; ... &#125;; (since C++<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">T &#123; arg1, arg2, ... &#125;</span><br><span class="line">T &#123; .des1 = arg1, .des2 &#123; arg2 &#125; ... &#125; (since C++<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> T &#123; arg1, arg2, ... &#125;</span><br><span class="line"><span class="keyword">new</span> T &#123; .des1 = arg1, .des2 &#123; arg2 &#125; ... &#125; (since C++<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">Class &#123; T member &#123; arg1, arg2, ... &#125;; &#125;;</span><br><span class="line">Class &#123; T member &#123; .des1 = arg1, .des2 &#123; arg2 &#125; ... &#125;; &#125;; (since C++<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">Class::<span class="built_in">Class</span>() : member &#123; arg1, arg2, ... &#125; &#123;...</span><br><span class="line">Class::<span class="built_in">Class</span>() : member &#123; .des1 = arg1, .des2 &#123; arg2 &#125; ... &#125; &#123;... (since C++<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Copy-list-initialization:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">T object = &#123; arg1, arg2, ... &#125;;</span><br><span class="line">T object = &#123; .des1 = arg1, .des2 &#123; arg2 &#125; ... &#125;; (since C++<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">function</span> (&#123; arg1, arg2, ... &#125;)</span><br><span class="line"><span class="built_in">function</span> (&#123; .des1 = arg1, .des2 &#123; arg2 &#125; ... &#125;) (since C++<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123; arg1, arg2, ... &#125;;</span><br><span class="line"><span class="keyword">return</span> &#123; .des1 = arg1, .des2 &#123; arg2 &#125; ... &#125;; (since C++<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">object [&#123; arg1, arg2, ... &#125;]</span><br><span class="line">object [&#123; .des1 = arg1, .des2 &#123; arg2 &#125; ... &#125;] (since C++<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">object = &#123; arg1, arg2, ... &#125;</span><br><span class="line">object = &#123; .des1 = arg1, .des2 &#123; arg2 &#125; ... &#125; (since C++<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">U</span> (&#123; arg1, arg2, ... &#125;)</span><br><span class="line"><span class="built_in">U</span> (&#123; .des1 = arg1, .des2 &#123; arg2 &#125; ... &#125;) (since C++<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">Class &#123; T member = &#123; arg1, arg2, ... &#125;; &#125;;</span><br><span class="line">Class &#123; T member = &#123; .des1 = arg1, .des2 &#123; arg2 &#125; ... &#125;; &#125;; (since C++<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h4 id="4131-aggregate-initialization"><a class="markdownIt-Anchor" href="#4131-aggregate-initialization"></a> 4.1.3.1 Aggregate initialization</h4>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">Aggregate initialization</a></p>
<p>Initializes an aggregate from an initializer list. It is a form of list-initialization</p>
<p>An aggregate is one of the following types:</p>
<ol>
<li>array types</li>
<li>class types that has
<ul>
<li>no user-declared constructors</li>
<li>no private or protected direct non-static data members</li>
<li>no base classes</li>
<li>…</li>
</ul>
</li>
</ol>
<p>Each member can choose to use copy constructor or move constructor independently:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp; foo) &#123; std::cout &lt;&lt; <span class="string">&quot;Foo::Foo(const Foo&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(Foo&amp;&amp; foo) &#123; std::cout &lt;&lt; <span class="string">&quot;Foo::Foo(Foo&amp;&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bar</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Bar</span>(<span class="type">const</span> Bar&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Bar::Bar(const Bar&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Bar</span>(Bar&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Bar::Bar(Bar&amp;&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    Bar bar;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    Bar bar;</span><br><span class="line">    Container c&#123;.foo = foo, .bar = std::<span class="built_in">move</span>(bar)&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="42-pointer"><a class="markdownIt-Anchor" href="#42-pointer"></a> 4.2 Pointer</h2>
<h3 id="421-multi-dimensional-pointer"><a class="markdownIt-Anchor" href="#421-multi-dimensional-pointer"></a> 4.2.1 Multi-dimensional Pointer</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Using a pointer to a 2D array</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yourFunction1</span><span class="params">(<span class="type">bool</span> (*rows)[<span class="number">9</span>])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Access elements of the 2D array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            std::cout &lt;&lt; rows[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using a reference to a 2D array</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yourFunction2</span><span class="params">(<span class="type">bool</span> (&amp;rows)[<span class="number">9</span>][<span class="number">9</span>])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Access elements of the 2D array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            std::cout &lt;&lt; rows[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> rows[<span class="number">9</span>][<span class="number">9</span>] = &#123;</span><br><span class="line">            <span class="comment">// Initialize the array as needed</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass the local variable to the functions</span></span><br><span class="line">    <span class="built_in">yourFunction1</span>(rows);</span><br><span class="line">    <span class="built_in">yourFunction2</span>(rows);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="43-reference"><a class="markdownIt-Anchor" href="#43-reference"></a> 4.3 Reference</h2>
<h3 id="431-reference-initialization"><a class="markdownIt-Anchor" href="#431-reference-initialization"></a> 4.3.1 Reference Initialization</h3>
<p>References can only be initialized at the point of definition.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> &amp;ref = a;</span><br><span class="line">    ref = b;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ref=&quot;</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=2</span><br><span class="line">b=2</span><br><span class="line">ref=2</span><br></pre></td></tr></table></figure>
<h2 id="44-class"><a class="markdownIt-Anchor" href="#44-class"></a> 4.4 Class</h2>
<h3 id="441-member-initializer-list"><a class="markdownIt-Anchor" href="#441-member-initializer-list"></a> 4.4.1 Member Initializer List</h3>
<ol>
<li>For built-in types, a direct value copy is made. There’s no difference between using an initializer list or initializing within the constructor body.</li>
<li>For class types:
<ul>
<li>Initializing in the initializer list: Calls either the copy constructor or the move constructor.</li>
<li>Initializing in the constructor body: Even though it’s not explicitly specified in the initializer list, the default constructor is still called to initialize it, followed by the use of the copy or move assignment operator within the constructor body.</li>
</ul>
</li>
<li>What must be placed in the initializer list:
<ul>
<li>Constant members</li>
<li>Reference types</li>
<li>Class types without a default constructor, because using the initializer list avoids the need to call the default constructor and instead directly calls the copy or move constructor for initialization.</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s default constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a) : _a(a), _b(<span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s (int) constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b) : _a(a), _b(b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s (int, int) constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a) : _a(a._a), _b(a._b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s copy constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(A &amp;&amp;a) : _a(a._a), _b(a._b) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s move constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="type">const</span> A &amp;a) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s copy assign operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = a._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(A &amp;&amp;a) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&#x27;s move assign operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a._a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_b = a._b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(A &amp;a) : _a(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(A &amp;a, std::<span class="type">nullptr_t</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(A &amp;&amp;a) : _a(std::<span class="built_in">move</span>(a)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(A &amp;&amp;a, std::<span class="type">nullptr_t</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_a = std::<span class="built_in">move</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;============(create a)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(create b1)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(a)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(create b2)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(a, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(create b3)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">B <span class="title">b3</span><span class="params">(<span class="keyword">static_cast</span>&lt;A &amp;&amp;&gt;(a))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n============(create b4)============&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">B <span class="title">b4</span><span class="params">(<span class="keyword">static_cast</span>&lt;A &amp;&amp;&gt;(a), <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">============(create a)============</span><br><span class="line">A&#x27;s (int, int) constructor</span><br><span class="line"></span><br><span class="line">============(create b1)============</span><br><span class="line">A&#x27;s copy constructor</span><br><span class="line"></span><br><span class="line">============(create b2)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line">A&#x27;s copy assign operator</span><br><span class="line"></span><br><span class="line">============(create b3)============</span><br><span class="line">A&#x27;s move constructor</span><br><span class="line"></span><br><span class="line">============(create b4)============</span><br><span class="line">A&#x27;s default constructor</span><br><span class="line">A&#x27;s move assign operator</span><br></pre></td></tr></table></figure>
<h3 id="442-initialization-order-of-class-members"><a class="markdownIt-Anchor" href="#442-initialization-order-of-class-members"></a> 4.4.2 Initialization Order of Class Members</h3>
<ol>
<li>Initializer list</li>
<li>List initialization at the member definition, which takes effect only if the member is not included in the initializer list</li>
<li>Initialization behavior within the constructor body</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initialized_where_defined</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;initialized_where_defined&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initialized_at_initialization_list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;initialized_at_initialization_list&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">initialized_at_construct_block</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;initialized_at_construct_block&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; _data = <span class="built_in">initialized_at_construct_block</span>(); &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) : _data(<span class="built_in">initialized_at_initialization_list</span>()) &#123; _data = <span class="built_in">initialized_at_construct_block</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _data = <span class="built_in">initialized_where_defined</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    Foo f1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n---------------------------------------\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Foo <span class="title">f2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">initialized_where_defined</span><br><span class="line">initialized_at_construct_block</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br><span class="line">initialized_at_initialization_list</span><br><span class="line">initialized_at_construct_block</span><br></pre></td></tr></table></figure>
<h3 id="443-initialization-of-non-static-class-members"><a class="markdownIt-Anchor" href="#443-initialization-of-non-static-class-members"></a> 4.4.3 Initialization of non-static Class Members</h3>
<p>Non-static members are not allowed to use constructor initialization, but they are allowed to use list initialization (which essentially still calls the corresponding constructor).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val) &#123; std::cout &lt;&lt; <span class="string">&quot;Foo(int)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Foo foo&#123;<span class="number">5</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bar bar;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="444-how-to-define-static-members-in-a-class"><a class="markdownIt-Anchor" href="#444-how-to-define-static-members-in-a-class"></a> 4.4.4 How to define static members in a class</h3>
<p><strong>Declare static members in the class and define (assign) static members outside the class, as shown in the example below:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> BUFFER_LEN;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> Demo::BUFFER_LEN = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Demo::BUFFER_LEN &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="445-non-static-members-of-a-class-cannot-undergo-type-deduction"><a class="markdownIt-Anchor" href="#445-non-static-members-of-a-class-cannot-undergo-type-deduction"></a> 4.4.5 Non-static members of a Class cannot undergo type deduction</h3>
<p>Non-static members of a class cannot undergo type deduction; the type must be explicitly specified (as the type information must be immutable). Static members, however, can. For example, the following code contains a syntax error:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Delegate</span>(Func func) : _func(std::<span class="built_in">move</span>(func)) &#123; _func(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Func _func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() : _delegate(Foo::do_something) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> Delegate _s_delegate&#123;Foo::do_something&#125;;</span><br><span class="line">    <span class="comment">// Use of class template &#x27;Delegate&#x27; requires template arguments</span></span><br><span class="line">    <span class="comment">// Argument deduction not allowed in non-static class member (clang auto_not_allowed</span></span><br><span class="line">    Delegate _delegate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="446-member-function-pointer"><a class="markdownIt-Anchor" href="#446-member-function-pointer"></a> 4.4.6 Member Function Pointer</h3>
<p>Member function pointers need to be invoked using the <code>.*</code> or <code>-&gt;*</code> operators.</p>
<ul>
<li>Inside the class: <code>(this-&gt;*&lt;name&gt;)(args...)</code></li>
<li>Outside the class: <code>(obj.*obj.&lt;name&gt;)(args...)</code> or <code>(pointer-&gt;*pointer-&gt;&lt;name&gt;)(args...)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Demo</span><span class="params">(<span class="type">bool</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            say_hi = &amp;Demo::say_hi_1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            say_hi = &amp;Demo::say_hi_2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">invoke_say_hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">this</span>-&gt;*say_hi)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (Demo::*say_hi)() = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say_hi_1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say_hi_2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo::say_hi_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;say_hi_1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo::say_hi_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;say_hi_2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Demo <span class="title">demo1</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke inside class</span></span><br><span class="line">    demo1.<span class="built_in">invoke_say_hi</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke outside class with obj</span></span><br><span class="line">    (demo1.*demo1.say_hi)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke outside class with pointer</span></span><br><span class="line">    Demo *p1 = &amp;demo1;</span><br><span class="line">    (p1-&gt;*p1-&gt;say_hi)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invoke outside class with pointer</span></span><br><span class="line">    std::shared_ptr&lt;Demo&gt; sp1 = std::<span class="built_in">make_shared</span>&lt;Demo&gt;(<span class="literal">false</span>);</span><br><span class="line">    (sp1.<span class="built_in">get</span>()-&gt;*sp1-&gt;say_hi)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="447-mock-class"><a class="markdownIt-Anchor" href="#447-mock-class"></a> 4.4.7 Mock class</h3>
<p>Sometimes during testing, we need to mock the implementation of a class. We can implement all the methods of this class (<strong>note, it must be all methods</strong>) in the test <code>.cpp</code> file, which will override the implementation in the original library. Below is an example:</p>
<p><strong>Directory structure is as follows</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── lib</span><br><span class="line">│   ├── libperson.a</span><br><span class="line">│   ├── person.cpp</span><br><span class="line">│   ├── person.h</span><br><span class="line">│   └── person.o</span><br><span class="line">└── main.cpp</span><br></pre></td></tr></table></figure>
<p><strong><code>lib/person.h</code>:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><code>lib/person.cpp</code>:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;work&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sleep&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;eat&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Build <code>person.cpp</code> to <code>.a</code></strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ person.cpp -c -std=gnu++11</span><br><span class="line">ar crv libperson.a person.o</span><br></pre></td></tr></table></figure>
<p><strong><code>main.cpp</code>:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib/person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.<span class="built_in">work</span>();</span><br><span class="line">    person.<span class="built_in">sleep</span>();</span><br><span class="line">    person.<span class="built_in">eat</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Compile <code>main.cpp</code> and execute:</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main main.cpp -std=gnu++11 -L lib -lperson</span><br><span class="line"></span><br><span class="line">./main</span><br><span class="line"></span><br><span class="line">work</span><br><span class="line"><span class="built_in">sleep</span></span><br><span class="line">eat</span><br></pre></td></tr></table></figure>
<p><strong>Next, we modify <code>main.cpp</code> to override the original <code>work</code>, <code>sleep</code>, and <code>eat</code> methods:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib/person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock work&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock sleep&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock eat&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.<span class="built_in">work</span>();</span><br><span class="line">    person.<span class="built_in">sleep</span>();</span><br><span class="line">    person.<span class="built_in">eat</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Compile <code>main.cpp</code> and execute:</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main main.cpp -std=gnu++11 -L lib -lperson</span><br><span class="line"></span><br><span class="line">./main</span><br><span class="line"></span><br><span class="line">mock work</span><br><span class="line">mock <span class="built_in">sleep</span></span><br><span class="line">mock eat</span><br></pre></td></tr></table></figure>
<p><strong>Then, we proceed to modify <code>main.cpp</code> by removing one of the methods:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib/person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock work&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mock sleep&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void Person::eat() &#123;</span></span><br><span class="line"><span class="comment">//     std::cout &lt;&lt; &quot;mock eat&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line">    person.<span class="built_in">work</span>();</span><br><span class="line">    person.<span class="built_in">sleep</span>();</span><br><span class="line">    person.<span class="built_in">eat</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Compile <code>main.cpp</code>(Failed)</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">g++ -o main main.cpp -std=gnu++11 -L lib -lperson</span><br><span class="line"></span><br><span class="line">lib/libperson.a(person.o)：在函数<span class="string">&#x27;Person::work()&#x27;</span>中：</span><br><span class="line">person.cpp:(.text+0x0): Person::work() 的多重定义</span><br><span class="line">/tmp/ccfhnlz4.o:main.cpp:(.text+0x0)：第一次在此定义</span><br><span class="line">lib/libperson.a(person.o)：在函数<span class="string">&#x27;Person::sleep()&#x27;</span>中：</span><br><span class="line">person.cpp:(.text+0x2a): Person::<span class="built_in">sleep</span>() 的多重定义</span><br><span class="line">/tmp/ccfhnlz4.o:main.cpp:(.text+0x2a)：第一次在此定义</span><br><span class="line">collect2: 错误：ld 返回 1</span><br></pre></td></tr></table></figure>
<h2 id="45-operator-overloading"><a class="markdownIt-Anchor" href="#45-operator-overloading"></a> 4.5 Operator Overloading</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operators">operator overloading</a></li>
</ul>
<p>Overloaded operators are functions with special function names:</p>
<ul>
<li>
<p><code>operator op</code></p>
</li>
<li>
<p><code>operator type</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val == <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Foo <span class="title">getFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getFoo</span>()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>operator new</code></p>
</li>
<li>
<p><code>operator new []</code></p>
</li>
<li>
<p><code>operator delete</code></p>
</li>
<li>
<p><code>operator delete []</code></p>
</li>
<li>
<p><code>operator &quot;&quot; suffix-identifier</code></p>
</li>
<li>
<p><code>operator co_await</code></p>
</li>
</ul>
<h3 id="451-stdforward-cannot-convert-brace-enclosed-initializer-list"><a class="markdownIt-Anchor" href="#451-stdforward-cannot-convert-brace-enclosed-initializer-list"></a> 4.5.1 std::forward cannot convert brace-enclosed initializer list</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="built_in">Foo</span>(std::vector&lt;<span class="type">int</span>&gt; data_) : <span class="built_in">data</span>(data_) &#123;&#125;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Foo <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Foo&gt; <span class="title">create_ptr_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Foo&gt;(&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Foo&gt; <span class="title">create_ptr_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Compile error</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;Foo&gt;(&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">create</span>();</span><br><span class="line">    <span class="built_in">create_ptr_1</span>();</span><br><span class="line">    <span class="built_in">create_ptr_2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="46-variadic-arguments"><a class="markdownIt-Anchor" href="#46-variadic-arguments"></a> 4.6 Variadic Arguments</h2>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/variadic_arguments">Variadic arguments</a></p>
<p>Allows a function to accept any number of extra arguments.</p>
<p>Within the body of a function that uses variadic arguments, the values of these arguments may be accessed using the <code>&lt;cstdarg&gt;</code> library facilities:</p>
<ul>
<li><code>va_start</code>: enables access to variadic function arguments</li>
<li><code>va_arg</code>: accesses the next variadic function argument</li>
<li><code>va_copy</code>: makes a copy of the variadic function arguments</li>
<li><code>va_end</code>: ends traversal of the variadic function arguments</li>
<li><code>va_list</code>: holds the information needed by va_start, va_arg, va_end, and va_copy</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        result += <span class="built_in">va_arg</span>(args, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl;            <span class="comment">// Output: 6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>) &lt;&lt; std::endl; <span class="comment">// Output: 150</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>How it works?</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12371450/how-are-variable-arguments-implemented-in-gcc">How are variable arguments implemented in gcc?</a></li>
</ul>
<p>If you look at the way the C language stores the parameters on the stack, the way the macros work should become clear:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Higher memory address    Last parameter</span><br><span class="line">                         Penultimate parameter</span><br><span class="line">                         ....</span><br><span class="line">                         Second parameter</span><br><span class="line">Lower memory address     First parameter</span><br><span class="line">       StackPointer  -&gt;  Return address</span><br></pre></td></tr></table></figure>
<p>The arguments are always stored like this, even without the <code>...</code> parameter type.</p>
<p>The <code>va_start</code> macro just sets up a pointer to the last named parameter:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// va_start</span></span><br><span class="line">    <span class="type">char</span>* p = (<span class="type">char</span>*)&amp;a + <span class="keyword">sizeof</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>which makes <code>p</code> point to the second parameter. The <code>va_arg</code> macro does this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// va_start</span></span><br><span class="line">    <span class="type">char</span>* p = (<span class="type">char</span>*)&amp;a + <span class="keyword">sizeof</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// va_arg</span></span><br><span class="line">    <span class="type">int</span> i1 = *((<span class="type">int</span>*)p);</span><br><span class="line">    p += <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// va_arg</span></span><br><span class="line">    <span class="type">int</span> i2 = *((<span class="type">int</span>*)p);</span><br><span class="line">    p += <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// va_arg</span></span><br><span class="line">    <span class="type">long</span> i2 = *((<span class="type">long</span>*)p);</span><br><span class="line">    p += <span class="built_in">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>va_end</code> macro just sets the <code>p</code> value to <code>NULL</code></p>
<h3 id="461-how-to-forward-variadic-arguments"><a class="markdownIt-Anchor" href="#461-how-to-forward-variadic-arguments"></a> 4.6.1 How to forward variadic arguments</h3>
<p><strong>Conclusion: Variadic arguments cannot be directly forwarded via function call.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* __restrict __format, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, __format);</span><br><span class="line">    std::<span class="built_in">printf</span>(__format, args);</span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward_vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* __restrict __format, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, __format);</span><br><span class="line">    std::<span class="built_in">vprintf</span>(__format, args);</span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FORWARD_PRINTF(format, ...) std::printf(format, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;std::printf: %d + %d = %d\n&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line">    forward_printf(<span class="string">&quot;forward_printf: %d + %d = %d\n&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line">    forward_vprintf(<span class="string">&quot;forward_vprintf: %d + %d = %d\n&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">FORWARD_PRINTF</span>(<span class="string">&quot;FORWARD_PRINTF: %d + %d = %d\n&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="462-implicit-type-conversion"><a class="markdownIt-Anchor" href="#462-implicit-type-conversion"></a> 4.6.2 Implicit Type Conversion</h3>
<p><strong>Conclusion: Variadic arguments do not support implicit type conversion</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IntWrap</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *val; &#125;</span><br><span class="line">    <span class="type">int</span>* val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> count, ...)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        result += <span class="built_in">va_arg</span>(args, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_template</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val1 = <span class="number">1</span>, val2 = <span class="number">2</span>, val3 = <span class="number">3</span>;</span><br><span class="line">    IntWrap wrap1&#123;&amp;val1&#125;, wrap2&#123;&amp;val2&#125;, wrap3&#123;&amp;val3&#125;;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Implicit type conversion not happen</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">sum</span>(<span class="number">3</span>, wrap1, wrap2, wrap3);</span><br><span class="line">        std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Explicit type conversion works</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">sum</span>(<span class="number">3</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(wrap1), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(wrap2), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(wrap3));</span><br><span class="line">        std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Implicit type conversion works</span></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">sum_template</span>(wrap1, wrap2, wrap3);</span><br><span class="line">        std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="47-attributes"><a class="markdownIt-Anchor" href="#47-attributes"></a> 4.7 Attributes</h2>
<p><code>__attribute__</code> is a feature specific to the <code>GCC</code> compiler that allows programmers to provide the compiler with certain instructions to optimize during compilation or apply additional constraints during runtime. These instructions are called attributes (<code>attributes</code>) and can be applied to various program elements such as functions, variables, and types.</p>
<p><code>C++11</code> introduced a new language feature called attributes (<code>attributes</code>), which are similar to <code>__attribute__</code> but are part of the standard <code>C++</code>, making them usable in <code>C++</code> code after the compiler supports <code>C++11</code>. Unlike <code>__attribute__</code>, <code>C++11</code> attributes can be used at the class and namespace levels, not just at the function and variable levels.</p>
<p><code>C++11</code> attributes also provide more flexibility and readability. They can be embedded in the code in a more natural way, unlike <code>__attribute__</code>, which requires some verbose syntax. Additionally, <code>C++11</code> attributes offer some useful new features such as <code>[[noreturn]]</code>, <code>[[carries_dependency]]</code>, <code>[[deprecated]]</code>, <code>[[fallthrough]]</code>.</p>
<p>Common <code>__attribute__</code> list:</p>
<ul>
<li>
<p><code>__attribute__((packed))</code>: Instructs the compiler to pack structure members as tightly as possible to reduce the memory footprint of the structure.</p>
</li>
<li>
<p><code>__attribute__((aligned(n)))</code>: Instructs the compiler to align a variable to an <code>n</code>-byte boundary.</p>
</li>
<li>
<p><code>__attribute__((noreturn))</code>: Instructs the compiler that the function will not return, which is used to inform the compiler that no cleanup is needed after the function call.</p>
</li>
<li>
<p><code>__attribute__((unused))</code>: Instructs the compiler not to issue a warning for unused variables.</p>
</li>
<li>
<p><code>__attribute__((deprecated))</code>: Instructs the compiler that the function or variable is deprecated, and the compiler will issue a warning when they are used.</p>
</li>
<li>
<p><code>__attribute__((visibility(&quot;hidden&quot;)))</code>: Instructs the compiler to hide the symbol, meaning it will not appear in the exported symbol table of the current compilation unit.</p>
</li>
<li>
<p><code>__attribute__((guarded_by(mutex)))</code>: is used to annotate a data member (usually a class member variable) to indicate that it is protected by a specific <code>mutex</code>. This attribute acts as a directive to the compiler or static analysis tools to help ensure thread safety.</p>
</li>
<li>
<p><code>__attribute__(alias)</code>: Allows you to specify the name of a function or variable as an alias for an existing function or variable. It can serve a similar purpose as the linker parameter <code>--wrap=&lt;symbol&gt;</code>.</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE* <span class="title">my_fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* mode)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is my fopen!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* mode)</span> __<span class="title">attribute__</span><span class="params">((alias(<span class="string">&quot;my_fopen&quot;</span>)))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calling the fopen() function...\n&quot;</span>);</span><br><span class="line">    FILE* fd = <span class="built_in">fopen</span>(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fopen() returned NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fopen() succeeded\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Common <code>attributes</code> list:</p>
<ul>
<li><code>[[noreturn]]</code> (C++11): Indicates that a function will not return. If a function is marked with <code>[[noreturn]]</code>, the compiler will issue a warning or error for any attempt to return a value from that function.</li>
<li><code>[[deprecated]]</code> (C++14): Indicates that a function or variable is deprecated. The compiler will issue a warning when a function or variable marked with <code>[[deprecated]]</code> is called or used.</li>
<li><code>[[fallthrough]]</code> (C++17): Used to indicate a <code>case</code> label in a <code>switch</code> statement, signaling that the code intentionally falls through to the next <code>case</code> label.</li>
<li><code>[[nodiscard]]</code> (C++17): Indicates that the return value of a function should be checked. When a function is marked with <code>[[nodiscard]]</code>, the compiler will issue a warning if the return value is not checked.</li>
<li><code>[[maybe_unused]]</code> (C++17): Indicates that a variable or function may be unused. The compiler will not issue a warning for unused variables or functions.</li>
<li><code>[[likely]]</code> (C++20): Hints to the compiler that this branch is likely to be <code>true</code>.</li>
<li><code>[[unlikely]]</code> (C++20): Hints to the compiler that this branch is likely to be <code>false</code>.</li>
</ul>
<h3 id="471-aligned"><a class="markdownIt-Anchor" href="#471-aligned"></a> 4.7.1 aligned</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOO_WITH_ALIGN(SIZE) \</span></span><br><span class="line"><span class="meta">    struct Foo_##SIZE &#123;      \</span></span><br><span class="line"><span class="meta">        int v;               \</span></span><br><span class="line"><span class="meta">    &#125; __attribute__((aligned(SIZE)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_SIZEOF_FOO(SIZE) std::cout &lt;&lt; <span class="string">&quot;Foo_##SIZE&#x27;s size=&quot;</span> &lt;&lt; sizeof(Foo_##SIZE) &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">32</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">64</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">FOO_WITH_ALIGN</span>(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">64</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">PRINT_SIZEOF_FOO</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="472-reference"><a class="markdownIt-Anchor" href="#472-reference"></a> 4.7.2 Reference</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.keil.com/support/man/docs/armcc/armcc_chr1359124965789.htm">Compiler-specific Features</a></li>
</ul>
<h2 id="48-asm"><a class="markdownIt-Anchor" href="#48-asm"></a> 4.8 ASM</h2>
<p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/">gcc-online-docs</a></p>
<h3 id="481-basic-asm"><a class="markdownIt-Anchor" href="#481-basic-asm"></a> 4.8.1 Basic Asm</h3>
<h3 id="482-extended-asm"><a class="markdownIt-Anchor" href="#482-extended-asm"></a> 4.8.2 Extended Asm</h3>
<p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">Extended Asm</a>: GCC设计了一种特有的嵌入方式，它规定了汇编代码嵌入的形式和嵌入汇编代码需要由哪几个部分组成，格式如下：</p>
<ul>
<li>汇编语句模板是必须的，其余三部分是可选的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="keyword">asm</span>-<span class="built_in">qualifiers</span> ( AssemblerTemplate </span><br><span class="line">                 : OutputOperands </span><br><span class="line">                 [ : InputOperands</span><br><span class="line">                 [ : Clobbers ] ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">asm</span> <span class="keyword">asm</span>-<span class="built_in">qualifiers</span> ( AssemblerTemplate </span><br><span class="line">                      : OutputOperands</span><br><span class="line">                      : InputOperands</span><br><span class="line">                      : Clobbers</span><br><span class="line">                      : GotoLabels)</span><br></pre></td></tr></table></figure>
<p><strong><code>Qualifiers</code>，修饰符：</strong></p>
<ul>
<li><code>volatile</code>：禁止编译器优化</li>
<li><code>inline</code></li>
<li><code>goto</code></li>
</ul>
<p><strong><code>AssemblerTemplate</code>，汇编语句模板：</strong></p>
<ul>
<li>汇编语句模板由汇编语句序列组成，语句之间使用<code>;</code>、<code>\n</code>、<code>\n\t</code>分开</li>
<li>指令中的操作数可以使用占位符，占位符可以指向<code>OutputOperands</code>、<code>InputOperands</code>、<code>GotoLabels</code></li>
<li>指令中使用占位符表示的操作数，总被视为<code>long</code>型（4个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节</li>
<li>对字节操作可以显式的指明是低字节还是次字节。方法是在<code>%</code>和序号之间插入一个字母
<ul>
<li><code>b</code>代表低字节</li>
<li><code>h</code>代表高字节</li>
<li>例如：<code>%h1</code></li>
</ul>
</li>
</ul>
<p><strong><code>OutputOperands</code>，输出操作数：</strong></p>
<ul>
<li>操作数之间用逗号分隔</li>
<li>每个操作数描述符由限定字符串（<code>Constraints</code>）和C语言变量或表达式组成</li>
</ul>
<p><strong><code>InputOperands</code>，输入操作数：</strong></p>
<ul>
<li>操作数之间用逗号分隔</li>
<li>每个操作数描述符由限定字符串（<code>Constraints</code>）和C语言变量或表达式组成</li>
</ul>
<p><strong><code>Clobbers</code>，描述部分：</strong></p>
<ul>
<li>用于通知编译器我们使用了哪些寄存器或内存，由逗号格开的字符串组成</li>
<li>每个字符串描述一种情况，一般是寄存器名；除寄存器外还有<code>memory</code>。例如：<code>%eax</code>，<code>%ebx</code>，<code>memory</code>等</li>
</ul>
<p><strong><code>Constraints</code>，限定字符串（下面仅列出常用的）：</strong></p>
<ul>
<li><code>m</code>：内存</li>
<li><code>o</code>：内存，但是其寻址方式是偏移量类型</li>
<li><code>v</code>：内存，但寻址方式不是偏移量类型</li>
<li><code>r</code>：通用寄存器</li>
<li><code>i</code>：整型立即数</li>
<li><code>g</code>：任意通用寄存器、内存、立即数</li>
<li><code>p</code>：合法指针</li>
<li><code>=</code>：write-only</li>
<li><code>+</code>：read-write</li>
<li><code>&amp;</code>：该输出操作数不能使用过和输入操作数相同的寄存器</li>
</ul>
<p><strong>示例1：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">atomic_t</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int32_t</span> a_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int32_t</span> <span class="title">atomic_read</span><span class="params">(<span class="type">const</span> <span class="type">atomic_t</span>* v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">volatile</span> <span class="type">int32_t</span>*)&amp;(v)-&gt;a_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">atomic_write</span><span class="params">(<span class="type">atomic_t</span>* v, <span class="type">int32_t</span> i)</span> </span>&#123;</span><br><span class="line">    v-&gt;a_count = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">atomic_add</span><span class="params">(<span class="type">atomic_t</span>* v, <span class="type">int32_t</span> i)</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">            <span class="string">&quot;lock;&quot;</span></span><br><span class="line">            <span class="string">&quot;addl %1,%0&quot;</span></span><br><span class="line">            : <span class="string">&quot;+m&quot;</span>(v-&gt;a_count)</span><br><span class="line">            : <span class="string">&quot;ir&quot;</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">atomic_sub</span><span class="params">(<span class="type">atomic_t</span>* v, <span class="type">int32_t</span> i)</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">            <span class="string">&quot;lock;&quot;</span></span><br><span class="line">            <span class="string">&quot;subl %1,%0&quot;</span></span><br><span class="line">            : <span class="string">&quot;+m&quot;</span>(v-&gt;a_count)</span><br><span class="line">            : <span class="string">&quot;ir&quot;</span>(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">atomic_inc</span><span class="params">(<span class="type">atomic_t</span>* v)</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">            <span class="string">&quot;lock;&quot;</span></span><br><span class="line">            <span class="string">&quot;incl %0&quot;</span></span><br><span class="line">            : <span class="string">&quot;+m&quot;</span>(v-&gt;a_count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">atomic_dec</span><span class="params">(<span class="type">atomic_t</span>* v)</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">            <span class="string">&quot;lock;&quot;</span></span><br><span class="line">            <span class="string">&quot;decl %0&quot;</span></span><br><span class="line">            : <span class="string">&quot;+m&quot;</span>(v-&gt;a_count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">atomic_t</span> v;</span><br><span class="line">    <span class="built_in">atomic_write</span>(&amp;v, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">atomic_add</span>(&amp;v, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">atomic_sub</span>(&amp;v, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">atomic_inc</span>(&amp;v);</span><br><span class="line">    <span class="built_in">atomic_dec</span>(&amp;v);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">atomic_read</span>(&amp;v) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<ul>
<li>这个程序是没法跑的，因为<code>cli</code>指令必须在内核态执行</li>
<li><code>hal_save_flags_cli</code>：将<code>eflags</code>寄存器的值保存到内存中，然后关闭中断</li>
<li><code>hal_restore_flags_sti</code>：将<code>hal_save_flags_cli</code>保存在内存中的值恢复到<code>eflags</code>寄存器中</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">cpuflg_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">hal_save_flags_cli</span><span class="params">(<span class="type">cpuflg_t</span>* flags)</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span> <span class="comment">// 把eflags寄存器的值压入当前栈顶</span></span><br><span class="line">            <span class="string">&quot;cli;&quot;</span>   <span class="comment">// 关闭中断，会改变eflags寄存器的值</span></span><br><span class="line">            <span class="string">&quot;pop %0&quot;</span> <span class="comment">// 把当前栈顶弹出到eflags为地址的内存中</span></span><br><span class="line">            : <span class="string">&quot;=m&quot;</span>(*flags)</span><br><span class="line">            :</span><br><span class="line">            : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">hal_restore_flags_sti</span><span class="params">(<span class="type">cpuflg_t</span>* flags)</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">            <span class="string">&quot;push %0;&quot;</span> <span class="comment">// 把flags为地址处的值寄存器压入当前栈顶</span></span><br><span class="line">            <span class="string">&quot;popf&quot;</span>     <span class="comment">// 把当前栈顶弹出到eflags寄存器中</span></span><br><span class="line">            :</span><br><span class="line">            : <span class="string">&quot;m&quot;</span>(*flags)</span><br><span class="line">            : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">cpuflg_t</span>* flags)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">hal_save_flags_cli</span>(flags);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;step1: foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">hal_restore_flags_sti</span>(flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">cpuflg_t</span> flags;</span><br><span class="line">    <span class="built_in">hal_save_flags_cli</span>(&amp;flags);</span><br><span class="line">    <span class="built_in">foo</span>(&amp;flags);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;step2: bar()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">hal_restore_flags_sti</span>(&amp;flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：linux内核大量用到了<code>asm</code>，具体可以参考<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm">linux-asm</a></strong></p>
<h2 id="49-lambda"><a class="markdownIt-Anchor" href="#49-lambda"></a> 4.9 Lambda</h2>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/lambda">Lambda expressions (since C++11)</a></p>
<blockquote>
<p>The lambda expression is a prvalue expression of unique unnamed non-union non-aggregate class type, known as closure type, which is declared (for the purposes of ADL) in the smallest block scope, class scope, or namespace scope that contains the lambda expression. The closure type has the following members, they cannot be explicitly instantiated, explicitly specialized, or (since C++14) named in a friend declaration</p>
</blockquote>
<ul>
<li>每个<code>Lambda</code>表达式都是独一无二的类型，且无法显式声明</li>
</ul>
<h3 id="491-stdfunction-and-lambda"><a class="markdownIt-Anchor" href="#491-stdfunction-and-lambda"></a> 4.9.1 <code>std::function</code> and Lambda</h3>
<p>在大多数场景下，<code>Lambda</code>和<code>std::function</code>可以相互替换使用，但它们之间存在一些差异（<a target="_blank" rel="noopener" href="https://www.quora.com/Whats-the-difference-between-a-lambda-expression-and-a-function-pointer-callback-in-C++">What’s the difference between a lambda expression and a function pointer (callback) in C++?</a>）：</p>
<ul>
<li><code>Lambda</code>无法显式声明类型，而<code>std::function</code>可以</li>
<li><code>Lambda</code>效率更高，参考<a href="/2021/10/15/Cpp-Performance-Optimization/" title="Cpp-Performance-Optimization">Cpp-Performance-Optimization</a>
<ul>
<li><code>std::function</code>本质上是个函数指针的封装，当传递它时，编译器很难进行内联优化</li>
<li><code>Lambda</code>本质上是传递某个匿名类的实例，有确定的类型信息，编译器可以很容易地进行内联优化</li>
</ul>
</li>
</ul>
<h3 id="492-how-lambda-capture-itself"><a class="markdownIt-Anchor" href="#492-how-lambda-capture-itself"></a> 4.9.2 How lambda capture itself</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; recursiveLambda;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Must use reference to capture itself</span></span><br><span class="line">    recursiveLambda = [&amp;recursiveLambda](<span class="type">int</span> x) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="built_in">recursiveLambda</span>(x - <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">recursiveLambda</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="493-c-stype-function-pointer"><a class="markdownIt-Anchor" href="#493-c-stype-function-pointer"></a> 4.9.3 C-Stype function pointer</h3>
<p>According to <a target="_blank" rel="noopener" href="https://eel.is/c++draft/expr.unary.op">expr.unary.op</a>/7</p>
<blockquote>
<p>The operand of the unary + operator shall be a prvalue of arithmetic, unscoped enumeration, or pointer type and the result is the value of the argument. Integral promotion is performed on integral or enumeration operands. The type of the result is the type of the promoted operand.</p>
</blockquote>
<p>According to <a target="_blank" rel="noopener" href="https://eel.is/c++draft/expr.prim.lambda.closure">expr.prim.lambda.closure</a>/1</p>
<blockquote>
<p>The type of a lambda-expression (which is also the type of the closure object) is a unique, unnamed non-union class type, called the closure type, whose properties are described below.</p>
</blockquote>
<p>According to <a target="_blank" rel="noopener" href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda">expr.prim.lambda</a>/6</p>
<blockquote>
<p>The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type’s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type’s function call operator.</p>
</blockquote>
<p><strong>Explicit cast to C-style function pointer by using unary operator <code>+</code>:</strong></p>
<ul>
<li>This is necessary in some cases like <code>libcurl</code> when you setting up the callback.</li>
<li>And in most cases, the labmda will automatically cast to C-style function pointer where there needs a C-style function pointer.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> AddFunType = <span class="built_in">int</span> (*)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"><span class="keyword">using</span> NegativeFunType = <span class="built_in">int</span> (*)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OperatorType</span> &#123;</span><br><span class="line">    ADD = <span class="number">0</span>,</span><br><span class="line">    NEGATIVE = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">invoke_operator</span><span class="params">(OperatorType op, ...)</span> </span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, op);</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD: &#123;</span><br><span class="line">        AddFunType add_func = <span class="built_in">va_arg</span>(args, AddFunType);</span><br><span class="line">        <span class="type">int</span> num1 = <span class="built_in">va_arg</span>(args, <span class="type">int</span>);</span><br><span class="line">        <span class="type">int</span> num2 = <span class="built_in">va_arg</span>(args, <span class="type">int</span>);</span><br><span class="line">        <span class="built_in">va_end</span>(args);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">add_func</span>(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> NEGATIVE: &#123;</span><br><span class="line">        NegativeFunType negative_func = <span class="built_in">va_arg</span>(args, NegativeFunType);</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">va_arg</span>(args, <span class="type">int</span>);</span><br><span class="line">        <span class="built_in">va_end</span>(args);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">negative_func</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;Invalid operator type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Must use + to explicitly convert lambda to function pointer, otherwise it may crash</span></span><br><span class="line">        <span class="keyword">auto</span> lambda_add = +[](<span class="type">int</span> num1, <span class="type">int</span> num2) &#123; <span class="keyword">return</span> num1 + num2; &#125;;</span><br><span class="line">        <span class="type">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> ret = <span class="built_in">invoke_operator</span>(OperatorType::ADD, lambda_add, num1, num2);</span><br><span class="line">        std::cout &lt;&lt; num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Must use + to explicitly convert lambda to function pointer, otherwise it may crash</span></span><br><span class="line">        <span class="keyword">auto</span> lambda_negative = +[](<span class="type">int</span> num) &#123; <span class="keyword">return</span> -num; &#125;;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> ret = <span class="built_in">invoke_operator</span>(OperatorType::NEGATIVE, lambda_negative, num);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;-(&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>References:</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17822131/resolving-ambiguous-overload-on-function-pointer-and-stdfunction-for-a-lambda">Resolving ambiguous overload on function pointer and std::function for a lambda using + (unary plus)</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18889028/a-positive-lambda-what-sorcery-is-this">A positive lambda: ‘+[]{}’ - What sorcery is this? [duplicate]</a></li>
</ul>
<h2 id="410-coroutine"><a class="markdownIt-Anchor" href="#410-coroutine"></a> 4.10 Coroutine</h2>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=8sEe-4tig_A">C++20’s Coroutines for Beginners - Andreas Fertig - CppCon 2022</a></p>
<p>A coroutine is a generalization of a function that can be exited and later resumed at specific points. The key difference from functions is that coroutines can maintain state between suspensions.</p>
<ul>
<li><code>co_yield</code>: Produces a value and suspends the coroutine. The coroutine can be later resumed from this point.</li>
<li><code>co_return</code>: Ends the coroutine, potentially returning a final value.</li>
<li><code>co_await</code>: Suspends the coroutine until the awaited expression is ready, at which point the coroutine is resumed.</li>
</ul>
<p><strong>A coroutine consists of:</strong></p>
<ul>
<li>A wrapper type</li>
<li>A type with the exact name <code>promise_type</code> inside the return type of coroutine(the wrapper type), this type can be:
<ul>
<li>Type alias</li>
<li>A <code>typedef</code></li>
<li>Directly declare an inner class</li>
</ul>
</li>
<li>An awaitable type that comes into play once we use <code>co_await</code></li>
<li>An interator</li>
</ul>
<p><strong>Key Observation: A coroutine in C++ is an finite state machine(FSM) that can be controlled and customized by the promise_type</strong></p>
<p><strong>Coroutine Classifications:</strong></p>
<ul>
<li><code>Task</code>: A coroutine that does a job without returning a value.</li>
<li><code>Generator</code>: A coroutine that does a job and returns a value(either by <code>co_return</code> or <code>co_yield</code>)</li>
</ul>
<h3 id="4101-overview-of-promise_type"><a class="markdownIt-Anchor" href="#4101-overview-of-promise_type"></a> 4.10.1 Overview of <code>promise_type</code></h3>
<p>The <code>promise_type</code> for coroutines in C++20 can have several member functions which the coroutine machinery recognizes and calls at specific times or events. Here’s a general overview of the structure and potential member functions:</p>
<ul>
<li><strong>Stored Values or State:</strong> These are member variables to hold state, intermediate results, or final values. The nature of these depends on the intended use of your coroutine.</li>
<li><strong>Coroutine Creation:</strong>
<ul>
<li><code>auto get_return_object() -&gt; CoroutineReturnObject</code>: Defines how to obtain the return object of the coroutine (what the caller of the coroutine gets when invoking the coroutine).</li>
</ul>
</li>
<li><strong>Coroutine Lifecycle:</strong>
<ul>
<li><code>std::suspend_always/std::suspend_never initial_suspend() noexcept</code>: Dictates if the coroutine should start executing immediately or be suspended right after its creation.</li>
<li><code>std::suspend_always/std::suspend_never final_suspend() noexcept</code>: Dictates if the coroutine should be suspended after running to completion. If <code>std::suspend_never</code> is used, the coroutine ends immediately after execution.</li>
<li><code>void return_void()</code> noexcept: Used for coroutines with a <code>void</code> return type. Indicates the end of the coroutine.</li>
<li><code>void return_value(ReturnType value)</code>: For coroutines that produce a result, this function specifies how to handle the value provided with <code>co_return</code>.</li>
<li><code>void unhandled_exception()</code>: Invoked if there’s an unhandled exception inside the coroutine. Typically, you’d capture or rethrow the exception here.</li>
</ul>
</li>
<li><strong>Yielding Values:</strong>
<ul>
<li><code>std::suspend_always/std::suspend_never yield_value(YieldType value)</code>: Specifies what to do when the coroutine uses <code>co_yield</code>. You dictate here how the value should be handled or stored.</li>
</ul>
</li>
<li><strong>Awaiting Values:</strong>
<ul>
<li><code>auto await_transform(AwaitableType value) -&gt; Awaiter</code>: Transforms the expression after co_await. This is useful for custom awaitable types. For instance, it’s used to make this a valid awaitable in member functions.</li>
</ul>
</li>
</ul>
<h4 id="41011-awaiter"><a class="markdownIt-Anchor" href="#41011-awaiter"></a> 4.10.1.1 Awaiter</h4>
<p>The awaiter in the C++ coroutine framework is a mechanism that allows fine-tuned control over how asynchronous operations are managed and how results are produced once those operations are complete.</p>
<p>Here’s an overview of the awaiter:</p>
<p><strong>Role of the Awaiter:</strong></p>
<ul>
<li>The awaiter is responsible for defining the behavior of a <code>co_await</code> expression. It determines if the coroutine should suspend, what should be done upon suspension, and what value (if any) should be produced when the coroutine resumes.</li>
</ul>
<p><strong>Required Methods:</strong> The awaiter must provide the following three methods:</p>
<ul>
<li><code>await_ready</code>
<ul>
<li>Purpose: Determines if the coroutine needs to suspend at all.</li>
<li>Signature: <code>bool await_ready() const noexcept</code></li>
<li>Return:
<ul>
<li><code>true</code>: The awaited operation is already complete, and the coroutine shouldn’t suspend.</li>
<li><code>false</code>: The coroutine should suspend.</li>
</ul>
</li>
</ul>
</li>
<li><code>await_suspend</code>
<ul>
<li>Purpose: Dictates the actions that should be taken when the coroutine suspends.</li>
<li>Signature: <code>void await_suspend(std::coroutine_handle&lt;&gt; handle) noexcept</code></li>
<li>Parameters:
<ul>
<li><code>handle</code>: A handle to the currently executing coroutine. It can be used to later resume the coroutine.</li>
</ul>
</li>
</ul>
</li>
<li><code>await_resume</code>
<ul>
<li>Purpose: Produces a value once the awaited operation completes and the coroutine resumes.</li>
<li>Signature: <code>ReturnType await_resume() noexcept</code></li>
<li>Return: The result of the <code>co_await</code> expression. The type can be <code>void</code> if no value needs to be produced.</li>
</ul>
</li>
</ul>
<p><strong>Workflow of the Awaiter:</strong></p>
<ol>
<li><strong>Obtain the Awaiter</strong>: When a coroutine encounters <code>co_await someExpression</code>, it first needs to get an awaiter. The awaiter can be:
<ul>
<li>Directly from <code>someExpression</code> if it has an <code>operator co_await</code>.</li>
<li>Through an ADL (Argument Dependent Lookup) free function named <code>operator co_await</code> that takes <code>someExpression</code> as a parameter.</li>
<li>From the coroutine’s <code>promise_type</code> via <code>await_transform</code> if neither of the above methods produce an awaiter.</li>
</ul>
</li>
<li><strong>Call <code>await_ready</code></strong>: The coroutine calls the awaiter’s <code>await_ready()</code> method.
<ul>
<li>If it returns <code>true</code>, the coroutine continues without suspending.</li>
<li>If it returns <code>false</code>, the coroutine prepares to suspend.</li>
</ul>
</li>
<li><strong>Call <code>await_suspend (if needed)</code></strong>: If <code>await_ready</code> indicated the coroutine should suspend (by returning <code>false</code>), the <code>await_suspend</code> method is called with a handle to the current coroutine. This method typically arranges for the coroutine to be resumed later, often by setting up callbacks or handlers associated with the asynchronous operation.</li>
<li><strong>Operation Completion and Coroutine Resumption</strong>: Once the awaited operation is complete and the coroutine is resumed, the awaiter’s await_resume method is called. The value it produces becomes the result of the co_await expression.</li>
</ol>
<p><strong>Built-in Awaiters:</strong></p>
<ul>
<li><code>std::suspend_always</code>: The method <code>await_ready</code> always returns <code>false</code>, indicating that an await expression always suspends as it waits for its value</li>
<li><code>std::suspend_never</code>: The method <code>await_ready</code> always returns <code>true</code>, indicating that an await expression never suspends</li>
</ul>
<h3 id="4102-example"><a class="markdownIt-Anchor" href="#4102-example"></a> 4.10.2 Example</h3>
<p>The <code>Chat</code> struct acts as a wrapper around the coroutine handle. It allows the main code to interact with the coroutine - by resuming it, or by sending/receiving data to/from it.</p>
<p>The <code>promise_type</code> nested within <code>Chat</code> is what gives behavior to our coroutine. It defines:</p>
<ul>
<li>What happens when you start the coroutine (<code>initial_suspend</code>).</li>
<li>What happens when you <code>co_yield</code> a value (<code>yield_value</code>).</li>
<li>What happens when you <code>co_await</code> a value (<code>await_transform</code>).</li>
<li>What happens when you <code>co_return</code> a value (<code>return_value</code>).</li>
<li>What happens at the end of the coroutine (<code>final_suspend</code>).</li>
</ul>
<p>Functionality:</p>
<ol>
<li><strong>Creating the Coroutine:</strong>
<ul>
<li>When <code>Fun()</code> is called, a new coroutine is started. Due to <code>initial_suspend</code>, it is suspended immediately before executing any code.</li>
<li>The coroutine handle (with the promise) is wrapped inside the Chat object, which is then returned to the caller (main function in this case).</li>
</ul>
</li>
<li><strong>Interacting with the Coroutine:</strong>
<ul>
<li><code>chat.listen()</code>: Resumes the coroutine until the next suspension point. If <code>co_yield</code> is used inside the coroutine, the yielded value will be returned.</li>
<li><code>chat.answer(msg)</code>: Sends a message to the coroutine. If the coroutine is waiting for input using <code>co_await</code>, this will provide the awaited value and resume the coroutine.</li>
</ul>
</li>
<li><strong>Coroutine Flow:</strong>
<ul>
<li>The coroutine starts and immediately hits <code>co_yield &quot;Hello!\n&quot;;</code>. This suspends the coroutine and the string <code>&quot;Hello!\n&quot;</code> is made available to the caller.</li>
<li>In <code>main</code>, after <code>chat.listen()</code>, it prints this message.</li>
<li>Then, <code>chat.answer(&quot;Where are you?\n&quot;);</code> is called. Inside the coroutine, the message <code>&quot;Where are you?\n&quot;</code> is captured and printed because of the line <code>std::cout &lt;&lt; co_await std::string&#123;&#125;;</code>.</li>
<li>Finally, <code>co_return &quot;Here!\n&quot;;</code> ends the coroutine, and the string <code>&quot;Here!\n&quot;</code> is made available to the caller. This message is printed after the second chat.<code>listen()</code> in <code>main</code>.</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Chat</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="comment">// A: Storing a value from or for the coroutine</span></span><br><span class="line">        std::string _msg_out&#123;&#125;;</span><br><span class="line">        std::string _msg_in&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// B: What to do in case of an exception</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Chat::unhandled_exception&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// C: Coroutine creation</span></span><br><span class="line">        <span class="function">Chat <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::get_return_object&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Chat</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// D: Startup</span></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::initial_suspend&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// F: Value from co_yield</span></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(std::string msg)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::yield_value&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            _msg_out = std::<span class="built_in">move</span>(msg);</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// G: Value from co_await</span></span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(std::string)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::await_transform&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// H: Customized version instead of using suspend_always or suspend_never</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">awaiter</span> &#123;</span><br><span class="line">                promise_type&amp; pt;</span><br><span class="line">                <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::await_transform::await_ready&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function">std::string <span class="title">await_resume</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::await_transform::await_resume&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">return</span> std::<span class="built_in">move</span>(pt._msg_in);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt;)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::await_transform::await_suspend&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> awaiter&#123;*<span class="keyword">this</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// I: Value from co_return</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(std::string msg)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::return_value&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            _msg_out = std::<span class="built_in">move</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// E: Ending</span></span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; -- Chat::promise_type::final_suspend&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A: Shortcut for the handle type</span></span><br><span class="line">    <span class="keyword">using</span> Handle = std::coroutine_handle&lt;promise_type&gt;;</span><br><span class="line">    <span class="comment">// B</span></span><br><span class="line">    Handle _handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C: Get the handle from promise</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Chat</span><span class="params">(promise_type* p)</span> : _handle(Handle::from_promise(*p)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// D: Move only</span></span><br><span class="line">    <span class="built_in">Chat</span>(Chat&amp;&amp; rhs) : _handle(std::<span class="built_in">exchange</span>(rhs._handle, <span class="literal">nullptr</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// E: Care taking, destroying the handle if needed</span></span><br><span class="line">    ~<span class="built_in">Chat</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_handle) &#123;</span><br><span class="line">            _handle.<span class="built_in">destroy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// F: Active the coroutine and wait for data</span></span><br><span class="line">    <span class="function">std::string <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; -- Chat::listen&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (!_handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">            _handle.<span class="built_in">resume</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(_handle.<span class="built_in">promise</span>()._msg_out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// G Send data to the coroutine and activate it</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">answer</span><span class="params">(std::string msg)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; -- Chat::answer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        _handle.<span class="built_in">promise</span>()._msg_in = msg;</span><br><span class="line">        <span class="keyword">if</span> (!_handle.<span class="built_in">done</span>()) &#123;</span><br><span class="line">            _handle.<span class="built_in">resume</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Chat <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">co_yield</span> <span class="string">&quot;Hello!\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">co_await</span> std::string&#123;&#125;;</span><br><span class="line">    <span class="keyword">co_return</span> <span class="string">&quot;Here!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Chat chat = <span class="built_in">Fun</span>();</span><br><span class="line">    std::cout &lt;&lt; chat.<span class="built_in">listen</span>();</span><br><span class="line">    chat.<span class="built_in">answer</span>(<span class="string">&quot;Where are you?\n&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; chat.<span class="built_in">listen</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> -- Chat::promise_type::get_return_object</span><br><span class="line"> -- Chat::promise_type::initial_suspend</span><br><span class="line"> -- Chat::listen</span><br><span class="line"> -- Chat::promise_type::yield_value</span><br><span class="line">Hello!</span><br><span class="line"> -- Chat::answer</span><br><span class="line"> -- Chat::promise_type::await_transform</span><br><span class="line"> -- Chat::promise_type::await_transform::await_ready</span><br><span class="line"> -- Chat::promise_type::await_transform::await_resume</span><br><span class="line">Where are you?</span><br><span class="line"> -- Chat::promise_type::return_value</span><br><span class="line"> -- Chat::promise_type::final_suspend</span><br><span class="line"> -- Chat::listen</span><br><span class="line">Here!</span><br></pre></td></tr></table></figure>
<h1 id="5-template"><a class="markdownIt-Anchor" href="#5-template"></a> 5 template</h1>
<h2 id="51-template-category"><a class="markdownIt-Anchor" href="#51-template-category"></a> 5.1 Template category</h2>
<ol>
<li>
<p><code>Function Templates</code>: These are templates that produce templated functions that can operate on a variety of data types.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Class Templates</code>: These produce templated classes. The Standard Template Library (STL) makes heavy use of this type of template for classes like <code>std::vector</code>, <code>std::map</code>, etc.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="comment">// ... class definition ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Variable Templates</code>: Introduced in C++14, these are templates that produce templated variables.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Alias Templates</code>: These are a way to define templated <code>typedef</code>, providing a way to simplify complex type names.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T, std::allocator&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Member Function Templates</code>: These are member functions within classes that are templated. The containing class itself may or may not be templated.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">myFunction</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... function implementation ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Template Template Parameters</code>: This advanced feature allows a template to have another template as a parameter.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">ContainerType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// ... class definition ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Non-type Template Parameters</code>: These are templates that take values (like integers, pointers, etc.) as parameters rather than types.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="type">int</span> elems[size];</span><br><span class="line">    <span class="comment">// ... class definition ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Nested Templates</code>: This refers to templates defined within another template. It’s not a different kind of template per se, but rather a feature where one template can be nested inside another.</p>
</li>
</ol>
<p><strong>Function and Class Templates</strong>: When you define a function template or a class template in a header, you’re not defining an actual function or class. Instead, you’re defining a blueprint from which actual functions or classes can be instantiated. Actual instantiations of these templates (the generated functions or classes) may end up in multiple translation units, but they’re identical and thus don’t violate the ODR. Only when these templates are instantiated do they become tangible entities in the object file. If multiple translation units include the same function or class template and instantiate it in the same way, they all will have the same instantiation, so it doesn’t break One Definition Rule (ODR).</p>
<p><strong>Variable Templates</strong>: A variable template is still a blueprint, like function and class templates. But the key difference lies in how the compiler treats template instantiations for variables versus functions/classes. For variables, the instantiation actually defines a variable. If this template is instantiated in multiple translation units, it results in multiple definitions of the same variable across those translation units, violating the ODR. Thus, for variable templates, the <code>inline</code> keyword is used to ensure that all instances of a variable template across multiple translation units are treated as a single entity, avoiding ODR violations.</p>
<h3 id="511-examples"><a class="markdownIt-Anchor" href="#511-examples"></a> 5.1.1 Examples</h3>
<p><strong>Case 1:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span> V, <span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> E&amp; <span class="title">get_back_1</span><span class="params">(<span class="type">const</span> V&lt;E&gt;&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="keyword">typename</span> T::value_type&amp; <span class="title">get_back_2</span><span class="params">(<span class="type">const</span> T&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> I&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">get</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c[I];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">get_back_1</span>(v) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">get_back_2</span>(v) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(v) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Case 2:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>&gt; <span class="keyword">typename</span> V, <span class="keyword">typename</span> T, <span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_last_value</span><span class="params">(V&lt;T, A&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> T&amp; value = v.<span class="built_in">back</span>();</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">typename</span> V, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_type</span><span class="params">(<span class="type">const</span> V&lt;T&gt;&amp; value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;V&lt;T&gt;&#x27;s type=&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(V&lt;T&gt;).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;T&#x27;s type=&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">print_last_value</span>(v);</span><br><span class="line">    <span class="built_in">print_type</span>(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="52-template-parameter"><a class="markdownIt-Anchor" href="#52-template-parameter"></a> 5.2 Template parameter</h2>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/template_parameters">Template parameters and template arguments</a></p>
<p>Every template is parameterized by one or more template parameters, indicated in the parameter-list of the template declaration syntax:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; parameter-list &gt; declaration</span><br></pre></td></tr></table></figure>
<p>Each parameter in parameter-list may be:</p>
<ul>
<li><strong>a non-type template parameter;</strong></li>
<li><strong>a type template parameter;</strong></li>
<li><strong>a template template parameter.</strong></li>
</ul>
<h2 id="53-template-argument"><a class="markdownIt-Anchor" href="#53-template-argument"></a> 5.3 Template argument</h2>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/template_parameters">Template parameters and template arguments</a></p>
<p>In order for a template to be instantiated, every template parameter (type, non-type, or template) must be replaced by a corresponding template argument. For class templates, the arguments are either explicitly provided, deduced from the initializer, (since C++17) or defaulted. For function templates, the arguments are explicitly provided, deduced from the context, or defaulted.</p>
<p>Each argument may be:</p>
<ul>
<li><strong>a template non-type argument;</strong></li>
<li><strong>a template type argument;</strong></li>
<li><strong>a template template argument.</strong></li>
</ul>
<h2 id="54-parameter-pack"><a class="markdownIt-Anchor" href="#54-parameter-pack"></a> 5.4 Parameter pack</h2>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/parameter_pack">Parameter pack</a></p>
<p>A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A function parameter pack is a function parameter that accepts zero or more function arguments.</p>
<p>A template with at least one parameter pack is called a variadic template.</p>
<h3 id="541-fold-expressions"><a class="markdownIt-Anchor" href="#541-fold-expressions"></a> 5.4.1 Fold Expressions</h3>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/fold">Fold expressions</a></p>
<p>Reduces (folds) a parameter pack over a binary operator.</p>
<p><strong>Syntax:</strong></p>
<ul>
<li>Unary right fold: <code>( pack op ... )</code></li>
<li>Unary left fold: <code>( ... op pack )</code></li>
<li>Binary right fold: <code>( pack op ... op init )</code></li>
<li>Binary left fold: <code>( init op ... op pack )</code></li>
<li><code>op</code>: any of the following 32 binary operators: <code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> <code>^</code> <code>&amp;</code> <code>|</code> <code>=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>^=</code> <code>&amp;=</code> <code>|=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>==</code> <code>!=</code> <code>&lt;=</code> <code>&gt;=</code> <code>&amp;&amp;</code> <code>||</code> <code>,</code> <code>.*</code> <code>-&gt;*</code>. In a binary fold, both ops must be the same.</li>
<li><code>pack</code>: an expression that contains an unexpanded parameter pack and does not contain an operator with precedence lower than cast at the top level (formally, a cast-expression)</li>
<li><code>init</code>: an expression that does not contain an unexpanded parameter pack and does not contain an operator with precedence lower than cast at the top level (formally, a cast-expression)<br />
Note that the opening and closing parentheses are a required part of the fold expression.</li>
</ul>
<p><strong>Case 1:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check_type</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>((std::is_same_v&lt;T, Args&gt; || ...), <span class="string">&quot;check failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check_type</span>&lt;<span class="type">int32_t</span>, <span class="type">int32_t</span>, <span class="type">int64_t</span>&gt;();</span><br><span class="line">    <span class="comment">// check_type&lt;int32_t, int8_t, int16_t&gt;();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Case 2:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_contents</span><span class="params">(<span class="type">const</span> std::string&amp; path, Args&amp;... args)</span> </span>&#123;</span><br><span class="line">    std::ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(path);</span><br><span class="line">    (ifs &gt;&gt; ... &gt;&gt; args);</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>);</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;1 2.3 5&quot;</span>;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    <span class="type">double</span> second;</span><br><span class="line">    <span class="type">int</span> third;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read_contents</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>, first, second, third);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; second &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; third &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="542-traverse-parameter-pack"><a class="markdownIt-Anchor" href="#542-traverse-parameter-pack"></a> 5.4.2 Traverse Parameter Pack</h3>
<h4 id="5421-parenthesis-initializer"><a class="markdownIt-Anchor" href="#5421-parenthesis-initializer"></a> 5.4.2.1 Parenthesis Initializer</h4>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operator_other#Built-in_comma_operator">Built-in comma operator</a>: In a comma expression <code>E1, E2</code>, the expression <code>E1</code> is evaluated, its result is discarded (although if it has class type, it won’t be destroyed until the end of the containing full expression), and its side effects are completed before evaluation of the expression <code>E2</code> begins (note that a user-defined operator, cannot guarantee sequencing)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> m = (++n, std::cout &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>, ++n, <span class="number">2</span> * n); <span class="comment">// print 2, n=3, m=6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;m = &quot;</span> &lt;&lt; (++m, m) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;                     <span class="comment">// print 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Values&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">read_contents</span><span class="params">(<span class="type">const</span> std::string&amp; path, Values&amp;... values)</span> </span>&#123;</span><br><span class="line">    std::ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> ok = ifs.<span class="built_in">good</span>();</span><br><span class="line">    <span class="keyword">auto</span> read_content = [&amp;ifs, &amp;ok](<span class="keyword">auto</span>&amp; value) &#123;</span><br><span class="line">        ok &amp;= ifs.<span class="built_in">good</span>();</span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ifs &gt;&gt; value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Either of the following two methods will work</span></span><br><span class="line">    <span class="comment">// ((read_content(values), ...));</span></span><br><span class="line">    [[maybe_unused]] <span class="type">int32_t</span> _[] = &#123;(<span class="built_in">read_content</span>(values), <span class="number">0</span>)...&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        ifs.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>);</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;1 2.3 5&quot;</span>;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> first = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">double</span> second = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> third = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">double</span> forth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_good: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">read_contents</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>, first, second, third)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, first: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, second: &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, third: &quot;</span> &lt;&lt; third &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    first = second = third = forth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_good: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">read_contents</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>, first, second, third, forth)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, first: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, second: &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, third: &quot;</span> &lt;&lt; third &lt;&lt; <span class="string">&quot;, forth=&quot;</span> &lt;&lt; forth</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    first = second = third = forth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_good: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">read_contents</span>(<span class="string">&quot;/tmp/test_wrong.txt&quot;</span>, first, second, third, forth)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, first: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, second: &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, third: &quot;</span> &lt;&lt; third &lt;&lt; <span class="string">&quot;, forth=&quot;</span> &lt;&lt; forth</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5422-constexpr-for"><a class="markdownIt-Anchor" href="#5422-constexpr-for"></a> 5.4.2.2 constexpr for</h4>
<p>有时候，无法通过折叠表达式处理一些复杂的场景，我们希望能通过循环来挨个处理形参，示例如下（参考<a target="_blank" rel="noopener" href="https://artificial-mind.net/blog/2020/10/31/constexpr-for">Approximating ‘constexpr for’</a>）：</p>
<ul>
<li>由于需要在函数内用迭代变量进行形参包的提取，因此这个变量必须是编译期的常量，这里用<code>std::integral_constant</code>进行转换，这样在函数内，就可以用<code>std::get&lt;i&gt;</code>来提取第<code>i</code>个参数了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> Start, <span class="keyword">auto</span> End, <span class="keyword">auto</span> Inc, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">constexpr_for</span><span class="params">(F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(Start &lt; End)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">f</span>(std::<span class="built_in">integral_constant</span>&lt;<span class="keyword">decltype</span>(Start), Start&gt;());</span><br><span class="line">        <span class="built_in">constexpr_for</span>&lt;Start + Inc, End, Inc&gt;(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Values&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">read_contents</span><span class="params">(<span class="type">const</span> std::string&amp; path, Values&amp;... values)</span> </span>&#123;</span><br><span class="line">    std::ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> tvalues = std::forward_as_tuple(values...);</span><br><span class="line">    <span class="type">bool</span> ok = ifs.<span class="built_in">good</span>();</span><br><span class="line">    <span class="built_in">constexpr_for</span>&lt;<span class="number">0</span>, <span class="keyword">sizeof</span>...(values), <span class="number">1</span>&gt;([&amp;ifs, &amp;tvalues, &amp;ok](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">        ok &amp;= ifs.<span class="built_in">good</span>();</span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ifs &gt;&gt; std::<span class="built_in">get</span>&lt;i&gt;(tvalues);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        ifs.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>);</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;1 2.3 5&quot;</span>;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> first = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">double</span> second = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> third = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">double</span> forth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_good: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">read_contents</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>, first, second, third)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, first: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, second: &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, third: &quot;</span> &lt;&lt; third &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    first = second = third = forth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_good: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">read_contents</span>(<span class="string">&quot;/tmp/test.txt&quot;</span>, first, second, third, forth)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, first: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, second: &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, third: &quot;</span> &lt;&lt; third &lt;&lt; <span class="string">&quot;, forth=&quot;</span> &lt;&lt; forth</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    first = second = third = forth = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is_good: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">read_contents</span>(<span class="string">&quot;/tmp/test_wrong.txt&quot;</span>, first, second, third, forth)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, first: &quot;</span> &lt;&lt; first &lt;&lt; <span class="string">&quot;, second: &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, third: &quot;</span> &lt;&lt; third &lt;&lt; <span class="string">&quot;, forth=&quot;</span> &lt;&lt; forth</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="55-template-specialization"><a class="markdownIt-Anchor" href="#55-template-specialization"></a> 5.5 template specialization</h2>
<h3 id="551-explicit-full-template-specialization"><a class="markdownIt-Anchor" href="#551-explicit-full-template-specialization"></a> 5.5.1 Explicit (full) template specialization</h3>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/template_specialization">Explicit (full) template specialization</a> Allows customizing the template code for a given set of template arguments.</p>
<h3 id="552-partial-template-specialization"><a class="markdownIt-Anchor" href="#552-partial-template-specialization"></a> 5.5.2 Partial template specialization</h3>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/partial_specialization">Partial template specialization</a> Allows customizing class and variable(since C++14) templates for a given category of template arguments.</p>
<ul>
<li>template function don’t support partial template specialization.</li>
</ul>
<p><strong>The requirements of argument list:</strong></p>
<ul>
<li>
<p>The argument list cannot be identical to the non-specialized argument list (it must specialize something).</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>, <span class="type">int</span> I&gt; <span class="keyword">class</span> <span class="title class_">B</span> &#123;&#125;;        <span class="comment">// primary template</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">X</span>, <span class="keyword">class</span> <span class="title class_">Y</span>, <span class="type">int</span> N&gt; <span class="keyword">class</span> <span class="title class_">B</span>&lt;X, Y, N&gt; &#123;&#125;; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Default arguments cannot appear in the argument list.</p>
</li>
<li>
<p>If any argument is a pack expansion, it must be the last argument in the list.</p>
</li>
<li>
<p>…</p>
</li>
</ul>
<h4 id="5521-members-of-partial-specializations"><a class="markdownIt-Anchor" href="#5521-members-of-partial-specializations"></a> 5.5.2.1 Members of partial specializations</h4>
<p>The template parameter list and the template argument list of a member of a partial specialization must match the parameter list and the argument list of the partial specialization.</p>
<p>Just like with members of primary templates, they only need to be defined if used in the program.</p>
<p>Members of partial specializations are not related to the members of the primary template.</p>
<p>Explicit (full) specialization of a member of a partial specialization is declared the same way as an explicit specialization of the primary template.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> I&gt; <span class="comment">// primary template</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// member declaration</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> I&gt;</span><br><span class="line"><span class="type">void</span> A&lt;T, I&gt;::<span class="built_in">f</span>() &#123;&#125; <span class="comment">// primary template member definition</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// partial specialization</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&lt;T, <span class="number">2</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member of partial specialization</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> A&lt;T, <span class="number">2</span>&gt;::<span class="built_in">g</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// explicit (full) specialization</span></span><br><span class="line"><span class="comment">// of a member of partial specialization</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> A&lt;<span class="type">char</span>, <span class="number">2</span>&gt;::<span class="built_in">h</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A&lt;<span class="type">char</span>, <span class="number">0</span>&gt; a0;</span><br><span class="line">    A&lt;<span class="type">char</span>, <span class="number">2</span>&gt; a2;</span><br><span class="line">    a0.<span class="built_in">f</span>(); <span class="comment">// OK, uses primary template&#x27;s member definition</span></span><br><span class="line">    a2.<span class="built_in">g</span>(); <span class="comment">// OK, uses partial specialization&#x27;s member definition</span></span><br><span class="line">    a2.<span class="built_in">h</span>(); <span class="comment">// OK, uses fully-specialized definition of</span></span><br><span class="line">            <span class="comment">// the member of a partial specialization</span></span><br><span class="line">    a2.<span class="built_in">f</span>(); <span class="comment">// error: no definition of f() in the partial</span></span><br><span class="line">            <span class="comment">// specialization A&lt;T,2&gt; (the primary template is not used)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5522-how-to-use-stdenable_if-in-partial-specialization"><a class="markdownIt-Anchor" href="#5522-how-to-use-stdenable_if-in-partial-specialization"></a> 5.5.2.2 How to use std::enable_if in partial specialization</h4>
<p><strong>Wrong way:</strong></p>
<ul>
<li>Default arguments cannot appear in the argument list.</li>
<li>Didn’t specialize anything.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = std::<span class="type">enable_if_t</span>&lt;std::is_integral_v&lt;T&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> Foo&lt;T&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Right way:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> E = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> Bar &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bar</span>&lt;T, std::<span class="type">enable_if_t</span>&lt;std::is_integral_v&lt;T&gt;&gt;&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="56-when-template-parameters-cannot-be-deduced"><a class="markdownIt-Anchor" href="#56-when-template-parameters-cannot-be-deduced"></a> 5.6 When template parameters cannot be deduced</h2>
<p>In C++ template programming, when a template parameter appears on the left side of <code>::</code>, it typically cannot be deduced. This is because the left side of <code>::</code> often represents a <code>dependent type</code>, which the compiler cannot resolve during template argument deduction.</p>
<p><strong>Case 1:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> T::type &amp;obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Long</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">long</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>); <span class="comment">// compile error</span></span><br><span class="line">    <span class="built_in">func</span>&lt;Int&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">func</span>&lt;Long&gt;(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Case 2:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&lt;std::vector&lt;T&gt;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This one cannot be deduced</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&lt;std::vector&lt;T&gt;::value_type&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This one cannot be deduced</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>&lt;std::<span class="type">conditional_t</span>&lt;std::is_integral_v&lt;T&gt;, <span class="type">int</span>, <span class="type">double</span>&gt;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T can be directly deduced from template parameter `std::vector&lt;T&gt;`</span></span><br><span class="line"><span class="comment">// so the dependent type `std::vector&lt;T&gt;::value_type` can be also deduced</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&lt;std::vector&lt;T&gt;, <span class="keyword">typename</span> std::vector&lt;T&gt;::value_type&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T can be directly deduced from template parameter `std::vector&lt;T&gt;`</span></span><br><span class="line"><span class="comment">// so the dependent type `std::conditional_t` and `std::is_integral_v` can be also deduced</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&lt;std::vector&lt;T&gt;, std::<span class="type">conditional_t</span>&lt;std::is_integral_v&lt;T&gt;, <span class="type">int</span>, <span class="type">double</span>&gt;&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="57-using-typename-to-disambiguate"><a class="markdownIt-Anchor" href="#57-using-typename-to-disambiguate"></a> 5.7 Using typename to Disambiguate</h2>
<p><strong>Under what circumstances would ambiguity arise? For example, <code>foo* ptr;</code></strong></p>
<ul>
<li>If <code>foo</code> is a type, then this statement is a declaration, i.e., it defines a variable of type <code>foo*</code>.</li>
<li>If <code>foo</code> is a variable, then this statement is an expression, i.e., it performs the <code>*</code> operation on <code>foo</code> and <code>ptr</code>.</li>
<li>The compiler cannot distinguish which of the above two cases it is. Therefore, you can explicitly use <code>typename</code> to inform the compiler that <code>foo</code> is a type.</li>
</ul>
<p><strong>For templates, such as <code>T::value_type</code>, the compiler similarly cannot determine whether <code>T::value_type</code> is a type or not. This is because the class scope resolution operator <code>::</code> can access both type members and static members. By default, the compiler assumes that something in the form of <code>T::value_type</code> is not a type.</strong></p>
<p><strong>Case 1:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The following will fail to compile:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T::value_type <span class="title">sum</span><span class="params">(<span class="type">const</span> T &amp;container)</span> </span>&#123;</span><br><span class="line">    T::value_type res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;item: container) &#123;</span><br><span class="line">        res += item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>After refined:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">sum</span><span class="params">(<span class="type">const</span> T &amp;container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::value_type res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;item: container) &#123;</span><br><span class="line">        res += item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="58-using-template-to-disambiguate"><a class="markdownIt-Anchor" href="#58-using-template-to-disambiguate"></a> 5.8 Using template to Disambiguate</h2>
<p><strong>Under what circumstances would ambiguity arise? For example, <code>container.emplace&lt;int&gt;(1);</code></strong></p>
<ul>
<li>If <code>container.emplace</code> is a member variable, then <code>&lt;</code> can be interpreted as a less-than symbol.</li>
<li>If <code>container.emplace</code> is a template, then <code>&lt;</code> can be interpreted as the brackets for template parameters.</li>
</ul>
<p><strong>Case 1:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">emplace</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;emplace value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The following will fail to compile:</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T &amp;container)</span> </span>&#123;</span><br><span class="line">    container.<span class="built_in">emplace</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>After refined:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T &amp;container)</span> </span>&#123;</span><br><span class="line">    container.<span class="keyword">template</span> <span class="built_in">emplace</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Case 2:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line">    <span class="keyword">using</span> container = std::vector&lt;C&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T::container&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>After refined:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line">    <span class="keyword">using</span> container = std::vector&lt;C&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::<span class="keyword">template</span> container&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="59-defining-a-type-alias-in-a-template-parameter-list"><a class="markdownIt-Anchor" href="#59-defining-a-type-alias-in-a-template-parameter-list"></a> 5.9 Defining a type alias in a template parameter list</h2>
<p>语法上，我们是无法在template的参数列表中定义别名的（无法使用<code>using</code>）。但是我们可以通过定义有默认值的类型形参来实现类似类型别名的功能，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> HashMap, <span class="keyword">typename</span> KeyType = <span class="keyword">typename</span> HashMap::key_type,</span><br><span class="line">          <span class="keyword">typename</span> ValueType = <span class="keyword">typename</span> HashMap::mapped_type&gt;</span><br><span class="line">ValueType&amp; <span class="built_in">get</span>(HashMap&amp; map, <span class="type">const</span> KeyType&amp; key) &#123;</span><br><span class="line">    <span class="keyword">return</span> map[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="510-accessing-members-of-a-template-parent-class-from-a-non-template-derived-class"><a class="markdownIt-Anchor" href="#510-accessing-members-of-a-template-parent-class-from-a-non-template-derived-class"></a> 5.10 Accessing members of a template parent class from a non-template derived class</h2>
<ul>
<li>Approach 1: <code>MemberName</code></li>
<li>Approach 2: <code>this-&gt;MemberName</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derive</span> : Base&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_data_1</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; other)</span> </span>&#123; data = other; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_data_2</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; other)</span> </span>&#123; <span class="keyword">this</span>-&gt;data = other; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive t;</span><br><span class="line">    t.<span class="built_in">set_data_1</span>(<span class="number">1</span>);</span><br><span class="line">    t.<span class="built_in">set_data_2</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="511-accessing-members-of-a-template-parent-class-from-a-template-derived-class"><a class="markdownIt-Anchor" href="#511-accessing-members-of-a-template-parent-class-from-a-template-derived-class"></a> 5.11 Accessing members of a template parent class from a template derived class</h2>
<ul>
<li>Approach 1: <code>ParentClass&lt;Template Args...&gt;::MemberName</code></li>
<li>Approach 2: <code>this-&gt;MemberName</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derive</span> : Base&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_data_1</span><span class="params">(<span class="type">const</span> T&amp; data)</span> </span>&#123; Base&lt;T&gt;::data = data; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_data_2</span><span class="params">(<span class="type">const</span> T&amp; data)</span> </span>&#123; <span class="keyword">this</span>-&gt;data = data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    t.<span class="built_in">set_data_1</span>(<span class="number">5</span>);</span><br><span class="line">    t.<span class="built_in">set_data_2</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="512-separating-the-definition-and-implementation-of-a-template"><a class="markdownIt-Anchor" href="#512-separating-the-definition-and-implementation-of-a-template"></a> 5.12 Separating the definition and implementation of a template</h2>
<p>We can place the declaration and definition of a template in two separate files, which makes the code structure clearer. For example, suppose there are two files <code>test.h</code> and <code>test.tpp</code>, with the following contents:</p>
<ul>
<li>
<p><code>test.h</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.tpp&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>test.tpp</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Demo&lt;T&gt;::<span class="built_in">func</span>() &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>As we can see, <code>test.h</code> references <code>test.tpp</code> at the end, so other modules only need to include <code>test.h</code>. The entire template definition can also be clearly viewed through a single file, <code>test.h</code>. However, there is an issue here: if we use <code>vscode</code> or the <code>lsp</code> plugin in <code>vim</code> to read or edit the <code>test.tpp</code> file, we may encounter syntax problems because <code>test.tpp</code> itself is incomplete and cannot be compiled.</p>
<p>Referring to <a target="_blank" rel="noopener" href="https://github.com/StarRocks/starrocks/pull/15330">[BugFix] Fix the problem of null aware anti join</a>, we can resolve this issue with a small trick by modifying <code>test.h</code> and <code>test.tpp</code> as follows:</p>
<ul>
<li>
<p><code>test.h</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEST_TPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.tpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> TEST_H</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>test.tpp</code></p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_TPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Demo&lt;T&gt;::<span class="built_in">func</span>() &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> TEST_TPP</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>In this way, when editing these two files independently, <code>lsp</code> can work normally without causing circular reference issues.</p>
<p>When there is no <code>compile_commands.json</code> file, <code>clangd</code> will report an error when processing a standalone <code>tpp</code> file. The error message is: <code>Unable to handle compilation, expected exactly one compiler job in ''</code>.</p>
<h3 id="5121-hide-template-implementation"><a class="markdownIt-Anchor" href="#5121-hide-template-implementation"></a> 5.12.1 Hide template implementation</h3>
<p>We can even hide the specific implementation of the template, but in this case, all required types must be explicitly instantiated in the defining <code>.cpp</code> file. This is because the implementation of the template is not visible to other <code>.cpp</code> files and can only resolve the corresponding symbols during linking.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; template.h &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#pragma once</span></span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">    void func();</span><br><span class="line">&#125;;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; template.cpp &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment">#include &quot;template.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Foo&lt;T&gt;::<span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Foo::func&#x27;s default implementation&quot;</span> &lt;&lt; <span class="string">std::endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">template &lt;&gt;</span></span><br><span class="line"><span class="string">void Foo&lt;double&gt;::func() &#123;</span></span><br><span class="line"><span class="string">    std</span>::cout &lt;&lt; <span class="string">&quot;Foo::func&#x27;s special implementation for double&quot;</span> &lt;&lt; <span class="string">std::endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">template class Foo&lt;int&gt;;</span></span><br><span class="line"><span class="string">template class Foo&lt;double&gt;;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cat &gt; main.cpp &lt;&lt; &#x27;EOF&#x27;</span></span><br><span class="line"><span class="string">#include &quot;template.h&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main() &#123;</span></span><br><span class="line"><span class="string">    Foo&lt;int&gt;().func();</span></span><br><span class="line"><span class="string">    Foo&lt;double&gt;().func();</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">gcc -o main main.cpp template.cpp -lstdc++ -std</span>=gnu++17 -O3</span><br></pre></td></tr></table></figure>
<h2 id="513-crtp"><a class="markdownIt-Anchor" href="#513-crtp"></a> 5.13 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a></h2>
<p><code>CRTP</code>的全称是<code>Curious Recurring Template Pattern</code></p>
<h3 id="5131-static-polymorphism"><a class="markdownIt-Anchor" href="#5131-static-polymorphism"></a> 5.13.1 Static Polymorphism</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">interface</span><span class="params">()</span> </span>&#123; <span class="built_in">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">implementation</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_func</span><span class="params">()</span> </span>&#123; T::<span class="built_in">static_sub_func</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base&lt;Derived&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">implementation</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived::implementation&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_sub_func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Dericed::static_sub_func&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">interface</span>();</span><br><span class="line">    Derived::<span class="built_in">static_func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5132-object-counter"><a class="markdownIt-Anchor" href="#5132-object-counter"></a> 5.13.2 Object Counter</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">counter</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> objects_created = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> objects_alive = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">counter</span>() &#123;</span><br><span class="line">        ++objects_created;</span><br><span class="line">        ++objects_alive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">counter</span>(<span class="type">const</span> counter&amp;) &#123;</span><br><span class="line">        ++objects_created;</span><br><span class="line">        ++objects_alive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ~<span class="built_in">counter</span>() <span class="comment">// objects should never be removed through pointers of this type</span></span><br><span class="line">    &#123;</span><br><span class="line">        --objects_alive;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> : <span class="keyword">public</span> counter&lt;X&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(expr) std::cout &lt;&lt; #expr &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; expr &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        X x;</span><br><span class="line">        <span class="built_in">PRINT</span>(X::objects_created);</span><br><span class="line">        <span class="built_in">PRINT</span>(X::objects_alive);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PRINT</span>(X::objects_created);</span><br><span class="line">    <span class="built_in">PRINT</span>(X::objects_alive);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5133-polymorphic-chaining"><a class="markdownIt-Anchor" href="#5133-polymorphic-chaining"></a> 5.13.3 Polymorphic Chaining</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; red, green, yello, blue, white, black &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlainPrinter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PlainPrinter</span>(std::ostream&amp; pstream) : <span class="built_in">m_stream</span>(pstream) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">PlainPrinter&amp; <span class="title">print</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">        m_stream &lt;&lt; t;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">PlainPrinter&amp; <span class="title">println</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">        m_stream &lt;&lt; t &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::ostream&amp; m_stream;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlainCoutPrinter</span> : <span class="keyword">public</span> PlainPrinter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PlainCoutPrinter</span>() : <span class="built_in">PlainPrinter</span>(std::cout) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">PlainCoutPrinter&amp; <span class="title">SetConsoleColor</span><span class="params">(Color c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something to change color</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ConcretePrinter&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Printer</span>(std::ostream&amp; pstream) : <span class="built_in">m_stream</span>(pstream) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">ConcretePrinter&amp; <span class="title">print</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">        m_stream &lt;&lt; t;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ConcretePrinter&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">ConcretePrinter&amp; <span class="title">println</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">        m_stream &lt;&lt; t &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ConcretePrinter&amp;&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::ostream&amp; m_stream;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoutPrinter</span> : <span class="keyword">public</span> Printer&lt;CoutPrinter&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CoutPrinter</span>() : <span class="built_in">Printer</span>(std::cout) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">CoutPrinter&amp; <span class="title">SetConsoleColor</span><span class="params">(Color c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// PlainCoutPrinter().print(&quot;Hello &quot;).SetConsoleColor(Color::red).println(&quot;Printer!&quot;); // compile error</span></span><br><span class="line">    <span class="built_in">CoutPrinter</span>().<span class="built_in">print</span>(<span class="string">&quot;Hello &quot;</span>).<span class="built_in">SetConsoleColor</span>(Color::red).<span class="built_in">println</span>(<span class="string">&quot;Printer!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>PlainCoutPrinter().print(&quot;Hello &quot;)</code>的返回类型是<code>PlainPrinter</code>，丢失了具体的<code>PlainCoutPrinter</code>类型信息，于是再调用<code>SetConsoleColor</code>就报错了</li>
<li>而使用<code>CRTP</code>就可以避免这个问题，基类的方法返回类型永远是具体的子类</li>
</ul>
<h3 id="5134-polymorphic-copy-construction"><a class="markdownIt-Anchor" href="#5134-polymorphic-copy-construction"></a> 5.13.4 Polymorphic Copy Construction</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Base class has a pure virtual function for cloning</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractShape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractShape</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;AbstractShape&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This CRTP class implements clone() for Derived</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> : <span class="keyword">public</span> AbstractShape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::unique_ptr&lt;AbstractShape&gt; <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;Derived&gt;(<span class="built_in">static_cast</span>&lt;Derived <span class="type">const</span>&amp;&gt;(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// We make clear Shape class needs to be inherited</span></span><br><span class="line">    <span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">const</span> Shape&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Shape</span>(Shape&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Every derived class inherits from CRTP class instead of abstract class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shape&lt;Square&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape&lt;Circle&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Square s;</span><br><span class="line">    <span class="keyword">auto</span> clone = s.<span class="built_in">clone</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="514-pimpl"><a class="markdownIt-Anchor" href="#514-pimpl"></a> 5.14 PIMPL</h2>
<p>In C++, the term <code>pimpl</code> is short for <code>pointer to implementation</code> or <code>private implementation</code>. It’s an idiom used to separate the public interface of a class from its implementation details. This helps improve code modularity, encapsulation, and reduces compile-time dependencies.</p>
<p>Here’s how the pimpl idiom works:</p>
<ol>
<li><strong>Public Interface</strong>: You define a class in your header file (<code>.h</code> or <code>.hpp</code>) that contains only the public interface members (public functions, typedefs, etc.). This header file should include minimal implementation details to keep the interface clean and focused.</li>
<li><strong>Private Implementation</strong>: In the implementation file (<code>.cpp</code>), you declare a private class that holds the actual implementation details of your class. This private class is typically defined within an anonymous namespace or as a private nested class of the original class. The private class contains private data members, private functions, and any other implementation-specific details.</li>
<li><strong>Pointer to Implementation</strong>: Within the main class, you include a pointer to the private implementation class. The public functions in the main class forward calls to the corresponding functions in the private implementation class.</li>
</ol>
<p>By using the pimpl idiom, you achieve several benefits:</p>
<ul>
<li>Reduces compile-time dependencies: Changes to the private implementation do not require recompilation of the public interface, reducing compilation times.</li>
<li>Enhances encapsulation: Clients of the class only need to know about the public interface, shielding them from implementation details.</li>
<li>Minimizes header dependencies: Since the private implementation is not exposed in the header, you avoid leaking implementation details to client code.</li>
<li>Eases binary compatibility: Changing the private implementation does not require recompiling or re-linking client code, as long as the public interface remains unchanged.</li>
</ul>
<p>Here’s a simplified example of the pimpl idiom:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Widget.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Impl</span>; <span class="comment">// Forward declaration of the private implementation class</span></span><br><span class="line">    Impl* pImpl; <span class="comment">// Pointer to the private implementation</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Widget.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>::Impl &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PerformAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implementation details</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>() : <span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">Impl</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> pImpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::DoSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pImpl-&gt;<span class="built_in">PerformAction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-memory-model"><a class="markdownIt-Anchor" href="#6-memory-model"></a> 6 Memory Model</h1>
<h2 id="61-concepts"><a class="markdownIt-Anchor" href="#61-concepts"></a> 6.1 Concepts</h2>
<h3 id="611-cache-coherence-memory-consistency"><a class="markdownIt-Anchor" href="#611-cache-coherence-memory-consistency"></a> 6.1.1 Cache coherence &amp; Memory consistency</h3>
<p>Cache coherence and memory consistency are two fundamental concepts in parallel computing systems, but they address different issues:</p>
<p><strong>Cache Coherence</strong>:</p>
<ul>
<li><strong>This concept is primarily concerned with the values of copies of a single memory location that are cached at several caches (typically, in a multiprocessor system)</strong>. When multiple processors with separate caches are in a system, it’s possible for those caches to hold copies of the same memory location. <strong>Cache coherence ensures that all processors in the system observe a single, consistent value for the memory location</strong>. It focuses on maintaining a global order in which writes to each individual memory location occur.</li>
<li>For example, suppose we have two processors P1 and P2, each with its own cache. If P1 changes the value of a memory location X that’s also stored in P2’s cache, the cache coherence protocols will ensure that P2 sees the updated value if it tries to read X.</li>
</ul>
<p><strong>Memory Consistency</strong>:</p>
<ul>
<li>While cache coherence is concerned with the view of a single memory location, <strong>memory consistency is concerned about the ordering of multiply updates to different memory locations(or single memory location) from different processors. It determines when a write by one processor to a shared memory location becomes visible to all other processors.</strong></li>
<li>A memory consistency model defines the architecturally visible behavior of a memory system. Different consistency models make different guarantees about the order and visibility of memory operations across different threads or processors. For example, sequential consistency, a strict type of memory consistency model, says that all memory operations must appear to execute in some sequential order that’s consistent with the program order of each individual processor.</li>
</ul>
<p>In summary, while both are essential for correctness in multiprocessor systems, cache coherence deals with maintaining a consistent view of a single memory location, while memory consistency is concerned with the order and visibility of updates to different memory locations.</p>
<h3 id="612-happens-before"><a class="markdownIt-Anchor" href="#612-happens-before"></a> 6.1.2 Happens-before</h3>
<p>If an operation A “happens-before” another operation B, it means that A is guaranteed to be observed by B. In other words, any data or side effects produced by A will be visible to B when it executes.</p>
<p><img src="/images/Cpp-Language/happens-before.png" alt="happens-before" /></p>
<h2 id="62-memory-consistency-model"><a class="markdownIt-Anchor" href="#62-memory-consistency-model"></a> 6.2 Memory consistency model</h2>
<h3 id="621-sequential-consistency-model"><a class="markdownIt-Anchor" href="#621-sequential-consistency-model"></a> 6.2.1 Sequential consistency model</h3>
<blockquote>
<p>the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program</p>
</blockquote>
<p><strong><code>Sequential consistency model (SC)</code></strong>, also known as the sequential consistency model, essentially stipulates two things:</p>
<ol>
<li><strong>Each thread’s instructions are executed in the order specified by the program (from the perspective of a single thread)</strong></li>
<li><strong>The interleaving order of thread execution can be arbitrary, but the overall execution order of the entire program, as observed by all threads, must be the same (from the perspective of the entire program)</strong>
<ul>
<li>That is, there should not be a situation where for write operations <code>W1</code> and <code>W2</code>, processor 1 sees the order as: <code>W1 -&gt; W2</code>; while processor 2 sees the order as: <code>W2 -&gt; W1</code></li>
</ul>
</li>
</ol>
<h3 id="622-relaxed-consistency-model"><a class="markdownIt-Anchor" href="#622-relaxed-consistency-model"></a> 6.2.2 Relaxed consistency model</h3>
<p><strong><code>Relaxed consistency model</code> also known as the loose memory consistency model, is characterized by:</strong></p>
<ol>
<li><strong>Within the same thread, access to the same atomic variable cannot be reordered (from the perspective of a single thread)</strong></li>
<li><strong>Apart from ensuring the atomicity of operations, there is no stipulation on the order of preceding and subsequent instructions, and the order in which other threads observe data changes may also be different (from the perspective of the entire program)</strong>
<ul>
<li>That is, different threads may observe the relaxed operations on a single atomic value in different orders.</li>
</ul>
</li>
</ol>
<p><strong>Looseness can be measured along the following two dimensions:</strong></p>
<ul>
<li>How to relax the requirements of program order. Typically, this refers to the read and write operations of different variables; for the same variable, read and write operations cannot be reordered. Program order requirements include:
<ul>
<li><code>read-read</code></li>
<li><code>read-write</code></li>
<li><code>write-read</code></li>
<li><code>write-write</code></li>
</ul>
</li>
<li>How they relax the requirements for write atomicity. Models are differentiated based on whether they allow a read operation to return the written value of another processor before all cache copies have received the invalidation or update message produced by the write; in other words, allowing a processor to read the written value before the write is visible to all other processors.</li>
</ul>
<p><strong>Through these two dimensions, the following relaxed strategies have been introduced:</strong></p>
<ul>
<li>Relaxing the <code>write-read</code> program order. Supported by <code>TSO</code> (Total Store Order)</li>
<li>Relaxing the <code>write-write</code> program order</li>
<li>Relaxing the <code>read-read</code> and <code>read-write</code> program order</li>
<li>Allowing early reads of values written by other processors</li>
<li>Allowing early reads of values written by the current processor</li>
</ul>
<h3 id="623-total-store-order"><a class="markdownIt-Anchor" href="#623-total-store-order"></a> 6.2.3 Total Store Order</h3>
<p>otal Store Order (TSO) is a type of memory consistency model used in computer architecture to manage how memory operations (reads and writes) are ordered and observed by different parts of the system.</p>
<p>In a Total Store Order model:</p>
<ul>
<li><strong>Writes are not immediately visible to all processors</strong>: When a processor writes to memory, that write is not instantly visible to all other processors. There’s a delay because writes are first written to a store buffer unique to each processor.</li>
<li><strong>Writes are seen in order</strong>: Even though there’s a delay in visibility, writes to the memory are seen by all processors in the same order. This is the “total order” part of TSO, which means that if Processor A sees Write X followed by Write Y, Processor B will also see Write X before Write Y.</li>
<li><strong>Reads may bypass writes</strong>: If a processor reads a location that it has just written to, it may get the value from its store buffer (the most recent write) rather than the value that is currently in memory. This means a processor can see its writes immediately but may not see writes from other processors that happened after its own write.</li>
<li><strong>Writes from a single processor are seen in the order issued</strong>: Writes by a single processor are observed in the order they were issued by that processor. If Processor A writes to memory location X and then to memory location Y, all processors will see the write to X happen before the write to Y.</li>
</ul>
<p>This model is a compromise between strict ordering and performance. In a system that enforces strict ordering (like Sequential Consistency), every operation appears to happen in a strict sequence, which can be quite slow. TSO allows some operations to be reordered (like reads happening before a write is visible to all) for better performance while still maintaining a predictable order for writes, which is critical for correctness in many concurrent algorithms.</p>
<p>TSO is commonly used in x86 processors, which strikes a balance between the predictable behavior needed for programming ease and the relaxed rules that allow for high performance in practice.</p>
<h2 id="63-stdmemory_order"><a class="markdownIt-Anchor" href="#63-stdmemory_order"></a> 6.3 std::memory_order</h2>
<ol>
<li><code>std::memory_order_seq_cst</code>: <strong>Provide happens-before relationship.</strong></li>
<li><code>std::memory_order_relaxed</code>: <strong>CAN NOT Provide happens-before relationship.</strong> Which specific relaxation strategies are adopted must be determined based on the hardware platform.
<ul>
<li>When you use <code>std::memory_order_relaxed</code>, it guarantees the following:
<ol>
<li>Sequential consistency for atomic operations on a single variable: If you perform multiple atomic operations on the same atomic variable using <code>std::memory_order_relaxed</code>, the result will be as if those operations were executed in some sequential order. This means that the final value observed by any thread will be a valid result based on the ordering of the operations.</li>
<li>Coherence: All threads will eventually observe the most recent value written to an atomic variable. However, the timing of when each thread observes the value may differ due to the relaxed ordering.</li>
<li>Atomicity: Atomic operations performed with <code>std::memory_order_relaxed</code> are indivisible. They are guaranteed to be performed without interruption or interference from other threads.</li>
</ol>
</li>
</ul>
</li>
<li><code>std::memory_order_acquire</code> and <code>std::memory_order_release</code>: <strong>Provide happens-before relationship.</strong>
<ul>
<li>When used together, <code>std::memory_order_acquire</code> and <code>std::memory_order_release</code> can establish a happens-before relationship between threads, allowing for proper synchronization and communication between them
<ol>
<li><code>std::memory_order_acquire</code> is a memory ordering constraint that provides acquire semantics. It ensures that any memory operations that occur before the acquire operation in the program order will be visible to the thread performing the acquire operation.</li>
<li><code>std::memory_order_release</code> is a memory ordering constraint that provides release semantics. It ensures that any memory operations that occur after the release operation in the program order will be visible to other threads that perform subsequent acquire operations.</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="64-cases"><a class="markdownIt-Anchor" href="#64-cases"></a> 6.4 Cases</h2>
<h3 id="641-case-1-happens-before"><a class="markdownIt-Anchor" href="#641-case-1-happens-before"></a> 6.4.1 Case-1-happens-before</h3>
<p>happens-before在不同<code>std::memory_order</code>下的规则</p>
<ul>
<li><code>std::memory_order_seq_cst</code>
<ul>
<li>normal-write happens-before atomic-write</li>
<li>atomic-read happens-before normal-read</li>
<li>atomic-write happens-before atomic-read</li>
<li>可以推导出：normal-write happens-before normal-read</li>
</ul>
</li>
<li><code>std::memory_order_relaxed</code>
<ul>
<li>normal-write happens-before atomic-write</li>
<li>atomic-read happens-before normal-read</li>
<li>无法推导出：normal-write happens-before normal-read</li>
</ul>
</li>
</ul>
<p>下面的程序：</p>
<ul>
<li><code>test_atomic_visibility&lt;std::memory_order_seq_cst&gt;();</code>可以正确执行</li>
<li><code>test_atomic_visibility&lt;std::memory_order_relaxed&gt;();</code>也可以正确执行。因为x86是<code>TSO</code>模型，<code>std::memory_order_relaxed</code>同样满足<code>atomic-write happens-before atomic-read</code>规则</li>
<li><code>test_volatile_visibility</code>会报错，因为<code>volatile</code>不提供同步语义，对重排没有限制</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> INVALID_VALUE = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> EXPECTED_VALUE = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> TIMES = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> data;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">atomic_data_ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="type">bool</span> <span class="title">volatile_data_ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order read_order, std::memory_order write_order&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_atomic_happens_before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> reader_thread = []() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="comment">// atomic read</span></span><br><span class="line">            <span class="keyword">while</span> (!atomic_data_ready.<span class="built_in">load</span>(read_order))</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// normal read: atomic read happens-before normal read</span></span><br><span class="line">            <span class="built_in">assert</span>(data == EXPECTED_VALUE);</span><br><span class="line"></span><br><span class="line">            data = INVALID_VALUE;</span><br><span class="line">            atomic_data_ready.<span class="built_in">store</span>(<span class="literal">false</span>, write_order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> writer_thread = []() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (atomic_data_ready.<span class="built_in">load</span>(read_order))</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// normal write</span></span><br><span class="line">            data = EXPECTED_VALUE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// atomic write: normal write happens-before atomic write</span></span><br><span class="line">            atomic_data_ready.<span class="built_in">store</span>(<span class="literal">true</span>, write_order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    data = INVALID_VALUE;</span><br><span class="line">    atomic_data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(reader_thread)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(writer_thread)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_volatile_happens_before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> reader_thread = []() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!volatile_data_ready)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">assert</span>(data == EXPECTED_VALUE);</span><br><span class="line"></span><br><span class="line">            data = INVALID_VALUE;</span><br><span class="line">            volatile_data_ready = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> writer_thread = []() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (volatile_data_ready)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            data = EXPECTED_VALUE;</span><br><span class="line"></span><br><span class="line">            volatile_data_ready = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    data = INVALID_VALUE;</span><br><span class="line">    volatile_data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(reader_thread)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(writer_thread)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_atomic_happens_before</span>&lt;std::memory_order_seq_cst, std::memory_order_seq_cst&gt;();</span><br><span class="line">    <span class="built_in">test_atomic_happens_before</span>&lt;std::memory_order_acquire, std::memory_order_release&gt;();</span><br><span class="line">    <span class="built_in">test_atomic_happens_before</span>&lt;std::memory_order_relaxed, std::memory_order_relaxed&gt;();</span><br><span class="line">    <span class="built_in">test_volatile_happens_before</span>(); <span class="comment">// Failed assertion</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="642-case-2-write-read-reorder"><a class="markdownIt-Anchor" href="#642-case-2-write-read-reorder"></a> 6.4.2 Case-2-write-read-reorder</h3>
<p>来自<a href="/resources/paper/Shared-Memory-Consistency-Models-A-Tutorial.pdf">Shared Memory Consistency Models: A Tutorial</a>中的<code>Figure-5(a)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> TIMES = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order read_order, std::memory_order write_order&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test_reorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// control vars</span></span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">control</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">stop</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">success</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; finished_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> round_process = [&amp;control, &amp;stop, &amp;finished_num](<span class="keyword">auto</span>&amp;&amp; process) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="comment">// make t1 and t2 go through synchronously</span></span><br><span class="line">            finished_num++;</span><br><span class="line">            <span class="keyword">while</span> (!stop &amp;&amp; !control)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">process</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait for next round</span></span><br><span class="line">            finished_num++;</span><br><span class="line">            <span class="keyword">while</span> (!stop &amp;&amp; control)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> control_process = [&amp;control, &amp;success, &amp;finished_num](<span class="keyword">auto</span>&amp;&amp; clean_process, <span class="keyword">auto</span>&amp;&amp; check_process) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="comment">// wait t1 and t2 at the top of the loop</span></span><br><span class="line">            <span class="keyword">while</span> (finished_num != <span class="number">2</span>)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// clean up data</span></span><br><span class="line">            finished_num = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">clean_process</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// let t1 and t2 go start</span></span><br><span class="line">            control = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait t1 and t2 finishing write operation</span></span><br><span class="line">            <span class="keyword">while</span> (finished_num != <span class="number">2</span>)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check assumption</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check_process</span>()) &#123;</span><br><span class="line">                success = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            finished_num = <span class="number">0</span>;</span><br><span class="line">            control = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main vars</span></span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; flag1, flag2;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; critical_num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> process_1 = [&amp;flag1, &amp;flag2, &amp;critical_num]() &#123;</span><br><span class="line">        flag1.<span class="built_in">store</span>(<span class="number">1</span>, write_order);</span><br><span class="line">        <span class="keyword">if</span> (flag2.<span class="built_in">load</span>(read_order) == <span class="number">0</span>) &#123;</span><br><span class="line">            critical_num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> process_2 = [&amp;flag1, &amp;flag2, &amp;critical_num]() &#123;</span><br><span class="line">        flag2.<span class="built_in">store</span>(<span class="number">1</span>, write_order);</span><br><span class="line">        <span class="keyword">if</span> (flag1.<span class="built_in">load</span>(read_order) == <span class="number">0</span>) &#123;</span><br><span class="line">            critical_num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> clean_process = [&amp;flag1, &amp;flag2, &amp;critical_num]() &#123;</span><br><span class="line">        flag1 = <span class="number">0</span>;</span><br><span class="line">        flag2 = <span class="number">0</span>;</span><br><span class="line">        critical_num = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> check_process = [&amp;critical_num]() &#123; <span class="keyword">return</span> critical_num &lt;= <span class="number">1</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t_1</span><span class="params">(round_process, process_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_2</span><span class="params">(round_process, process_2)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_control</span><span class="params">(control_process, clean_process, check_process)</span></span>;</span><br><span class="line"></span><br><span class="line">    t_control.<span class="built_in">join</span>();</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t_1.<span class="built_in">join</span>();</span><br><span class="line">    t_2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> res;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_seq_cst, std::memory_order_seq_cst&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_seq_cst, std::memory_order_seq_cst&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_acquire, std::memory_order_release&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_acquire, std::memory_order_release&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_relaxed, std::memory_order_relaxed&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_relaxed, std::memory_order_relaxed&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>x86</code>平台（<code>TSO</code>），结果如下，只有<code>memory_order_seq_cst</code>能保证一致性，而<code>memory_order_acquire/memory_order_release</code>仅针对同一变量，不同变量的<code>Write-Read</code>仍然可能重排</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test std::memory_order_seq_cst, std::memory_order_seq_cst, res=true</span><br><span class="line">test std::memory_order_acquire, std::memory_order_release, res=false</span><br><span class="line">test std::memory_order_relaxed, std::memory_order_relaxed, res=false</span><br></pre></td></tr></table></figure>
<h3 id="643-case-3-write-write-read-read-reorder"><a class="markdownIt-Anchor" href="#643-case-3-write-write-read-read-reorder"></a> 6.4.3 Case-3-write-write-read-read-reorder</h3>
<p>来自<a href="/resources/paper/Shared-Memory-Consistency-Models-A-Tutorial.pdf">Shared Memory Consistency Models: A Tutorial</a>中的<code>Figure-5(b)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> TIMES = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order read_order, std::memory_order write_order&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test_reorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// control vars</span></span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">control</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">stop</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">success</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; finished_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> round_process = [&amp;control, &amp;stop, &amp;finished_num](<span class="keyword">auto</span>&amp;&amp; process) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="comment">// make t1 and t2 go through synchronously</span></span><br><span class="line">            finished_num++;</span><br><span class="line">            <span class="keyword">while</span> (!stop &amp;&amp; !control)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">process</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait for next round</span></span><br><span class="line">            finished_num++;</span><br><span class="line">            <span class="keyword">while</span> (!stop &amp;&amp; control)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> control_process = [&amp;control, &amp;success, &amp;finished_num](<span class="keyword">auto</span>&amp;&amp; clean_process, <span class="keyword">auto</span>&amp;&amp; check_process) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="comment">// wait t1 and t2 at the top of the loop</span></span><br><span class="line">            <span class="keyword">while</span> (finished_num != <span class="number">2</span>)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// clean up data</span></span><br><span class="line">            finished_num = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">clean_process</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// let t1 and t2 go start</span></span><br><span class="line">            control = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait t1 and t2 finishing write operation</span></span><br><span class="line">            <span class="keyword">while</span> (finished_num != <span class="number">2</span>)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check assumption</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check_process</span>()) &#123;</span><br><span class="line">                success = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            finished_num = <span class="number">0</span>;</span><br><span class="line">            control = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main vars</span></span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; data;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; head;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; read_val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> process_1 = [&amp;data, &amp;head]() &#123;</span><br><span class="line">        data.<span class="built_in">store</span>(<span class="number">2000</span>, write_order);</span><br><span class="line">        head.<span class="built_in">store</span>(<span class="number">1</span>, write_order);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> process_2 = [&amp;data, &amp;head, &amp;read_val]() &#123;</span><br><span class="line">        <span class="keyword">while</span> (head.<span class="built_in">load</span>(read_order) == <span class="number">0</span>)</span><br><span class="line">            ;</span><br><span class="line">        read_val = data.<span class="built_in">load</span>(read_order);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> clean_process = [&amp;data, &amp;head, &amp;read_val]() &#123;</span><br><span class="line">        data = <span class="number">0</span>;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        read_val = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> check_process = [&amp;read_val]() &#123; <span class="keyword">return</span> read_val == <span class="number">2000</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t_1</span><span class="params">(round_process, process_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_2</span><span class="params">(round_process, process_2)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_control</span><span class="params">(control_process, clean_process, check_process)</span></span>;</span><br><span class="line"></span><br><span class="line">    t_control.<span class="built_in">join</span>();</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t_1.<span class="built_in">join</span>();</span><br><span class="line">    t_2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> res;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_seq_cst, std::memory_order_seq_cst&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_seq_cst, std::memory_order_seq_cst&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_acquire, std::memory_order_release&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_acquire, std::memory_order_release&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_relaxed, std::memory_order_relaxed&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_relaxed, std::memory_order_relaxed&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>x86</code>平台（<code>TSO</code>），<code>Relaxed Consistency Model</code>不允许<code>Write-Write</code>以及<code>Read-Read</code>重排，结果如下（对于其他具有不同内存模型的硬件平台，由于对<code>Relaxed</code>的支持程度不同，可能会有不同的结果）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test std::memory_order_seq_cst, std::memory_order_seq_cst, res=true</span><br><span class="line">test std::memory_order_acquire, std::memory_order_release, res=true</span><br><span class="line">test std::memory_order_relaxed, std::memory_order_relaxed, res=true</span><br></pre></td></tr></table></figure>
<h3 id="644-case-4-write-order-consistency"><a class="markdownIt-Anchor" href="#644-case-4-write-order-consistency"></a> 6.4.4 Case-4-write-order-consistency</h3>
<p>来自<a href="/resources/paper/Shared-Memory-Consistency-Models-A-Tutorial.pdf">Shared Memory Consistency Models: A Tutorial</a>中的<code>Figure-10(b)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> TIMES = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::memory_order read_order, std::memory_order write_order&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test_reorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// control vars</span></span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">control</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">stop</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">success</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; finished_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> round_process = [&amp;control, &amp;stop, &amp;finished_num](<span class="keyword">auto</span>&amp;&amp; process) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            <span class="comment">// make t1 and t2 go through synchronously</span></span><br><span class="line">            finished_num++;</span><br><span class="line">            <span class="keyword">while</span> (!stop &amp;&amp; !control)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">process</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait for next round</span></span><br><span class="line">            finished_num++;</span><br><span class="line">            <span class="keyword">while</span> (!stop &amp;&amp; control)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> control_process = [&amp;control, &amp;success, &amp;finished_num](<span class="keyword">auto</span>&amp;&amp; clean_process, <span class="keyword">auto</span>&amp;&amp; check_process) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="comment">// wait t1, t2 and t3 at the top of the loop</span></span><br><span class="line">            <span class="keyword">while</span> (finished_num != <span class="number">3</span>)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// clean up data</span></span><br><span class="line">            finished_num = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">clean_process</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// let t1, t2 and t3 go start</span></span><br><span class="line">            control = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait t1, t2 and t3 finishing write operation</span></span><br><span class="line">            <span class="keyword">while</span> (finished_num != <span class="number">3</span>)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check assumption</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check_process</span>()) &#123;</span><br><span class="line">                success = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            finished_num = <span class="number">0</span>;</span><br><span class="line">            control = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main vars</span></span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; a;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; b;</span><br><span class="line">    std::atomic&lt;<span class="type">int32_t</span>&gt; reg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> process_1 = [&amp;a]() &#123; a.<span class="built_in">store</span>(<span class="number">1</span>, write_order); &#125;;</span><br><span class="line">    <span class="keyword">auto</span> process_2 = [&amp;a, &amp;b]() &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">load</span>(read_order) == <span class="number">1</span>) &#123;</span><br><span class="line">            b.<span class="built_in">store</span>(<span class="number">1</span>, write_order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> process_3 = [&amp;a, &amp;b, &amp;reg]() &#123;</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">load</span>(read_order) == <span class="number">1</span>) &#123;</span><br><span class="line">            reg.<span class="built_in">store</span>(a.<span class="built_in">load</span>(read_order), write_order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> clean_process = [&amp;a, &amp;b, &amp;reg]() &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">        b = <span class="number">0</span>;</span><br><span class="line">        reg = <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> check_process = [&amp;reg]() &#123; <span class="keyword">return</span> reg != <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t_1</span><span class="params">(round_process, process_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_2</span><span class="params">(round_process, process_2)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_3</span><span class="params">(round_process, process_3)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_control</span><span class="params">(control_process, clean_process, check_process)</span></span>;</span><br><span class="line"></span><br><span class="line">    t_control.<span class="built_in">join</span>();</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">    t_1.<span class="built_in">join</span>();</span><br><span class="line">    t_2.<span class="built_in">join</span>();</span><br><span class="line">    t_3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> res;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_seq_cst, std::memory_order_seq_cst&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_seq_cst, std::memory_order_seq_cst&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_acquire, std::memory_order_release&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_acquire, std::memory_order_release&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    res = <span class="built_in">test_reorder</span>&lt;std::memory_order_relaxed, std::memory_order_relaxed&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test std::memory_order_relaxed, std::memory_order_relaxed&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;, res=&quot;</span> &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>x86</code>平台（<code>TSO</code>），<code>Relaxed Consistency Model</code>要求所有核看到的<code>Write</code>顺序是一致的，结果如下（对于其他具有不同内存模型的硬件平台，由于对<code>Relaxed</code>的支持程度不同，可能会有不同的结果）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test std::memory_order_seq_cst, std::memory_order_seq_cst, res=true</span><br><span class="line">test std::memory_order_acquire, std::memory_order_release, res=true</span><br><span class="line">test std::memory_order_relaxed, std::memory_order_relaxed, res=true</span><br></pre></td></tr></table></figure>
<h3 id="645-case-5-visibility"><a class="markdownIt-Anchor" href="#645-case-5-visibility"></a> 6.4.5 Case-5-visibility</h3>
<p>进程调度也能保证可见性，我们可以让读写线程绑定到某个核上，那么读写线程会在调度的作用下交替执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> use_inc&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_concurrent_visibility</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> TIMES = <span class="number">1000000</span>;</span><br><span class="line">    T count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [&amp;count]() &#123;</span><br><span class="line">        <span class="type">pthread_t</span> thread = <span class="built_in">pthread_self</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line">        <span class="built_in">CPU_ZERO</span>(&amp;cpuset);</span><br><span class="line">        <span class="built_in">CPU_SET</span>(<span class="number">0</span>, &amp;cpuset);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_setaffinity_np</span>(thread, <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_getaffinity_np</span>(thread, <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; TIMES; i++) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(use_inc)</span> </span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count = count + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;T, <span class="type">int32_t</span>&gt;)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;type=int32_t, count=&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, <span class="keyword">volatile</span> <span class="type">int32_t</span>&gt;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;type=volatile int32_t, count=&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same_v&lt;T, std::atomic&lt;<span class="type">int32_t</span>&gt;&gt;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;type=std::atomic&lt;int32_t&gt;, count=&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_concurrent_visibility</span>&lt;<span class="type">int32_t</span>, <span class="literal">true</span>&gt;();</span><br><span class="line">    <span class="built_in">test_concurrent_visibility</span>&lt;<span class="keyword">volatile</span> <span class="type">int32_t</span>, <span class="literal">false</span>&gt;();</span><br><span class="line">    test_concurrent_visibility&lt;std::atomic&lt;<span class="type">int32_t</span>&gt;, <span class="literal">true</span>&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type=int32_t, count=2000000</span><br><span class="line">type=volatile int32_t, count=2000000</span><br><span class="line">type=std::atomic&lt;int32_t&gt;, count=2000000</span><br></pre></td></tr></table></figure>
<h3 id="646-case-6-eventual-consistency"><a class="markdownIt-Anchor" href="#646-case-6-eventual-consistency"></a> 6.4.6 Case-6-eventual-consistency</h3>
<p>不同的原子操作，虽然无法保证同步语义，但是可以保证变量的最终一致性</p>
<ul>
<li>
<p>无原子操作时，<code>write</code>线程的写操作无法被<code>read</code>线程的读操作看到（<code>-O3</code>优化级别）</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">read</span><span class="params">([&amp;data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int64_t</span> prev = <span class="number">-1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (prev != <span class="number">-1</span> &amp;&amp; prev != data) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;see changes, prev=&quot;</span> &lt;&lt; prev &lt;&lt; <span class="string">&quot;, data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            prev = data;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">write</span><span class="params">([&amp;data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            data++;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    read.<span class="built_in">join</span>();</span><br><span class="line">    write.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用不同的<code>std::mutex</code>可以保证变量的最终一致性</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">read</span><span class="params">([&amp;data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::mutex m_read;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int64_t</span> prev = <span class="number">-1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::lock_guard&lt;std::mutex&gt; l(m_read);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (prev != <span class="number">-1</span> &amp;&amp; prev != data) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;see changes, prev=&quot;</span> &lt;&lt; prev &lt;&lt; <span class="string">&quot;, data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            prev = data;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">write</span><span class="params">([&amp;data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::mutex m_write;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::lock_guard&lt;std::mutex&gt; l(m_write);</span></span></span><br><span class="line"><span class="params"><span class="function">            data++;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    read.<span class="built_in">join</span>();</span><br><span class="line">    write.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用不同的<code>std::atomic</code>可以保证变量的最终一致性</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> data = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">read</span><span class="params">([&amp;data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::atomic&lt;<span class="type">int32_t</span>&gt; atom_read;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int64_t</span> prev = <span class="number">-1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            atom_read.load();</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (prev != <span class="number">-1</span> &amp;&amp; prev != data) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;see changes, prev=&quot;</span> &lt;&lt; prev &lt;&lt; <span class="string">&quot;, data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            prev = data;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">write</span><span class="params">([&amp;data]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::atomic&lt;<span class="type">int32_t</span>&gt; atom_write;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            data++;</span></span></span><br><span class="line"><span class="params"><span class="function">            atom_write.store(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    read.<span class="built_in">join</span>();</span><br><span class="line">    write.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="65-x86-memory-model"><a class="markdownIt-Anchor" href="#65-x86-memory-model"></a> 6.5 x86 Memory Model</h2>
<p>对于<code>std::memory_order_relaxed</code>，在不同的硬件平台上，其效果是不同的。x86属于<code>TSO</code></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lqlqlq/p/13693876.html">x86-TSO : 适用于x86体系架构并发编程的内存模型</a></p>
<h2 id="66-reference"><a class="markdownIt-Anchor" href="#66-reference"></a> 6.6 Reference</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107092432">C++11 - atomic类型和内存模型</a></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/memory_order">cppreference.com-std::memory_order</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24301047">如何理解 C++11 的六种 memory order？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiayy/p/3246157.html">并行编程——内存模型之顺序一致性</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91406250">漫谈内存一致性模型</a></li>
</ul>
<h1 id="7-mechanism"><a class="markdownIt-Anchor" href="#7-mechanism"></a> 7 Mechanism</h1>
<h2 id="71-lvalue-rvalue"><a class="markdownIt-Anchor" href="#71-lvalue-rvalue"></a> 7.1 lvalue &amp; rvalue</h2>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category">Value categories</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Foo(const Foo&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(Foo&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Foo(Foo&amp;&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HolderWithoutMove</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">HolderWithoutMove</span><span class="params">(Foo&amp;&amp; foo)</span> : _foo(foo) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> Foo _foo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HolderWithMove</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">HolderWithMove</span><span class="params">(Foo&amp;&amp; foo)</span> : _foo(std::move(foo)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> Foo _foo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">receiveFoo</span><span class="params">(Foo&amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;receiveFoo(Foo&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">receiveFoo</span><span class="params">(Foo&amp;&amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;receiveFoo(Foo&amp;&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forwardWithoutMove</span><span class="params">(Foo&amp;&amp; foo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">receiveFoo</span>(foo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forwardWithMove</span><span class="params">(Foo&amp;&amp; foo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">receiveFoo</span>(std::<span class="built_in">move</span>(foo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">HolderWithoutMove <span class="title">holder1</span><span class="params">(&#123;&#125;)</span></span>;</span><br><span class="line">    <span class="function">HolderWithMove <span class="title">holder2</span><span class="params">(&#123;&#125;)</span></span>;</span><br><span class="line">    forwardWithoutMove(&#123;&#125;);</span><br><span class="line">    forwardWithMove(&#123;&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo(const Foo&amp;)</span><br><span class="line">Foo(Foo&amp;&amp;)</span><br><span class="line">receiveFoo(Foo&amp;)</span><br><span class="line">receiveFoo(Foo&amp;&amp;)</span><br></pre></td></tr></table></figure>
<h2 id="72-move-semantics"><a class="markdownIt-Anchor" href="#72-move-semantics"></a> 7.2 Move Semantics</h2>
<p><strong>For argument passing:</strong></p>
<ul>
<li>If a function receives an object of type <code>T</code>(not reference type), you pass lvalue, then copy constructor is called to create the object; you pass rvalue, then move constructor is called to create the object</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Foo::Foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Foo::Foo(const Foo&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(Foo&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Foo::Foo(Foo&amp;&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Foo::operator=(const Foo&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(Foo&amp;&amp;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Foo::operator=(Foo&amp;&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Foo <span class="title">getFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bar</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Bar</span>(<span class="type">const</span> Bar&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Bar::Bar(const Bar&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Bar</span>(Bar&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Bar::Bar(Bar&amp;&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">receiveBar</span><span class="params">(Bar bar)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;receiveBar(Bar)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;Foo&gt; v;</span><br><span class="line">    <span class="comment">// Avoid scale up</span></span><br><span class="line">    v.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\npush_back without std::move&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// This move operation is possible because the object returned by getFoo() is an rvalue, which is eligible for move semantics.</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">getFoo</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\npush_back with std::move (1)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(<span class="built_in">getFoo</span>()));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\npush_back with std::move (2)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Foo foo = <span class="built_in">getFoo</span>();</span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(foo));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nassign without std::move&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Foo foo_assign;</span><br><span class="line">    foo_assign = <span class="built_in">getFoo</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nassign with std::move&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    foo_assign = std::<span class="built_in">move</span>(<span class="built_in">getFoo</span>());</span><br><span class="line"></span><br><span class="line">    Bar bar1, bar2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\npass without std::move&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">receiveBar</span>(bar1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\npass with std::move&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">receiveBar</span>(std::<span class="built_in">move</span>(bar2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">push_back without std::move</span><br><span class="line">Foo::Foo()</span><br><span class="line">Foo::Foo(Foo&amp;&amp;)</span><br><span class="line"></span><br><span class="line">push_back with std::move (1)</span><br><span class="line">Foo::Foo()</span><br><span class="line">Foo::Foo(Foo&amp;&amp;)</span><br><span class="line"></span><br><span class="line">push_back with std::move (2)</span><br><span class="line">Foo::Foo()</span><br><span class="line">Foo::Foo(Foo&amp;&amp;)</span><br><span class="line"></span><br><span class="line">assign without std::move</span><br><span class="line">Foo::Foo()</span><br><span class="line">Foo::Foo()</span><br><span class="line">Foo::operator=(Foo&amp;&amp;)</span><br><span class="line"></span><br><span class="line">assign with std::move</span><br><span class="line">Foo::Foo()</span><br><span class="line">Foo::operator=(Foo&amp;&amp;)</span><br><span class="line"></span><br><span class="line">pass without std::move</span><br><span class="line">Bar::Bar(const Bar&amp;)</span><br><span class="line">receiveBar(Bar)</span><br><span class="line"></span><br><span class="line">pass with std::move</span><br><span class="line">Bar::Bar(Bar&amp;&amp;)</span><br><span class="line">receiveBar(Bar)</span><br></pre></td></tr></table></figure>
<h2 id="73-structured-bindings"><a class="markdownIt-Anchor" href="#73-structured-bindings"></a> 7.3 Structured Bindings</h2>
<p>Structured bindings were introduced in C++17 and provide a convenient way to destructure the elements of a tuple-like object or aggregate into individual variables.</p>
<p>Tuple-like objects in C++ include:</p>
<ul>
<li><code>std::tuple</code>: The standard tuple class provided by the C++ Standard Library.</li>
<li><code>std::pair</code>: A specialized tuple with exactly two elements, also provided by the C++ Standard Library.</li>
<li>Custom user-defined types that mimic the behavior of tuples, such as structs with a fixed number of members.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; n, <span class="type">int</span> a, <span class="type">double</span> h) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">myTuple</span><span class="params">(<span class="number">42</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = myTuple;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;z: &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create an instance of the custom struct</span></span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="number">1.75</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Structured binding to extract elements</span></span><br><span class="line">    <span class="keyword">auto</span> [name, age, height] = person;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print the extracted elements</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; age &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Height: &quot;</span> &lt;&lt; height &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="74-copy-elision"><a class="markdownIt-Anchor" href="#74-copy-elision"></a> 7.4 Copy Elision</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_elision">Copy elision</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12953127/what-are-copy-elision-and-return-value-optimization">What are copy elision and return value optimization?</a></li>
</ul>
<p>Copy elision is an optimization technique used by compilers in C++ to reduce the overhead of copying and moving objects. This optimization can significantly improve performance by eliminating unnecessary copying of objects, especially in return statements or during function calls. Two specific cases of copy elision are Return Value Optimization (RVO) and Named Return Value Optimization (NRVO). Let’s explore each of these:</p>
<ul>
<li>
<p><code>Return Value Optimization (RVO)</code>: RVO is a compiler optimization that eliminates the need for a temporary object when a function returns an object by value. Normally, when a function returns an object, a temporary copy of the object is created (which invokes the copy constructor), and then the temporary object is copied to the destination variable. With RVO, the compiler can directly construct the return value in the memory location of the caller’s receiving variable, thereby skipping the creation and copy of the temporary object.</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">    Widget() &#123;&#125;</span><br><span class="line">    Widget(const Widget&amp;) &#123; std::cout &lt;&lt; &quot;Copy constructor called!\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget createWidget() &#123;</span><br><span class="line">    return Widget();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Widget w = createWidget(); // With RVO, the copy constructor is not called</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Named Return Value Optimization (NRVO)</code>: Similar to RVO, NRVO allows the compiler to eliminate the temporary object even when the object returned has a name. NRVO is a bit more challenging for the compiler because it involves predicting which named variable will be returned at compile time.</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy constructor called!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">createWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="keyword">return</span> w; <span class="comment">// Normally, this would call the copy constructor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Widget w = <span class="built_in">createWidget</span>(); <span class="comment">// With RVO, the copy constructor is not called</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="75-implicit-type-conversions"><a class="markdownIt-Anchor" href="#75-implicit-type-conversions"></a> 7.5 Implicit Type Conversions</h2>
<p><strong>Implicit conversion sequence consists of the following, in this order:</strong></p>
<ol>
<li>zero or one standard conversion sequence;</li>
<li>zero or one user-defined conversion;</li>
<li>zero or one standard conversion sequence (only if a user-defined conversion is used).</li>
</ol>
<p><strong>A standard conversion sequence consists of the following, in this order:</strong></p>
<ol>
<li>zero or one conversion from the following set:
<ul>
<li>lvalue-to-rvalue conversion,</li>
<li>array-to-pointer conversion, and</li>
<li>function-to-pointer conversion;</li>
</ul>
</li>
<li>zero or one numeric promotion or numeric conversion;</li>
<li>zero or one function pointer conversion;</li>
<li>zero or one qualification conversion.</li>
</ol>
<p><strong>Assored conversion types:</strong></p>
<ol>
<li>derived-to-base pointer conversions;</li>
</ol>
<h1 id="8-policy"><a class="markdownIt-Anchor" href="#8-policy"></a> 8 Policy</h1>
<h2 id="81-pointer-stability"><a class="markdownIt-Anchor" href="#81-pointer-stability"></a> 8.1 Pointer Stability</h2>
<p><strong><code>pointer stability</code>通常用于描述容器。当我们说一个容器是<code>pointer stability</code>时，是指，当某个元素添加到容器之后、从容器删除之前，该元素的内存地址不变，也就是说，该元素的内存地址，不会受到容器的添加删除元素、扩缩容、或者其他操作影响</strong></p>
<ul>
<li>引用也会受到这个性质的影响，因为引用就是指针的语法糖</li>
</ul>
<p><strong><a target="_blank" rel="noopener" href="https://abseil.io/docs/cpp/guides/container">absl</a></strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Container</th>
<th style="text-align:left">Is pointer stability or not</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>std::vector</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>std::list</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>std::deque</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left">Expand may keep pointer stablity, but contract may not</td>
</tr>
<tr>
<td style="text-align:left"><code>std::map</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>std::unordered_map</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>std::set</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>std::unordered_set</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>absl::flat_hash_map</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>absl::flat_hash_set</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>absl::node_hash_map</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>absl::node_hash_set</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>phmap::flat_hash_map</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>phmap::flat_hash_set</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>phmap::node_hash_map</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>phmap::node_hash_set</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h2 id="82-exception-safe"><a class="markdownIt-Anchor" href="#82-exception-safe"></a> 8.2 Exception Safe</h2>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Exception_safety">Wiki-Exception safety</a></p>
<p><strong><code>exception safety</code>的几个级别：</strong></p>
<ol>
<li><code>No-throw guarantee</code>：承诺不会对外抛出任何异常。方法内部可能会抛异常，但都会被正确处理</li>
<li><code>Strong exception safety</code>：可能会抛出异常，但是承诺不会有副作用，所有对象都会恢复到调用方法时的初始状态</li>
<li><code>Basic exception safety</code>：可能会抛出异常，操作失败的部分可能会导致副作用，但所有不变量都会被保留。任何存储的数据都将包含可能与原始值不同的有效值。资源泄漏（包括内存泄漏）通常通过一个声明所有资源都被考虑和管理的不变量来排除</li>
<li><code>No exception safety</code>：不承诺异常安全</li>
</ol>
<h2 id="83-raii"><a class="markdownIt-Anchor" href="#83-raii"></a> 8.3 RAII</h2>
<p><code>RAII, Resource Acquisition is initialization</code>，即资源获取即初始化。典型示例包括：<code>std::lock_guard</code>、<code>defer</code>。简单来说，就是在对象的构造方法中初始化资源，在析构函数中销毁资源。而构造函数与析构函数的调用是由编译器自动插入的，减轻了开发者的心智负担</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DeferFunction</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeferOp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DeferOp</span><span class="params">(DeferFunction func)</span> : _func(std::move(func)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DeferOp</span>() &#123; _func(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DeferFunction _func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="831-destructor-behavior"><a class="markdownIt-Anchor" href="#831-destructor-behavior"></a> 8.3.1 Destructor Behavior</h3>
<p><strong>Key Concepts</strong></p>
<ul>
<li>RAII (Resource Acquisition Is Initialization): The DeferOp class is an RAII wrapper that executes a provided function (or lambda) when its destructor is called. This is typically used for cleanup or deferred execution.</li>
<li>Destructor Behavior: In C++, destructors are implicitly called when an object goes out of scope. If an exception is thrown elsewhere in the scope, the stack unwinds, and destructors of automatic objects are invoked.</li>
<li>Exception Handling: A try-catch block catches exceptions thrown within its scope, but how exceptions interact with destructors is critical here.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DeferFunction</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeferOp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DeferOp</span><span class="params">(DeferFunction func)</span> : _func(std::move(func)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DeferOp</span>() <span class="built_in">noexcept</span>(<span class="literal">false</span>) &#123; _func(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DeferFunction _func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">normal_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;normal_func&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">raii_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DeferOp</span>([]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;raii_func&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">normal_func</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;normal_func exception caught&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">raii_func</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;raii_func exception caught&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Code Breakdown</strong></p>
<ul>
<li><code>normal_func</code>
<ul>
<li>Executes <code>std::cout &lt;&lt; &quot;hello world&quot; &lt;&lt; std::endl;</code>.</li>
<li>Throws a <code>std::runtime_error</code>.</li>
<li>This exception is thrown directly in the <code>try</code> block in <code>main</code>, so it’s caught by the corresponding <code>catch (...)</code> block, printing <code>&quot;normal_func exception caught&quot;</code>.</li>
</ul>
</li>
<li><code>raii_func</code>
<ul>
<li>Creates a <code>DeferOp</code> object with a lambda: <code>[]() &#123; std::cout &lt;&lt; &quot;hello world&quot; &lt;&lt; std::endl; throw std::runtime_error(&quot;raii_func&quot;); &#125;</code>.</li>
<li>The lambda isn’t executed immediately—it’s stored in the <code>DeferOp</code> object’s <code>_func</code> member.</li>
<li>When <code>raii_func</code> returns, the <code>DeferOp</code> object goes out of scope, and its destructor <code>~DeferOp()</code> is called.</li>
<li>The destructor invokes <code>_func()</code>, which executes the lambda, printing <code>&quot;hello world&quot;</code> and throwing <code>the std::runtime_error</code>.</li>
</ul>
</li>
</ul>
<p><strong>Why the Exception Isn’t Caught</strong>: The key issue lies in when and where the exception is thrown in raii_func:</p>
<ul>
<li>The <code>try</code> block in <code>main</code> surrounds the call to <code>raii_func()</code>.</li>
<li>However, no exception is thrown during the execution of <code>raii_func()</code> itself—<code>raii_func</code> simply constructs the <code>DeferOp</code> object and returns.</li>
<li>The exception is thrown later, in the destructor of <code>DeferOp</code>, after the <code>try</code> block has already completed and the stack is unwinding (or after the function has exited normally).</li>
<li>At this point, the <code>try-catch</code> block in <code>main</code> is no longer active because the scope of the <code>try</code> block has ended. Exceptions thrown during stack unwinding or outside the <code>try</code> block aren’t caught by that block.</li>
</ul>
<p><strong>In C++, if an exception is thrown while the stack is already unwinding due to another exception—or outside of an active <code>try</code> block—it results in undefined behavior or program termination unless caught by a higher-level <code>try-catch</code>. In this case, there’s no prior exception causing unwinding, but the exception still occurs outside the <code>try</code> block’s scope.</strong></p>
<p><strong>And there’s a solution: add <code>noexcept(false)</code> to destructor of <code>DeferOp</code>, the exception can be catched as expected.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">DeferFunction</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeferOp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">DeferOp</span><span class="params">(DeferFunction func)</span> : _func(std::move(func)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DeferOp</span>() <span class="built_in">noexcept</span>(<span class="literal">false</span>) &#123; _func(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DeferFunction _func;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">normal_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;normal_func&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">raii_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DeferOp</span>([]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;raii_func&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">normal_func</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;normal_func exception caught&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">raii_func</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;raii_func exception caught&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="9-best-practice"><a class="markdownIt-Anchor" href="#9-best-practice"></a> 9 Best Practice</h1>
<h2 id="91-visitor"><a class="markdownIt-Anchor" href="#91-visitor"></a> 9.1 Visitor</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APPLY_AST_TYPES(M) \</span></span><br><span class="line"><span class="meta">    M(Function)            \</span></span><br><span class="line"><span class="meta">    M(UnaryExpression)     \</span></span><br><span class="line"><span class="meta">    M(BinaryExpression)    \</span></span><br><span class="line"><span class="meta">    M(Literal)</span></span><br><span class="line"><span class="comment">// More types here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ASTType</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENUM_TYPE(ITEM) ITEM,</span></span><br><span class="line">    <span class="built_in">APPLY_AST_TYPES</span>(ENUM_TYPE) UNDEFINED,</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> ENUM_TYPE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">toString</span><span class="params">(ASTType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASE_TYPE(ITEM) \</span></span><br><span class="line"><span class="meta">    case ASTType::ITEM: \</span></span><br><span class="line"><span class="meta">        return #ITEM;</span></span><br><span class="line">        <span class="built_in">APPLY_AST_TYPES</span>(CASE_TYPE)</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> CASE_TYPE</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        __builtin_unreachable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ASTNode</span> &#123;</span><br><span class="line">    <span class="built_in">ASTNode</span>(std::vector&lt;ASTNode*&gt; children_) : <span class="built_in">children</span>(children_) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ASTType <span class="title">getType</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;ASTNode*&gt; children;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ASTFunction</span> : <span class="keyword">public</span> ASTNode &#123;</span><br><span class="line">    <span class="built_in">ASTFunction</span>(std::string name_, std::vector&lt;ASTNode*&gt; args_) : <span class="built_in">ASTNode</span>(args_), <span class="built_in">name</span>(std::<span class="built_in">move</span>(name_)) &#123;&#125;</span><br><span class="line">    <span class="function">ASTType <span class="title">getType</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> ASTType::Function; &#125;</span><br><span class="line">    <span class="type">const</span> std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ASTUnaryExpression</span> : <span class="keyword">public</span> ASTNode &#123;</span><br><span class="line">    <span class="built_in">ASTUnaryExpression</span>(std::string op_, ASTNode* operand_) : <span class="built_in">ASTNode</span>(&#123;operand_&#125;), <span class="built_in">op</span>(std::<span class="built_in">move</span>(op_)) &#123;&#125;</span><br><span class="line">    <span class="function">ASTType <span class="title">getType</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> ASTType::UnaryExpression; &#125;</span><br><span class="line">    <span class="type">const</span> std::string op;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ASTBinaryExpression</span> : <span class="keyword">public</span> ASTNode &#123;</span><br><span class="line">    <span class="built_in">ASTBinaryExpression</span>(std::string op_, ASTNode* lhs_, ASTNode* rhs_) : <span class="built_in">ASTNode</span>(&#123;lhs_, rhs_&#125;), _op(std::<span class="built_in">move</span>(op_)) &#123;&#125;</span><br><span class="line">    <span class="function">ASTType <span class="title">getType</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> ASTType::BinaryExpression; &#125;</span><br><span class="line">    <span class="type">const</span> std::string _op;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ASTLiteral</span> : <span class="keyword">public</span> ASTNode &#123;</span><br><span class="line">    <span class="built_in">ASTLiteral</span>(std::string value_) : <span class="built_in">ASTNode</span>(&#123;&#125;), <span class="built_in">value</span>(std::<span class="built_in">move</span>(value_)) &#123;&#125;</span><br><span class="line">    <span class="function">ASTType <span class="title">getType</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> ASTType::Literal; &#125;</span><br><span class="line">    <span class="type">const</span> std::string value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ASTVisitor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> R <span class="title">visit</span><span class="params">(ASTNode* node, C&amp; ctx)</span> </span>&#123; <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;unimplemented&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VISITOR_DEF(TYPE) \</span></span><br><span class="line"><span class="meta">    virtual R visit##TYPE(ASTNode* node, C&amp; context) &#123; return visit(node, context); &#125;</span></span><br><span class="line">    <span class="built_in">APPLY_AST_TYPES</span>(VISITOR_DEF)</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> VISITOR_DEF</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ASTVisitorUtil</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> C&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> R <span class="title">visit</span><span class="params">(ASTNode* node, ASTVisitor&lt;R, C&gt;&amp; visitor, C&amp; ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (node-&gt;<span class="built_in">getType</span>()) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASE_TYPE(ITEM) \</span></span><br><span class="line"><span class="meta">    case ASTType::ITEM: \</span></span><br><span class="line"><span class="meta">        return visitor.visit##ITEM(node, ctx);</span></span><br><span class="line">            <span class="built_in">APPLY_AST_TYPES</span>(CASE_TYPE)</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> CASE_TYPE</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            __builtin_unreachable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EmptyContext</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintVisitor</span> : <span class="keyword">public</span> ASTVisitor&lt;<span class="type">void</span>, EmptyContext&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ASTNode* node, EmptyContext&amp; context)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Visiting node: &quot;</span> &lt;&lt; <span class="built_in">toString</span>(node-&gt;<span class="built_in">getType</span>()) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>* child : node-&gt;children) &#123;</span><br><span class="line">            ASTVisitorUtil::<span class="built_in">visit</span>(child, *<span class="keyword">this</span>, context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RebuildVisitor</span> : <span class="keyword">public</span> ASTVisitor&lt;<span class="type">void</span>, std::string&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ASTNode* node, std::string&amp; context)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;unimplemented&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visitUnaryExpression</span><span class="params">(ASTNode* node, std::string&amp; context)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>* unary = <span class="built_in">dynamic_cast</span>&lt;ASTUnaryExpression*&gt;(node);</span><br><span class="line">        context.<span class="built_in">append</span>(unary-&gt;op);</span><br><span class="line">        ASTVisitorUtil::<span class="built_in">visit</span>(unary-&gt;children[<span class="number">0</span>], *<span class="keyword">this</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visitBinaryExpression</span><span class="params">(ASTNode* node, std::string&amp; context)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>* binary = <span class="built_in">dynamic_cast</span>&lt;ASTBinaryExpression*&gt;(node);</span><br><span class="line">        ASTVisitorUtil::<span class="built_in">visit</span>(binary-&gt;children[<span class="number">0</span>], *<span class="keyword">this</span>, context);</span><br><span class="line">        context.<span class="built_in">append</span>(<span class="string">&quot; &quot;</span> + binary-&gt;_op + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        ASTVisitorUtil::<span class="built_in">visit</span>(binary-&gt;children[<span class="number">1</span>], *<span class="keyword">this</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visitFunction</span><span class="params">(ASTNode* node, std::string&amp; context)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>* function = <span class="built_in">dynamic_cast</span>&lt;ASTFunction*&gt;(node);</span><br><span class="line">        context.<span class="built_in">append</span>(function-&gt;name);</span><br><span class="line">        context.<span class="built_in">append</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>* child : node-&gt;children) &#123;</span><br><span class="line">            ASTVisitorUtil::<span class="built_in">visit</span>(child, *<span class="keyword">this</span>, context);</span><br><span class="line">            <span class="keyword">if</span> (++i != node-&gt;children.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                context.<span class="built_in">append</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        context.<span class="built_in">append</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visitLiteral</span><span class="params">(ASTNode* node, std::string&amp; context)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>* literal = <span class="built_in">dynamic_cast</span>&lt;ASTLiteral*&gt;(node);</span><br><span class="line">        context.<span class="built_in">append</span>(literal-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create an AST: max(1, 2) + min(3, 5) / -3</span></span><br><span class="line">    ASTNode* ast = <span class="keyword">new</span> <span class="built_in">ASTBinaryExpression</span>(</span><br><span class="line">            <span class="string">&quot;+&quot;</span>, <span class="keyword">new</span> <span class="built_in">ASTFunction</span>(<span class="string">&quot;max&quot;</span>, &#123;<span class="keyword">new</span> <span class="built_in">ASTLiteral</span>(<span class="string">&quot;1&quot;</span>), <span class="keyword">new</span> <span class="built_in">ASTLiteral</span>(<span class="string">&quot;2&quot;</span>)&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">ASTBinaryExpression</span>(<span class="string">&quot;/&quot;</span>, <span class="keyword">new</span> <span class="built_in">ASTFunction</span>(<span class="string">&quot;min&quot;</span>, &#123;<span class="keyword">new</span> <span class="built_in">ASTLiteral</span>(<span class="string">&quot;3&quot;</span>), <span class="keyword">new</span> <span class="built_in">ASTLiteral</span>(<span class="string">&quot;5&quot;</span>)&#125;),</span><br><span class="line">                                    <span class="keyword">new</span> <span class="built_in">ASTUnaryExpression</span>(<span class="string">&quot;-&quot;</span>, <span class="keyword">new</span> <span class="built_in">ASTLiteral</span>(<span class="string">&quot;3&quot;</span>))));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        EmptyContext context;</span><br><span class="line">        PrintVisitor visitor;</span><br><span class="line">        ASTVisitorUtil::<span class="built_in">visit</span>(ast, visitor, context);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::string buffer;</span><br><span class="line">        RebuildVisitor visitor;</span><br><span class="line">        ASTVisitorUtil::<span class="built_in">visit</span>(ast, visitor, buffer);</span><br><span class="line">        std::cout &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="10-tips"><a class="markdownIt-Anchor" href="#10-tips"></a> 10 Tips</h1>
<h2 id="101-how-to-choose-function-parameter-type"><a class="markdownIt-Anchor" href="#101-how-to-choose-function-parameter-type"></a> 10.1 How to Choose Function Parameter Type</h2>
<p>For given type T, you can use:</p>
<ol>
<li><code>const T&amp;</code>: Avoid copy.</li>
<li><code>T&amp;&amp;</code>: The function should take ownership of this parameter.</li>
<li><code>T&amp;</code>: The function may modify this parameter.</li>
<li><code>T</code>: A copy of the parameter. (Not recommend)</li>
<li><code>T*</code>: Used when this parameter is treated as output of the function.</li>
<li><code>std::shared_ptr&lt;T&gt;</code>/<code>std::unique_ptr&lt;T&gt;</code>: Used when the lifetime of object should be extended or transfered.</li>
</ol>
<h3 id="1011-how-to-choose-constructor-parameter-type"><a class="markdownIt-Anchor" href="#1011-how-to-choose-constructor-parameter-type"></a> 10.1.1 How to Choose Constructor Parameter Type</h3>
<p>Things change when it come to constructor:</p>
<ol>
<li><code>const T&amp;</code>: Often used when the type cannot be moved.</li>
<li><code>T&amp;&amp;</code>: Often used when the type can be moved.</li>
<li><code>T&amp;</code>: Rarely use.</li>
<li><strong><code>T</code>: Recommended, used for both copy or moved.</strong></li>
<li><code>T*</code>: Rarely use.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo1</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Foo1</span>(Foo1&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Foo1(Foo1&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Foo1</span>(Foo1&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Foo1(Foo1&amp;&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo2</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Foo2</span>(Foo2&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Foo2(Foo2&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Foo2</span>(Foo2&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Foo2(Foo2&amp;&amp;)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bar</span>(Foo1 f1, Foo2 f2) : <span class="built_in">foo1</span>(f1), <span class="built_in">foo2</span>(std::<span class="built_in">move</span>(f2)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Foo1 foo1;</span><br><span class="line">    Foo2 foo2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo1 foo1;</span><br><span class="line">    Foo2 foo2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bar1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Bar <span class="title">bar1</span><span class="params">(foo1, std::move(foo2))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bar2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Bar <span class="title">bar2</span><span class="params">(std::move(foo1), std::move(foo2))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Bar1</span><br><span class="line">Foo2(Foo2&amp;&amp;)</span><br><span class="line">Foo1(Foo1&amp;)</span><br><span class="line">Foo1(Foo1&amp;)</span><br><span class="line">Foo2(Foo2&amp;&amp;)</span><br><span class="line">Bar2</span><br><span class="line">Foo2(Foo2&amp;&amp;)</span><br><span class="line">Foo1(Foo1&amp;&amp;)</span><br><span class="line">Foo1(Foo1&amp;)</span><br><span class="line">Foo2(Foo2&amp;&amp;)</span><br></pre></td></tr></table></figure>
<h2 id="102-variable-length-array"><a class="markdownIt-Anchor" href="#102-variable-length-array"></a> 10.2 Variable-length Array</h2>
<p>Variable-length array (VLA), which is a feature not supported by standard C++. However, some compilers, particularly in C and as extensions in C++, do provide support for VLAs.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> array[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int32_t</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> num1;</span><br><span class="line">    <span class="type">int32_t</span> num2;</span><br><span class="line">    <span class="type">int32_t</span> array1[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int32_t</span> num3;</span><br><span class="line">    <span class="type">int32_t</span> array2[std::<span class="built_in">atoi</span>(argv[<span class="number">1</span>])];</span><br><span class="line">    <span class="type">int32_t</span> num4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> offset = [&amp;num1](<span class="type">void</span>* p) &#123; <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int8_t</span>*&gt;(p) - <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int8_t</span>*&gt;(&amp;num1); &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num1: &quot;</span> &lt;&lt; <span class="built_in">offset</span>(&amp;num1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num2: &quot;</span> &lt;&lt; <span class="built_in">offset</span>(&amp;num2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;array1: &quot;</span> &lt;&lt; <span class="built_in">offset</span>(&amp;array1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num3: &quot;</span> &lt;&lt; <span class="built_in">offset</span>(&amp;num3) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;array2: &quot;</span> &lt;&lt; <span class="built_in">offset</span>(&amp;array2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num4: &quot;</span> &lt;&lt; <span class="built_in">offset</span>(&amp;num4) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">./main 1</span><br><span class="line">num1: 0</span><br><span class="line">num2: -4</span><br><span class="line">array1: -8</span><br><span class="line">num3: -12</span><br><span class="line">array2: -148</span><br><span class="line">num4: -32</span><br><span class="line"></span><br><span class="line">./main 100</span><br><span class="line">num1: 0</span><br><span class="line">num2: -4</span><br><span class="line">array1: -8</span><br><span class="line">num3: -12</span><br><span class="line">array2: -532</span><br><span class="line">num4: -32</span><br></pre></td></tr></table></figure>
<h1 id="11-faq"><a class="markdownIt-Anchor" href="#11-faq"></a> 11 FAQ</h1>
<h2 id="111-why-is-it-unnecessary-to-specify-the-size-when-releasing-memory-with-free-and-delete"><a class="markdownIt-Anchor" href="#111-why-is-it-unnecessary-to-specify-the-size-when-releasing-memory-with-free-and-delete"></a> 11.1 Why is it unnecessary to specify the size when releasing memory with free and delete</h2>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1518711/how-does-free-know-how-much-to-free">How does free know how much to free?</a></p>
<p>分配内存时，除了分配指定的内存之外，还会分配一个<code>header</code>，用于存储一些信息，例如</p>
<ul>
<li><strong><code>size</code></strong></li>
<li><code>special marker</code></li>
<li><code>checksum</code></li>
<li><code>pointers to next/previous block</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">____ The allocated block ____</span><br><span class="line">/                             \</span><br><span class="line">+--------+--------------------+</span><br><span class="line">| Header | Your data area ... |</span><br><span class="line">+--------+--------------------+</span><br><span class="line">          ^</span><br><span class="line">          |</span><br><span class="line">          +-- The address you are given</span><br></pre></td></tr></table></figure>
<h2 id="112-do-parameter-types-require-lvalue-or-rvalue-references"><a class="markdownIt-Anchor" href="#112-do-parameter-types-require-lvalue-or-rvalue-references"></a> 11.2 Do parameter types require lvalue or rvalue references</h2>
<h2 id="113-does-the-return-type-require-lvalue-or-rvalue-references"><a class="markdownIt-Anchor" href="#113-does-the-return-type-require-lvalue-or-rvalue-references"></a> 11.3 Does the return type require lvalue or rvalue references</h2>
<h1 id="12-reference"><a class="markdownIt-Anchor" href="#12-reference"></a> 12 Reference</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8c4952e9edec">C++11\14\17\20 特性介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://www.codenong.com/1563897/">关于C++：静态常量字符串(类成员)</a></li>
<li><a target="_blank" rel="noopener" href="https://hownot2code.com/2016/12/05/do-while-0-in-macros/">do {…} while (0) in macros</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.sei.cmu.edu/confluence/display/c/PRE10-C.+Wrap+multistatement+macros+in+a+do-while+loop">PRE10-C. Wrap multistatement macros in a do-while loop</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-const-keyword.html">C++ const 关键字小结</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-casting-operators.html">C++ 强制转换运算符</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used">When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12566228/candidate-template-ignored-because-template-argument-could-not-be-inferred">Candidate template ignored because template argument could not be inferred</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/60438079/calling-a-member-function-pointer-from-outside-the-class-is-it-possible">calling a member function pointer from outside the class - is it possible?</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83449008">带你深入理解内存对齐最底层原理</a></li>
<li><a target="_blank" rel="noopener" href="https://light-city.club/sc/">C++那些事</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ethernut.de/en/documents/arm-inline-asm.html">ARM GCC Inline Assembler Cookbook</a></li>
<li><a target="_blank" rel="noopener" href="https://www.felixcloutier.com/documents/gcc-asm.html#constraints">GCC’s assembler syntax</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag"># 原创</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/09/06/Cpp-Meta-Programming/" rel="prev" title="Cpp-Meta-Programming">
      <i class="fa fa-chevron-left"></i> Cpp-Meta-Programming
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/06/Cpp-Standard-Library/" rel="next" title="Cpp-Standard-Library">
      Cpp-Standard-Library <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-livere">livere</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzY0My8xMDE5OA=="></div>
  </div>
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-features"><span class="nav-text"> 1 Features</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-preprocessor-directives"><span class="nav-text"> 2 Preprocessor Directives</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#21-conditions"><span class="nav-text"> 2.1 Conditions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-define"><span class="nav-text"> 2.2 #define</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#221-work-with-compiler"><span class="nav-text"> 2.2.1 Work with compiler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#222-tips"><span class="nav-text"> 2.2.2 Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2221-do-while0-in-macros"><span class="nav-text"> 2.2.2.1 do while(0) in macros</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2222-variant"><span class="nav-text"> 2.2.2.2 Variant</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2223-comma-problem"><span class="nav-text"> 2.2.2.3 Comma Problem</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#223-macro-expansion"><span class="nav-text"> 2.2.3 Macro Expansion</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-variadic-macros"><span class="nav-text"> 2.3 Variadic Macros</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-pragma"><span class="nav-text"> 2.4 #pragma</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-error"><span class="nav-text"> 2.5 #error</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-reference"><span class="nav-text"> 2.6 Reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-key-word"><span class="nav-text"> 3 Key Word</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#31-type-qualifier"><span class="nav-text"> 3.1 Type Qualifier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#311-const"><span class="nav-text"> 3.1.1 const</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3111-topbottom-level-const"><span class="nav-text"> 3.1.1.1 Top&#x2F;Bottom Level const</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3112-const-actual-and-formal-parameters"><span class="nav-text"> 3.1.1.2 const Actual and Formal Parameters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3113-const-member"><span class="nav-text"> 3.1.1.3 const Member</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3114-const-member-function"><span class="nav-text"> 3.1.1.4 const Member Function</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#312-volatile"><span class="nav-text"> 3.1.2 volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3121-visibility-verification"><span class="nav-text"> 3.1.2.1 Visibility Verification</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3122-atomicity-verification"><span class="nav-text"> 3.1.2.2 Atomicity Verification</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#313-mutable"><span class="nav-text"> 3.1.3 mutable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-other-specifiers"><span class="nav-text"> 3.2 Other Specifiers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#321-inline"><span class="nav-text"> 3.2.1 inline</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-type-length"><span class="nav-text"> 3.3 Type Length</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#331-memory-alignment"><span class="nav-text"> 3.3.1 Memory Alignment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#332-sizeof"><span class="nav-text"> 3.3.2 sizeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#333-alignof"><span class="nav-text"> 3.3.3 alignof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#334-alignas"><span class="nav-text"> 3.3.4 alignas</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-type-inference"><span class="nav-text"> 3.4 Type Inference</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#341-auto"><span class="nav-text"> 3.4.1 auto</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#342-decltype"><span class="nav-text"> 3.4.2 decltype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#343-typeof"><span class="nav-text"> 3.4.3 typeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#344-typeid"><span class="nav-text"> 3.4.4 typeid</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-type-conversion"><span class="nav-text"> 3.5 Type Conversion</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#351-static_cast"><span class="nav-text"> 3.5.1 static_cast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#352-dynamic_cast"><span class="nav-text"> 3.5.2 dynamic_cast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#353-const_cast"><span class="nav-text"> 3.5.3 const_cast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#354-reinterpret_cast"><span class="nav-text"> 3.5.4 reinterpret_cast</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-storage-class-specifiers"><span class="nav-text"> 3.6 Storage Class Specifiers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#361-static"><span class="nav-text"> 3.6.1 static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#362-extern"><span class="nav-text"> 3.6.2 extern</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3621-shared-global-variable"><span class="nav-text"> 3.6.2.1 Shared Global Variable</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#363-thread_local"><span class="nav-text"> 3.6.3 thread_local</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3631-initialization"><span class="nav-text"> 3.6.3.1 Initialization</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-inheritance-and-polymorphism"><span class="nav-text"> 3.7 Inheritance and Polymorphism</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#371-inheritance-modes"><span class="nav-text"> 3.7.1 Inheritance Modes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#372-virtual"><span class="nav-text"> 3.7.2 virtual</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3721-virtual-destructor"><span class="nav-text"> 3.7.2.1 virtual destructor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#373-final"><span class="nav-text"> 3.7.3 final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#374-override"><span class="nav-text"> 3.7.4 override</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-constexpr"><span class="nav-text"> 3.8 constexpr</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#381-if-constexpr"><span class="nav-text"> 3.8.1 if constexpr</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-static_assert"><span class="nav-text"> 3.9 static_assert</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#310-noexcept"><span class="nav-text"> 3.10 noexcept</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3101-destructor"><span class="nav-text"> 3.10.1 destructor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#311-throw-and-error"><span class="nav-text"> 3.11 throw and error</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#312-placement-new"><span class="nav-text"> 3.12 placement new</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-syntax"><span class="nav-text"> 4 Syntax</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#41-initialization"><span class="nav-text"> 4.1 Initialization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#411-initialization-types"><span class="nav-text"> 4.1.1 Initialization Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#412-initialization-of-static-local-variables"><span class="nav-text"> 4.1.2 Initialization of static Local Variables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#413-list-initialization"><span class="nav-text"> 4.1.3 List-initialization</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4131-aggregate-initialization"><span class="nav-text"> 4.1.3.1 Aggregate initialization</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-pointer"><span class="nav-text"> 4.2 Pointer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#421-multi-dimensional-pointer"><span class="nav-text"> 4.2.1 Multi-dimensional Pointer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-reference"><span class="nav-text"> 4.3 Reference</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#431-reference-initialization"><span class="nav-text"> 4.3.1 Reference Initialization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-class"><span class="nav-text"> 4.4 Class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#441-member-initializer-list"><span class="nav-text"> 4.4.1 Member Initializer List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#442-initialization-order-of-class-members"><span class="nav-text"> 4.4.2 Initialization Order of Class Members</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#443-initialization-of-non-static-class-members"><span class="nav-text"> 4.4.3 Initialization of non-static Class Members</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#444-how-to-define-static-members-in-a-class"><span class="nav-text"> 4.4.4 How to define static members in a class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#445-non-static-members-of-a-class-cannot-undergo-type-deduction"><span class="nav-text"> 4.4.5 Non-static members of a Class cannot undergo type deduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#446-member-function-pointer"><span class="nav-text"> 4.4.6 Member Function Pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#447-mock-class"><span class="nav-text"> 4.4.7 Mock class</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-operator-overloading"><span class="nav-text"> 4.5 Operator Overloading</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#451-stdforward-cannot-convert-brace-enclosed-initializer-list"><span class="nav-text"> 4.5.1 std::forward cannot convert brace-enclosed initializer list</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-variadic-arguments"><span class="nav-text"> 4.6 Variadic Arguments</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#461-how-to-forward-variadic-arguments"><span class="nav-text"> 4.6.1 How to forward variadic arguments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#462-implicit-type-conversion"><span class="nav-text"> 4.6.2 Implicit Type Conversion</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-attributes"><span class="nav-text"> 4.7 Attributes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#471-aligned"><span class="nav-text"> 4.7.1 aligned</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#472-reference"><span class="nav-text"> 4.7.2 Reference</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-asm"><span class="nav-text"> 4.8 ASM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#481-basic-asm"><span class="nav-text"> 4.8.1 Basic Asm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#482-extended-asm"><span class="nav-text"> 4.8.2 Extended Asm</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49-lambda"><span class="nav-text"> 4.9 Lambda</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#491-stdfunction-and-lambda"><span class="nav-text"> 4.9.1 std::function and Lambda</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#492-how-lambda-capture-itself"><span class="nav-text"> 4.9.2 How lambda capture itself</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#493-c-stype-function-pointer"><span class="nav-text"> 4.9.3 C-Stype function pointer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#410-coroutine"><span class="nav-text"> 4.10 Coroutine</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4101-overview-of-promise_type"><span class="nav-text"> 4.10.1 Overview of promise_type</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#41011-awaiter"><span class="nav-text"> 4.10.1.1 Awaiter</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4102-example"><span class="nav-text"> 4.10.2 Example</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-template"><span class="nav-text"> 5 template</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#51-template-category"><span class="nav-text"> 5.1 Template category</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#511-examples"><span class="nav-text"> 5.1.1 Examples</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-template-parameter"><span class="nav-text"> 5.2 Template parameter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-template-argument"><span class="nav-text"> 5.3 Template argument</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54-parameter-pack"><span class="nav-text"> 5.4 Parameter pack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#541-fold-expressions"><span class="nav-text"> 5.4.1 Fold Expressions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#542-traverse-parameter-pack"><span class="nav-text"> 5.4.2 Traverse Parameter Pack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5421-parenthesis-initializer"><span class="nav-text"> 5.4.2.1 Parenthesis Initializer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5422-constexpr-for"><span class="nav-text"> 5.4.2.2 constexpr for</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55-template-specialization"><span class="nav-text"> 5.5 template specialization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#551-explicit-full-template-specialization"><span class="nav-text"> 5.5.1 Explicit (full) template specialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#552-partial-template-specialization"><span class="nav-text"> 5.5.2 Partial template specialization</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5521-members-of-partial-specializations"><span class="nav-text"> 5.5.2.1 Members of partial specializations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5522-how-to-use-stdenable_if-in-partial-specialization"><span class="nav-text"> 5.5.2.2 How to use std::enable_if in partial specialization</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56-when-template-parameters-cannot-be-deduced"><span class="nav-text"> 5.6 When template parameters cannot be deduced</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#57-using-typename-to-disambiguate"><span class="nav-text"> 5.7 Using typename to Disambiguate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58-using-template-to-disambiguate"><span class="nav-text"> 5.8 Using template to Disambiguate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59-defining-a-type-alias-in-a-template-parameter-list"><span class="nav-text"> 5.9 Defining a type alias in a template parameter list</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#510-accessing-members-of-a-template-parent-class-from-a-non-template-derived-class"><span class="nav-text"> 5.10 Accessing members of a template parent class from a non-template derived class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#511-accessing-members-of-a-template-parent-class-from-a-template-derived-class"><span class="nav-text"> 5.11 Accessing members of a template parent class from a template derived class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#512-separating-the-definition-and-implementation-of-a-template"><span class="nav-text"> 5.12 Separating the definition and implementation of a template</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5121-hide-template-implementation"><span class="nav-text"> 5.12.1 Hide template implementation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#513-crtp"><span class="nav-text"> 5.13 CRTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5131-static-polymorphism"><span class="nav-text"> 5.13.1 Static Polymorphism</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5132-object-counter"><span class="nav-text"> 5.13.2 Object Counter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5133-polymorphic-chaining"><span class="nav-text"> 5.13.3 Polymorphic Chaining</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5134-polymorphic-copy-construction"><span class="nav-text"> 5.13.4 Polymorphic Copy Construction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#514-pimpl"><span class="nav-text"> 5.14 PIMPL</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-memory-model"><span class="nav-text"> 6 Memory Model</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#61-concepts"><span class="nav-text"> 6.1 Concepts</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#611-cache-coherence-memory-consistency"><span class="nav-text"> 6.1.1 Cache coherence &amp; Memory consistency</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#612-happens-before"><span class="nav-text"> 6.1.2 Happens-before</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-memory-consistency-model"><span class="nav-text"> 6.2 Memory consistency model</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#621-sequential-consistency-model"><span class="nav-text"> 6.2.1 Sequential consistency model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#622-relaxed-consistency-model"><span class="nav-text"> 6.2.2 Relaxed consistency model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#623-total-store-order"><span class="nav-text"> 6.2.3 Total Store Order</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63-stdmemory_order"><span class="nav-text"> 6.3 std::memory_order</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-cases"><span class="nav-text"> 6.4 Cases</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#641-case-1-happens-before"><span class="nav-text"> 6.4.1 Case-1-happens-before</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#642-case-2-write-read-reorder"><span class="nav-text"> 6.4.2 Case-2-write-read-reorder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#643-case-3-write-write-read-read-reorder"><span class="nav-text"> 6.4.3 Case-3-write-write-read-read-reorder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#644-case-4-write-order-consistency"><span class="nav-text"> 6.4.4 Case-4-write-order-consistency</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#645-case-5-visibility"><span class="nav-text"> 6.4.5 Case-5-visibility</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#646-case-6-eventual-consistency"><span class="nav-text"> 6.4.6 Case-6-eventual-consistency</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#65-x86-memory-model"><span class="nav-text"> 6.5 x86 Memory Model</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#66-reference"><span class="nav-text"> 6.6 Reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-mechanism"><span class="nav-text"> 7 Mechanism</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#71-lvalue-rvalue"><span class="nav-text"> 7.1 lvalue &amp; rvalue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72-move-semantics"><span class="nav-text"> 7.2 Move Semantics</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#73-structured-bindings"><span class="nav-text"> 7.3 Structured Bindings</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#74-copy-elision"><span class="nav-text"> 7.4 Copy Elision</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#75-implicit-type-conversions"><span class="nav-text"> 7.5 Implicit Type Conversions</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-policy"><span class="nav-text"> 8 Policy</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#81-pointer-stability"><span class="nav-text"> 8.1 Pointer Stability</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#82-exception-safe"><span class="nav-text"> 8.2 Exception Safe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#83-raii"><span class="nav-text"> 8.3 RAII</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#831-destructor-behavior"><span class="nav-text"> 8.3.1 Destructor Behavior</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-best-practice"><span class="nav-text"> 9 Best Practice</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#91-visitor"><span class="nav-text"> 9.1 Visitor</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-tips"><span class="nav-text"> 10 Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#101-how-to-choose-function-parameter-type"><span class="nav-text"> 10.1 How to Choose Function Parameter Type</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1011-how-to-choose-constructor-parameter-type"><span class="nav-text"> 10.1.1 How to Choose Constructor Parameter Type</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#102-variable-length-array"><span class="nav-text"> 10.2 Variable-length Array</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-faq"><span class="nav-text"> 11 FAQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#111-why-is-it-unnecessary-to-specify-the-size-when-releasing-memory-with-free-and-delete"><span class="nav-text"> 11.1 Why is it unnecessary to specify the size when releasing memory with free and delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#112-do-parameter-types-require-lvalue-or-rvalue-references"><span class="nav-text"> 11.2 Do parameter types require lvalue or rvalue references</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#113-does-the-return-type-require-lvalue-or-rvalue-references"><span class="nav-text"> 11.3 Does the return type require lvalue or rvalue references</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-reference"><span class="nav-text"> 12 Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liuyehcf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Liuyehcf</p>
  <div class="site-description" itemprop="description">大音希声，大象无形</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">285</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liuyehcf</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qhEhLuMeMOy1zgcBhkqUS6P8-gzGzoHsz',
      appKey     : 'uhkruDLNLNdL5rQjRBY2X9Ke',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
