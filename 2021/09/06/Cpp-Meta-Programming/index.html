<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="阅读更多">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp-Meta-Programming">
<meta property="og:url" content="http://example.com/2021/09/06/Cpp-Meta-Programming/index.html">
<meta property="og:site_name" content="Liuye Notebook">
<meta property="og:description" content="阅读更多">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-09-06T01:20:53.000Z">
<meta property="article:modified_time" content="2025-04-03T15:30:58.000Z">
<meta property="article:author" content="Liuyehcf">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/09/06/Cpp-Meta-Programming/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Cpp-Meta-Programming | Liuye Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Liuye Notebook</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-explore">

    <a href="/explore/" rel="section"><i class="fa fa-sitemap fa-fw"></i>发现</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/06/Cpp-Meta-Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Liuyehcf">
      <meta itemprop="description" content="大音希声，大象无形">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liuye Notebook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Cpp-Meta-Programming
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-06 09:20:53" itemprop="dateCreated datePublished" datetime="2021-09-06T09:20:53+08:00">2021-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-03 23:30:58" itemprop="dateModified" datetime="2025-04-03T23:30:58+08:00">2025-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          
            <span id="/2021/09/06/Cpp-Meta-Programming/" class="post-meta-item leancloud_visitors" data-flag-title="Cpp-Meta-Programming" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/06/Cpp-Meta-Programming/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/06/Cpp-Meta-Programming/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>阅读更多</strong></p>
<span id="more"></span>
<p><strong>本文转载摘录自<a target="_blank" rel="noopener" href="https://bot-man-jl.github.io/articles/?post=2017/Cpp-Metaprogramming#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%83%E7%BC%96%E7%A8%8B">浅谈 C++ 元编程</a></strong></p>
<h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1 Introduction</h1>
<h2 id="11-what-is-metaprogramming"><a class="markdownIt-Anchor" href="#11-what-is-metaprogramming"></a> 1.1 What is Metaprogramming</h2>
<p><strong>Metaprogramming calculates the constants, types, and code needed at runtime by manipulating program entities at compile time.</strong></p>
<p>In general programming, a program is directly written, compiled by a compiler, which produces target code for execution at runtime. Unlike regular programming, metaprogramming uses the template mechanism provided by the language, allowing the compiler to deduce and generate programs at compile time. The program deduced by metaprogramming is then further compiled by the compiler to produce the final target code.</p>
<p>Thus, metaprogramming is also known as two-level programming, generative programming, or template metaprogramming.</p>
<h2 id="12-the-position-of-metaprogramming-in-c"><a class="markdownIt-Anchor" href="#12-the-position-of-metaprogramming-in-c"></a> 1.2 The Position of Metaprogramming in C++</h2>
<p><strong><code>C++</code> Language = Superset of C Language + Abstraction Mechanisms + Standard Library</strong></p>
<p><strong><code>C++</code> has two main abstraction mechanisms:</strong></p>
<ol>
<li>Object-Oriented Programming</li>
<li>Template Programming</li>
</ol>
<p>To support object-oriented programming, <code>C++</code> provides classes that allow new types to be constructed from existing types in <code>C++</code>. In the area of template programming, <code>C++</code> provides templates, which represent general concepts in an intuitive way.</p>
<p><strong>There are two main applications of template programming:</strong></p>
<ol>
<li>Generic Programming</li>
<li>Metaprogramming</li>
</ol>
<p>The former focuses on the abstraction of general concepts, designing generic types or algorithms without needing to be overly concerned about how the compiler generates specific code.</p>
<p>The latter focuses on selection and iteration during template deduction, designing programs using template techniques.</p>
<h2 id="13-history-of-c-metaprogramming"><a class="markdownIt-Anchor" href="#13-history-of-c-metaprogramming"></a> 1.3 History of C++ Metaprogramming</h2>
<h2 id="14-language-support-for-metaprogramming"><a class="markdownIt-Anchor" href="#14-language-support-for-metaprogramming"></a> 1.4 Language Support for Metaprogramming</h2>
<p><code>C++</code> metaprogramming primarily relies on the template mechanism provided by the language. In addition to templates, modern <code>C++</code> also allows the use of <code>constexpr</code> functions for constant calculations. Due to the limited functionality of <code>constexpr</code> functions, recursion depth and the number of calculations are still constrained by the compiler, and compile-time performance is relatively poor. Therefore, most current metaprogramming programs are based on templates. <strong>This section mainly summarizes the foundational language features related to the <code>C++</code> template mechanism, including narrowly defined templates and generic <code>lambda</code> expressions.</strong></p>
<h3 id="141-narrow-templates"><a class="markdownIt-Anchor" href="#141-narrow-templates"></a> 1.4.1 Narrow Templates</h3>
<p><strong>The latest version of <code>C++</code> currently divides templates into four categories:</strong></p>
<ol>
<li>Class templates</li>
<li>Function templates</li>
<li>Alias templates</li>
<li>Variable templates</li>
</ol>
<p>The first two can generate new types and are considered type constructors, while the latter two are shorthand notations added by <code>C++</code> to simplify the former.</p>
<p>Class templates and function templates are used to define classes and functions with similar functionalities, abstracting types and algorithms in generic programming. In the standard library, containers and functions are applications of class templates and function templates.</p>
<p>Alias templates and variable templates were introduced in <code>C++11</code> and <code>C++14</code>, respectively, providing shorthand notation for type aliases and constants with template features. The former can implement methods such as nested classes in class templates, while the latter can be achieved through <code>constexpr</code> functions, static members of class templates, and function template return values. For example, the alias template <code>std::enable_if_t&lt;T&gt;</code> in <code>C++14</code> is equivalent to <code>typename std::enable_if&lt;T&gt;::type</code>, and the variable template <code>std::is_same&lt;T, U&gt;</code> in <code>C++17</code> is equivalent to <code>std::is_same&lt;T, U&gt;::value</code>. Although these two types of templates are not necessary, they can enhance code readability and improve template compilation performance.</p>
<p><strong>There are three types of template parameters in <code>C++</code>:</strong></p>
<ol>
<li>Value parameters</li>
<li>Type parameters</li>
<li>Template parameters</li>
</ol>
<p>Since <code>C++11</code>, <code>C++</code> has supported variadic templates, where the number of template parameters can be indefinite. Variadic parameters are folded into a parameter pack, and during usage, each parameter is iterated at compile time. The standard library’s tuple, <code>std::tuple</code>, is an application of variadic templates (the tuple’s type parameters are variable-length and can be matched using <code>template&lt;typename... Ts&gt;</code>).</p>
<p>Although template parameters can be passed as general type parameters (a template is also a type), they are distinguished separately because they allow parameter matching for the passed-in template. Code 8 uses <code>std::tuple</code> as a parameter, and through matching, extracts the variadic parameters inside <code>std::tuple</code>.</p>
<p>Specialization is similar to function overloading, providing a template implementation for all template parameter values or some template parameter values. Instantiation is akin to function binding, where the compiler determines which overload to use based on the number and type of parameters. Since functions and templates have similarities in overloading, their parameter overloading rules are also similar.</p>
<h3 id="142-generic-lambda-expressions"><a class="markdownIt-Anchor" href="#142-generic-lambda-expressions"></a> 1.4.2 Generic Lambda Expressions</h3>
<p>Since <code>C++</code> does not allow templates to be defined within functions, sometimes it’s necessary to define a template outside a function to achieve specific local functionality within the function. On one hand, this leads to a loose code structure, making maintenance difficult; on the other, using templates requires passing specific context, which reduces reusability (similar to the callback mechanism in C, where a callback function cannot be defined within a function and must pass context through parameters).</p>
<p>To address this, <code>C++14</code> introduced generic lambda expressions, which, on one hand, allow constructing closures within functions like the <code>lambda</code> expressions introduced in <code>C++11</code>, avoiding the need to define local functionality used within the function outside the function. On the other hand, they enable the functionality of function templates, allowing parameters of any type to be passed.</p>
<h1 id="2-basic-operations-of-metaprogramming"><a class="markdownIt-Anchor" href="#2-basic-operations-of-metaprogramming"></a> 2 Basic Operations of Metaprogramming</h1>
<p>The template mechanism in <code>C++</code> only provides a pure functional approach, meaning it does not support variables, and all deduction must be completed at compile time. However, the templates provided in <code>C++</code> are Turing complete (<code>turing complete</code>), so it is possible to use templates to implement full metaprogramming.</p>
<p>There are two basic calculus rules for metaprogramming:</p>
<ol>
<li>Compile-time testing</li>
<li>Compile-time iteration</li>
</ol>
<p>These respectively implement selection and iteration in control structures. Based on these two basic calculus methods, more complex calculations can be achieved.</p>
<p>Additionally, metaprogramming often uses template parameters to pass different policies, allowing for dependency injection and inversion of control. For example, <code>std::vector&lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt;</code> allows passing an <code>Allocator</code> to implement custom memory allocation.</p>
<h2 id="21-compile-time-testing"><a class="markdownIt-Anchor" href="#21-compile-time-testing"></a> 2.1 Compile-Time Testing</h2>
<p>Compile-time testing is equivalent to the selection statement in procedural programming, allowing the implementation of <code>if-else/switch</code> selection logic.</p>
<p>Before <code>C++17</code>, compile-time testing was achieved through template instantiation and specialization, where the most specific template would be matched each time. <code>C++17</code> introduced a new method for compile-time testing using <code>constexpr-if</code>.</p>
<h3 id="211-testing-expressions"><a class="markdownIt-Anchor" href="#211-testing-expressions"></a> 2.1.1 Testing Expressions</h3>
<p>Similar to static assertions, the object of compile-time testing is a constant expression, an expression whose result can be determined at compile time. By using different constant expressions as parameters, various required template overloads can be constructed. For example, Code 1 demonstrates how to construct a predicate <code>isZero&lt;Val&gt;</code> to determine at compile time whether <code>Val</code> is <code>0</code>.</p>
<p><strong>Code 1:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> Val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_isZero</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_isZero</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> Val&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> isZero = _isZero&lt;Val&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(!isZero&lt;<span class="number">1</span>&gt;, <span class="string">&quot;compile error&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(isZero&lt;<span class="number">0</span>&gt;, <span class="string">&quot;compile error&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="212-testing-types"><a class="markdownIt-Anchor" href="#212-testing-types"></a> 2.1.2 Testing Types</h3>
<p><strong>In many metaprogramming applications, type testing is required, where different functionality is implemented for different types. Common type tests fall into two categories:</strong></p>
<ul>
<li><strong>Checking if a type is a specific type:</strong>
<ul>
<li>This can be achieved directly through template specialization.</li>
</ul>
</li>
<li><strong>Checking if a type meets certain conditions:</strong>
<ul>
<li>This can be done through the “Substitution Failure Is Not An Error” rule (<code>SFINAE</code>), which ensures optimal matching.</li>
<li>Tag dispatch can also be used to match enumerable finite cases (for example, <code>std::advance&lt;Iter&gt;</code> selects an implementation based on <code>std::iterator_traits&lt;Iter&gt;::iterator_category</code> for the iterator type <code>Iter</code>).</li>
</ul>
</li>
</ul>
<p><strong>To better support <code>SFINAE</code>, <code>C++11</code>’s <code>&lt;type_traits&gt;</code> provides predicate templates <code>is_*/has_*</code> for type checking and two additional helpful templates:</strong></p>
<ol>
<li><code>std::enable_if</code> converts condition checks into constant expressions, similar to the “Test Expression” section’s overload selection (though it requires an extra function parameter, function return type, or template parameter).</li>
<li><code>std::void_t</code> directly checks for the existence of dependent members/functions; if they do not exist, overload resolution fails (it can be used to construct predicates, then conditions can be checked with <code>std::enable_if</code>).</li>
</ol>
<p>For type-specific checks, similar to Code 1, change <code>unsigned Val</code> to <code>typename Type</code> and convert the template parameter from a value parameter to a type parameter, then match the overload according to the optimal match principle.</p>
<p>For condition-based type checks, Code 2 demonstrates how to convert basic C language data types to <code>std::string</code> in the <code>ToString</code> function. The code is divided into three parts:</p>
<ol>
<li>First, three variable templates <code>isNum/isStr/isBad</code> are defined, each corresponding to a predicate for three type conditions (using <code>std::is_arithmetic</code> and <code>std::is_same</code> from <code>&lt;type_traits&gt;</code>).</li>
<li>Then, based on the <code>SFINAE</code> rule, <code>std::enable_if</code> is used to overload the function <code>ToString</code>, each corresponding to numerical, C-style string, and invalid types.</li>
<li>In the first two overloads, <code>std::to_string</code> and <code>std::string</code> constructors are called, respectively; in the last overload, a static assertion immediately raises an error.</li>
</ol>
<p><strong>Code 2:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> isNum = std::is_arithmetic&lt;T&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> isStr = std::is_same&lt;T, <span class="type">const</span> <span class="type">char</span> *&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> isBad = !isNum&lt;T&gt; &amp;&amp; !isStr&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;isNum&lt;T&gt;, std::string&gt; <span class="built_in">ToString</span>(T num) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">to_string</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;isStr&lt;T&gt;, std::string&gt; <span class="built_in">ToString</span>(T str) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">string</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="type">enable_if_t</span>&lt;isBad&lt;T&gt;, std::string&gt; <span class="built_in">ToString</span>(T bad) &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(T) == <span class="number">0</span>, <span class="string">&quot;neither Num nor Str&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">ToString</span>(<span class="number">1</span>);  <span class="comment">// std::to_string (num);</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">ToString</span>(<span class="number">1.0</span>);  <span class="comment">// std::to_string (num);</span></span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">ToString</span>(<span class="string">&quot;0x0&quot;</span>);  <span class="comment">// std::string (str);</span></span><br><span class="line"><span class="keyword">auto</span> d = <span class="built_in">ToString</span>(std::string &#123;&#125;);  <span class="comment">// not compile :-(</span></span><br></pre></td></tr></table></figure>
<p>According to the rule of two-phase name lookup, directly using <code>static_assert(false)</code> would cause a compilation failure in the first phase, before the template is instantiated. Therefore, a type-dependent <code>false</code> expression (typically dependent on the parameter <code>T</code>) is required for a failing static assertion.</p>
<p>Similarly, a variable template can be defined as <code>template &lt;typename...&gt; constexpr bool false_v = false</code>, and <code>false_v&lt;T&gt;</code> can be used in place of <code>sizeof(T) == 0</code>.</p>
<h3 id="213-using-if-for-compile-time-testing"><a class="markdownIt-Anchor" href="#213-using-if-for-compile-time-testing"></a> 2.1.3 Using if for Compile-Time Testing</h3>
<p>For those new to metaprogramming, it’s common to try using an <code>if</code> statement for compile-time testing. Code 3 is an incorrect version of Code 2, which serves as a representative example of the differences between metaprogramming and regular programming.</p>
<p><strong>Code 3:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::string <span class="title">ToString</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNum&lt;T&gt;)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">to_string</span>(val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isStr&lt;T&gt;)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">string</span>(val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">static_assert</span>(!isBad&lt;T&gt;, <span class="string">&quot;neither Num nor Str&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The error in Code 3 lies in the function <code>ToString</code>’s compilation. For a given type <code>T</code>, the function needs to perform two function bindings: <code>val</code> is passed as an argument to both <code>std::to_string(val)</code> and <code>std::string(val)</code>, and then a static assertion checks whether <code>!isBad&lt;T&gt;</code> is <code>true</code>. This causes an issue: one of the two bindings will fail. For instance, if <code>ToString(&quot;str&quot;)</code> is called, during compilation, <code>std::string(const char *)</code> can be correctly overloaded, but <code>std::to_string(const char *)</code> cannot find a proper overload, leading to a compilation failure.</p>
<p>If this were a scripting language, this code would be fine because scripting languages lack the concept of compilation; all function bindings are performed at runtime. However, in a statically-typed language, function binding is completed at compile time. To allow Code 3’s style to be used in metaprogramming, <code>C++17</code> introduced <code>constexpr-if</code>, where simply replacing <code>if</code> with <code>if constexpr</code> in Code 3 allows it to compile.</p>
<p>The introduction of <code>constexpr-if</code> makes template testing more intuitive, improving the readability of template code. Code 4 demonstrates how to use <code>constexpr-if</code> to solve the issue of compile-time selection. Additionally, the catch-all statement no longer requires the <code>isBad&lt;T&gt;</code> predicate template and can use a type-dependent <code>false</code> expression for a static assertion (though a direct <code>static_assert(false)</code> cannot be used).</p>
<p><strong>Code 4:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::string <span class="title">ToString</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(isNum&lt;T&gt;)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="title">std::to_string</span><span class="params">(val)</span></span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (isStr&lt;T&gt;)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">string</span>(val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">static_assert</span>(false_v&lt;T&gt;, <span class="string">&quot;neither Num nor Str&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, the idea behind <code>constexpr-if</code> had already appeared as early as <code>Visual Studio 2012</code>. It introduced the <code>__if_exists</code> statement, which was used for compile-time testing to check whether an identifier exists.</p>
<h2 id="22-compile-time-iteration"><a class="markdownIt-Anchor" href="#22-compile-time-iteration"></a> 2.2 Compile-Time Iteration</h2>
<p>Compile-time iteration is similar to loop statements in procedural programming, allowing logic similar to <code>for/while/do</code> loops.</p>
<p>Before <code>C++17</code>, unlike in regular programming, metaprogramming calculus rules were purely functional, meaning compile-time iteration could not be achieved through variable iteration and instead had to rely on recursion combined with specialization. <strong>The general approach is to provide two types of overloads: one that accepts arbitrary parameters and recursively calls itself internally, and another that is a template specialization or function overload of the former, directly returning the result, effectively serving as the termination condition for recursion. Their overload conditions can be either expressions or types.</strong></p>
<p><code>C++17</code> introduced fold expressions to simplify the syntax for iteration.</p>
<h3 id="221-iterating-over-fixed-length-templates"><a class="markdownIt-Anchor" href="#221-iterating-over-fixed-length-templates"></a> 2.2.1 Iterating over Fixed-Length Templates</h3>
<p>Code 5 demonstrates how to use compile-time iteration to compute the factorial (<code>N!</code>) at compile time. The function <code>_Factor</code> has two overloads: one for any non-negative integer and another for <code>0</code> as the parameter. The former uses recursion to produce results, while the latter directly returns the result. When <code>_Factor&lt;2&gt;</code> is called, the compiler expands it to <code>2 * _Factor&lt;1&gt;</code>, then <code>_Factor&lt;1&gt;</code> expands to <code>1 * _Factor&lt;0&gt;</code>, and finally <code>_Factor&lt;0&gt;</code> directly matches the overload with <code>0</code> as the parameter.</p>
<p><strong>Code 5:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> _Factor() &#123;</span><br><span class="line">    <span class="keyword">return</span> N * _Factor&lt;N - <span class="number">1</span>&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> _Factor&lt;<span class="number">0</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> N&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> Factor = _Factor&lt;N&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(Factor&lt;<span class="number">0</span>&gt; == <span class="number">1</span>, <span class="string">&quot;compile error&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(Factor&lt;<span class="number">1</span>&gt; == <span class="number">1</span>, <span class="string">&quot;compile error&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(Factor&lt;<span class="number">4</span>&gt; == <span class="number">24</span>, <span class="string">&quot;compile error&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="222-iterating-over-variable-length-templates"><a class="markdownIt-Anchor" href="#222-iterating-over-variable-length-templates"></a> 2.2.2 Iterating over Variable-Length Templates</h3>
<p>To iterate through each parameter in a variadic template, compile-time iteration can be used to implement loop traversal. Code 6 implements a function that sums all parameters. The function <code>Sum</code> has two overloads: one for when there are no function parameters, and another for when there is at least one function parameter. Similar to iteration with fixed-length templates, this is also achieved through recursive calls to traverse the parameters.</p>
<p><strong>Code 6:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">Sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">T</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(T arg, Ts... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg + <span class="built_in">Sum</span>&lt;T&gt;(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">Sum</span>&lt;<span class="type">int</span>&gt;() == <span class="number">0</span>, <span class="string">&quot;compile error&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">Sum</span>(<span class="number">1</span>, <span class="number">2.0</span>, <span class="number">3</span>) == <span class="number">6</span>, <span class="string">&quot;compile error&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="223-simplifying-compile-time-iteration-with-fold-expressions"><a class="markdownIt-Anchor" href="#223-simplifying-compile-time-iteration-with-fold-expressions"></a> 2.2.3 Simplifying Compile-Time Iteration with Fold Expressions</h3>
<p>When variadic templates were introduced in <code>C++11</code>, direct syntax for expanding parameter packs within templates was supported; however, this syntax only allowed unary operations on each parameter within the pack. To perform binary operations between parameters, additional templates were necessary (for example, Code 6 defines two <code>Sum</code> function templates, with one expanding the parameter pack to recursively call itself).</p>
<p><code>C++17</code> introduced fold expressions, enabling direct traversal of each parameter within a parameter pack and applying a binary operator to perform either a left fold or right fold. Code 7 improves upon Code 6 by using a left fold expression with an initial value of <code>0</code>.</p>
<p><strong>Code 7:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">Sum</span><span class="params">(Ts... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> + ... + args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">Sum</span>() == <span class="number">0</span>, <span class="string">&quot;compile error&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">Sum</span>(<span class="number">1</span>, <span class="number">2.0</span>, <span class="number">3</span>) == <span class="number">6</span>, <span class="string">&quot;compile error&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="23-metaprogramming-vs-regular-programming"><a class="markdownIt-Anchor" href="#23-metaprogramming-vs-regular-programming"></a> 2.3 Metaprogramming vs. Regular programming</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Concept</th>
<th style="text-align:left">Regular Programming</th>
<th style="text-align:left">Metaprogramming</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Sequence</td>
<td style="text-align:left">Statements in order</td>
<td style="text-align:left">Nested templates, Type deduction</td>
</tr>
<tr>
<td style="text-align:left">Branching</td>
<td style="text-align:left"><code>if</code>, <code>else</code>, <code>switch</code></td>
<td style="text-align:left"><code>std::conditional</code>, <code>constexpr if</code>, <code>SFINAE</code>, template specialization</td>
</tr>
<tr>
<td style="text-align:left">Looping (Iteration)</td>
<td style="text-align:left"><code>for</code>, <code>while</code>, <code>do-while</code></td>
<td style="text-align:left">Recursive templates, template specialization, <code>std::integer_sequence</code></td>
</tr>
</tbody>
</table>
<h1 id="3-basic-applications-of-metaprogramming"><a class="markdownIt-Anchor" href="#3-basic-applications-of-metaprogramming"></a> 3 Basic Applications of Metaprogramming</h1>
<p>Metaprogramming enables the design of type-safe and runtime-efficient programs with ease. Today, metaprogramming is widely applied in <code>C++</code> programming practices. For example, <code>Todd Veldhuizen</code> proposed a metaprogramming approach to construct expression templates, optimizing expressions to improve the runtime speed of vector calculations. Additionally, <code>K. Czarnecki</code> and <code>U. Eisenecker</code> used templates to implement a <code>Lisp</code> interpreter.</p>
<p>Although metaprogramming applications vary, they are combinations of three fundamental types: numeric computation, type deduction, and code generation. For instance, in the <code>ORM</code> (object-relation mapping) designed by <code>BOT Man</code>, type deduction and code generation are primarily used. Based on an object’s type in <code>C++</code>, the types of each field in the corresponding database relation tuple are deduced. Operations on <code>C++</code> objects are mapped to corresponding database statements, generating the relevant code.</p>
<h2 id="31-numerical-computation"><a class="markdownIt-Anchor" href="#31-numerical-computation"></a> 3.1 Numerical Computation</h2>
<p>As one of the earliest applications of metaprogramming, numeric computation can be used for compile-time constant calculation and optimizing runtime expression evaluation.</p>
<p>Compile-time constant calculation allows programmers to use the programming language to define constants at compile time, rather than directly writing constants (magic numbers) or calculating these constants at runtime. For example, Codes 5, 6, and 7 perform compile-time constant calculations.</p>
<p>The earliest concept of using metaprogramming to optimize expression evaluation was proposed by <code>Todd Veldhuizen</code>. By utilizing expression templates, it is possible to implement features such as partial evaluation, lazy evaluation, and expression simplification.</p>
<h2 id="32-type-deduction"><a class="markdownIt-Anchor" href="#32-type-deduction"></a> 3.2 Type Deduction</h2>
<p>Beyond basic numeric computation, metaprogramming can also be used to deduce conversions between arbitrary types. For example, when combining a domain-specific language natively with <code>C++</code>, type deduction can convert types in these languages into <code>C++</code> types while ensuring type safety.</p>
<p><code>BOT Man</code> proposed a method for compile-time tuple type deduction in <code>SQL</code>. Since all data types in <code>C++</code> cannot be <code>NULL</code>, whereas <code>SQL</code> fields can be <code>NULL</code>, fields that may be null are stored in <code>C++</code> using the <code>std::optional</code> container. For tuples resulting from <code>SQL</code> outer joins, where all fields can be <code>NULL</code>, <code>ORM</code> needs a method to convert tuples with fields that may be either <code>std::optional&lt;T&gt;</code> or <code>T</code> into a new tuple where all fields are <code>std::optional&lt;T&gt;</code>.</p>
<p><strong>Code 8:</strong></p>
<ol>
<li>Define <code>TypeToNullable</code>, and specialize it for <code>std::optional&lt;T&gt;</code>. Its purpose is to automatically convert both <code>std::optional&lt;T&gt;</code> and <code>T</code> to <code>std::optional&lt;T&gt;</code>.</li>
<li>Define <code>TupleToNullable</code>, which decomposes all types in a tuple, converts them into a parameter pack, passes each type in the parameter pack to <code>TypeToNullable</code>, and finally reassembles the results into a new tuple.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeToNullable</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = std::optional&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeToNullable</span>&lt;std::optional&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = std::optional&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">TupleToNullable</span><span class="params">(<span class="type">const</span> std::tuple&lt;Args...&gt;&amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::tuple&lt;<span class="keyword">typename</span> TypeToNullable&lt;Args&gt;::type...&gt;&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> t1 = std::<span class="built_in">make_tuple</span>(std::optional&lt;<span class="type">int</span>&gt;&#123;&#125;, <span class="type">int</span>&#123;&#125;);</span><br><span class="line"><span class="keyword">auto</span> t2 = <span class="built_in">TupleToNullable</span>(t1);</span><br><span class="line"><span class="built_in">static_assert</span>(!std::is_same&lt;std::<span class="type">tuple_element_t</span>&lt;<span class="number">0</span>, <span class="keyword">decltype</span>(t1)&gt;, std::<span class="type">tuple_element_t</span>&lt;<span class="number">1</span>, <span class="keyword">decltype</span>(t1)&gt;&gt;::value,</span><br><span class="line">              <span class="string">&quot;compile error&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same&lt;std::<span class="type">tuple_element_t</span>&lt;<span class="number">0</span>, <span class="keyword">decltype</span>(t2)&gt;, std::<span class="type">tuple_element_t</span>&lt;<span class="number">1</span>, <span class="keyword">decltype</span>(t2)&gt;&gt;::value,</span><br><span class="line">              <span class="string">&quot;compile error&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="33-code-generation"><a class="markdownIt-Anchor" href="#33-code-generation"></a> 3.3 Code Generation</h2>
<p>Like generic programming, metaprogramming is often used for code generation. However, unlike simple generic programming, code generated by metaprogramming is often derived through compile-time testing and compile-time iteration. For example, Code 2 generates code that converts basic C language types to <code>std::string</code>.</p>
<p>In real projects, we often need to convert between <code>C++</code> data structures and domain models related to actual business logic. For example, a <code>JSON</code> string representing a domain model might be deserialized into a <code>C++</code> object, further processed by business logic, and then serialized back into a <code>JSON</code> string. Such serialization/deserialization code generally does not need to be manually written and can be automatically generated.</p>
<p><code>BOT Man</code> proposed a method based on compile-time polymorphism that defines a schema for the domain model, automatically generating code for serialization/deserialization between the domain model and <code>C++</code> objects. This allows business logic developers to focus more on handling the business logic without needing to worry about low-level data structure conversions.</p>
<h1 id="4-key-challenges-in-metaprogramming"><a class="markdownIt-Anchor" href="#4-key-challenges-in-metaprogramming"></a> 4 Key Challenges in Metaprogramming</h1>
<p>Despite the rich capabilities of metaprogramming, both learning and using it are quite challenging. On one hand, the complex syntax and calculus rules often deter beginners; on the other, even experienced <code>C++</code> developers can fall into the hidden pitfalls of metaprogramming.</p>
<h2 id="41-complexity"><a class="markdownIt-Anchor" href="#41-complexity"></a> 4.1 Complexity</h2>
<p>Due to significant language-level limitations in metaprogramming, much metaprogramming code relies heavily on compile-time testing and iteration techniques, often resulting in poor readability. Additionally, designing compile-time calculus in an elegant manner is challenging, making the writability of metaprogramming less favorable compared to typical <code>C++</code> programs.</p>
<p>Modern <code>C++</code> continuously introduces features aimed at reducing the complexity of metaprogramming:</p>
<ul>
<li>Alias templates in <code>C++11</code> provide a shorthand for types within templates.</li>
<li>Variable templates in <code>C++14</code> offer a shorthand for constants within templates.</li>
<li><code>constexpr-if</code> in <code>C++17</code> introduces a new syntax for compile-time testing.</li>
<li>Fold expressions in <code>C++17</code> simplify the process of writing compile-time iterations.</li>
</ul>
<p>Based on the generic <code>lambda</code> expressions in <code>C++14</code>, <code>Louis Dionne</code> designed the metaprogramming library <code>Boost.Hana</code>, which proposes metaprogramming without templates, marking the transition from template metaprogramming to modern metaprogramming. The core idea is that using only the generic <code>lambda</code> expressions in <code>C++14</code> and <code>constexpr/decltype</code> from <code>C++11</code> enables the quick implementation of basic metaprogramming calculus.</p>
<h2 id="42-instantiation-errors"><a class="markdownIt-Anchor" href="#42-instantiation-errors"></a> 4.2 Instantiation Errors</h2>
<p>Template instantiation differs from function binding: before compilation, the former imposes few restrictions on the types of parameters passed in, whereas the latter determines the expected parameter types based on the function declaration. Parameter checks for templates occur during instantiation, making it difficult for the program designer to detect potential errors before compilation.</p>
<p>To reduce potential errors, <code>Bjarne Stroustrup</code> and others proposed introducing concepts at the language level for templates. With concepts, restrictions can be placed on parameters, allowing only types that meet specific requirements to be passed into the template. For example, the template <code>std::max</code> could be constrained to accept only types that support the <code>&lt;</code> operator. However, for various reasons, this language feature was not included in the <code>C++</code> standard for a long time (though it may have been added in <code>C++20</code>). Despite this, compile-time testing and static assertions can still provide checks.</p>
<p>Additionally, in the case of template instantiation errors at deeper levels, the compiler reports each level of instantiation, leading to verbose error messages that can obscure the source of the issue. <code>BOT Man</code> proposed a short-circuit compiling method to offer more user-friendly compile-time error messages in metaprogramming libraries. This approach involves having the interface check whether the passed parameters support the required operations before the implementation performs them. If they do not, the interface uses short-circuiting to redirect to an error-reporting interface, stopping compilation and using static assertions to provide error messages. <code>Paul Fultz II</code> proposed a similar approach to concept/constraint interface checks (like those in <code>C++20</code>) by defining trait templates corresponding to concepts and checking if these traits are met before usage.</p>
<h2 id="43-code-bloat"><a class="markdownIt-Anchor" href="#43-code-bloat"></a> 4.3 Code Bloat</h2>
<p>Since templates instantiate for each unique set of template arguments, a large number of parameter combinations can lead to code bloat, resulting in a massive codebase. This code can be divided into two types: dead code and effective code.</p>
<p>In metaprogramming, the focus is often on the final result rather than the process. For example, in Code 5, we only care that <code>Factor&lt;4&gt; == 24</code> and do not need the temporary templates generated during intermediate steps. However, when <code>N</code> is large, compilation produces many temporary templates. These temporary templates are dead code, meaning they are not executed. The compiler automatically optimizes the final code generation by removing these unused codes at link-time, ensuring that the final output does not include them. Nevertheless, generating excessive dead code wastes valuable compilation time.</p>
<p>In other cases, the expanded code is all effective code—meaning it is executed—but the code size remains large due to the wide variety of parameter types needed. The compiler has limited ability to optimize such code, so programmers should design to avoid code bloat. Thin templates are typically used to reduce the size of template instances; the approach is to abstract common parts of templates instantiated with different parameters into shared base classes or functions, with the distinct parts inheriting from the base class or calling the function to enable code sharing.</p>
<p>For example, in the implementation of <code>std::vector</code>, <code>T*</code> and <code>void*</code> are specialized. Then, the implementation for all <code>T*</code> types is inherited from the <code>void*</code> implementation, with public functions using casting to convert between <code>void*</code> and <code>T*</code>. This allows all pointer types in <code>std::vector</code> to share a single implementation, avoiding code bloat (Code 9).</p>
<p><strong>Code 9:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>; <span class="comment">// general</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&lt;T*&gt;; <span class="comment">// partial spec</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&lt;<span class="type">void</span>*&gt;; <span class="comment">// complete spec</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&lt;T*&gt; : <span class="keyword">private</span> vector&lt;<span class="type">void</span>*&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> Base = Vector&lt;<span class="type">void</span>∗&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T∗&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;T∗&amp;&gt;(Base::<span class="keyword">operator</span>[](i));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="44-compile-time-performance"><a class="markdownIt-Anchor" href="#44-compile-time-performance"></a> 4.4 Compile-Time Performance</h2>
<p>Although metaprogramming does not add runtime overhead, excessive use can significantly increase compilation time, especially in large projects. Optimizing metaprogramming compile-time performance requires special techniques.</p>
<p>According to the One Definition Rule, a template can be instantiated with the same parameters across multiple translation units and merged into a single instance at link time. However, template operations in each translation unit are independent, which increases compilation time and produces excessive intermediate code. Explicit instantiation is commonly used to avoid repeated template instantiations. The approach is to explicitly define a template instance in one translation unit and declare the same instance with <code>extern</code> in other translation units. This method, which separates interface from implementation, is also commonly used for template interfaces in static libraries.</p>
<p><code>Chiel Douwes</code> conducted an in-depth analysis of common template operations in metaprogramming, comparing the costs of several template operations (Cost of operations: The Rule of Chiel) from highest to lowest (without considering <code>C++14</code> variable templates):</p>
<ol>
<li>Substitution Failure Is Not An Error (<code>SFINAE</code>)</li>
<li>Instantiating function templates</li>
<li>Instantiating class templates</li>
<li>Using alias templates</li>
<li>Adding parameters to class templates</li>
<li>Adding parameters to alias templates</li>
<li>Using cached types</li>
</ol>
<p>Following these principles, <code>Odin Holmes</code> designed the type manipulation library <code>Kvasir</code>, which achieves high compilation performance compared to type manipulation libraries based on <code>C++98/11</code>. To measure the effectiveness of compilation performance optimizations, <code>Louis Dionne</code> developed a CMake-based compile-time benchmarking framework.</p>
<p>Additionally, <code>Mateusz Pusz</code> shared some best practices for metaprogramming performance. For example, <code>std::conditional_t</code> based on <code>C++11</code> alias templates and <code>std::is_same_v</code> based on <code>C++14</code> variable templates are faster than the traditional <code>std::conditional/std::is_same</code> approach. Code 10 demonstrates implementations using <code>std::is_same</code> and the variable template-based <code>std::is_same_v</code>.</p>
<p><strong>Code 10:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// traditional, slow</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_same</span> : std::false_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_same</span>&lt;T, T&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_same_v = is_same&lt;T, U&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using variable template, fast</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_same_v = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_same_v&lt;T, T&gt; = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h2 id="45-debugging-templates"><a class="markdownIt-Anchor" href="#45-debugging-templates"></a> 4.5 Debugging Templates</h2>
<p>The primary runtime challenge in metaprogramming is debugging template code. When debugging code that has undergone extensive compile-time testing and compile-time iteration—meaning the code is a concatenation of various templates with many levels of expansion—one must frequently switch back and forth between template instances during debugging. In such cases, it is difficult for the debugger to pinpoint the issue within the expanded code.</p>
<p>As a result, some large projects avoid complex code generation techniques and instead use traditional code generators to produce repetitive code that is easier to debug. For example, <code>Chromium</code>’s common extension API defines <code>JSON/IDL</code> files, which a code generator uses to produce the relevant <code>C++</code> code and simultaneously generate interface documentation.</p>
<h1 id="5-summary"><a class="markdownIt-Anchor" href="#5-summary"></a> 5 Summary</h1>
<p>The emergence of <code>C++</code> metaprogramming was a serendipitous discovery: people realized that the template abstraction mechanism provided by <code>C++</code> could be effectively applied to metaprogramming. With metaprogramming, it’s possible to write type-safe and runtime-efficient code. However, excessive use of metaprogramming can increase compilation time and reduce code readability. Nevertheless, as <code>C++</code> continues to evolve, new language features are consistently introduced, offering more possibilities for metaprogramming.</p>
<h1 id="6-applications-of-metaprogramming"><a class="markdownIt-Anchor" href="#6-applications-of-metaprogramming"></a> 6 Applications of Metaprogramming</h1>
<h2 id="61-utility"><a class="markdownIt-Anchor" href="#61-utility"></a> 6.1 Utility</h2>
<h3 id="611-is_same"><a class="markdownIt-Anchor" href="#611-is_same"></a> 6.1.1 is_same</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_same</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_same</span>&lt;T, T&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="612-rank"><a class="markdownIt-Anchor" href="#612-rank"></a> 6.1.2 rank</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rank</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> <span class="type">const</span> value = <span class="number">0u</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rank</span>&lt;U[N]&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> <span class="type">const</span> value = <span class="number">1u</span> + rank&lt;U&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">array_t</span> = <span class="type">int</span>[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>];</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rank=&quot;</span> &lt;&lt; rank&lt;<span class="type">array_t</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can also use <code>std::integral_constant</code> to achieve the functionality described above.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Default version</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rank</span> : std::integral_constant&lt;<span class="type">size_t</span>, <span class="number">0</span>&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rank</span>&lt;U[N]&gt; : std::integral_constant&lt;<span class="type">size_t</span>, <span class="number">1</span> + rank&lt;U&gt;::value&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">array_t</span> = <span class="type">int</span>[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>];</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rank=&quot;</span> &lt;&lt; rank&lt;<span class="type">array_t</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="613-one_oftype_invalue_in"><a class="markdownIt-Anchor" href="#613-one_oftype_invalue_in"></a> 6.1.3 one_of/type_in/value_in</h3>
<p>Here is the implementation approach for <code>is_one_of</code>:</p>
<ul>
<li>First, define the template.</li>
<li><code>base1</code>: Define the single-parameter instantiation version, which serves as the termination state for recursion.</li>
<li><code>base2</code>: Define the instantiation version where the first element matches, also serving as a termination state for recursion.</li>
<li>Define the instantiation version where the first element differs, and implement recursive instantiation through inheritance (during recursion, be mindful to reduce one parameter with each step).</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// declare the interface only</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... P0toN&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_one_of</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// base #1: specialization recognizes empty list of types:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_one_of</span>&lt;T&gt; : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// base #2: specialization recognizes match at head of list of types:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... P1toN&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_one_of</span>&lt;T, T, P1toN...&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// specialization recognizes mismatch at head of list of types:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> P0, <span class="keyword">typename</span>... P1toN&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_one_of</span>&lt;T, P0, P1toN...&gt; : is_one_of&lt;T, P1toN...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; is_one_of&lt;<span class="type">double</span>, <span class="type">double</span>, <span class="type">float</span>, <span class="type">long</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; is_one_of&lt;<span class="type">bool</span>, <span class="type">double</span>, <span class="type">float</span>, <span class="type">long</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can also use <a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/cppreference-language/62e23cda3198622e.md">fold expressions</a> to implement recursive expansion.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> type_in = (std::is_same_v&lt;T, Args&gt; || ...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T v, T... args&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> value_in = ((v == args) || ...);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; type_in&lt;<span class="type">double</span>, <span class="type">double</span>, <span class="type">float</span>, <span class="type">long</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; type_in&lt;<span class="type">bool</span>, <span class="type">double</span>, <span class="type">float</span>, <span class="type">long</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; value_in&lt;<span class="type">int</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; value_in&lt;<span class="type">int</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="614-is_copy_assignable"><a class="markdownIt-Anchor" href="#614-is_copy_assignable"></a> 6.1.4 is_copy_assignable</h3>
<p>Let’s manually implement <code>std::is_copy_assignable</code> from the <code>&lt;type_traits&gt;</code> header, which is used to check if a class supports the copy assignment operator.</p>
<p>Example implementation steps and explanation:</p>
<ul>
<li><code>std::declval&lt;T&gt;</code> is used to return a <code>T&amp;&amp;</code> type (refer to the reference collapsing rules).</li>
<li>The function template <code>try_assignment(U&amp;&amp;)</code> has two type parameters, where the second type parameter is unused (its name is omitted) and has a default value of <code>typename = decltype(std::declval&lt;U&amp;&gt;() = std::declval&lt;U const&amp;&gt;())</code>. This part tests whether the specified type supports the copy assignment operation. If the type does not support it, the instantiation of the <code>try_assignment(U&amp;&amp;)</code> template will fail, and it will fall back to the default version <code>try_assignment(...)</code>. <strong>This is the well-known <code>SFINAE, Substitution Failure Is Not An Error</code>.</strong>
<ul>
<li>For implementing <code>is_copy_constructible</code>, <code>is_move_constructible</code>, or <code>is_move_assignable</code>, a similar approach can be used by replacing the expression in this part.</li>
</ul>
</li>
<li><code>try_assignment(...)</code> is an overload that can match any number and type of arguments.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_copy_assignable</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> = <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;U&amp;&gt;() = std::<span class="built_in">declval</span>&lt;U <span class="type">const</span>&amp;&gt;())&gt;</span><br><span class="line">    <span class="type">static</span> std::true_type <span class="built_in">try_assignment</span>(U&amp;&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::false_type <span class="title">try_assignment</span><span class="params">(...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">decltype</span>(<span class="built_in">try_assignment</span>(std::<span class="built_in">declval</span>&lt;T&gt;()));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SupportCopyAssignment</span> &#123;</span><br><span class="line">    <span class="built_in">SupportCopyAssignment</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">SupportCopyAssignment</span>(<span class="type">const</span> SupportCopyAssignment&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">SupportCopyAssignment</span>(SupportCopyAssignment&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SupportCopyAssignment&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SupportCopyAssignment&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    SupportCopyAssignment&amp; <span class="keyword">operator</span>=(SupportCopyAssignment&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NoSupportCopyAssignment</span> &#123;</span><br><span class="line">    <span class="built_in">NoSupportCopyAssignment</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">NoSupportCopyAssignment</span>(<span class="type">const</span> NoSupportCopyAssignment&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">NoSupportCopyAssignment</span>(NoSupportCopyAssignment&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NoSupportCopyAssignment&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NoSupportCopyAssignment&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    NoSupportCopyAssignment&amp; <span class="keyword">operator</span>=(NoSupportCopyAssignment&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; is_copy_assignable&lt;SupportCopyAssignment&gt;::type::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; is_copy_assignable&lt;NoSupportCopyAssignment&gt;::type::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="615-has_type_member"><a class="markdownIt-Anchor" href="#615-has_type_member"></a> 6.1.5 has_type_member</h3>
<p>Let’s implement <code>has_type_member</code>, which checks if a given type has a member type named <code>type</code>, that is, whether <code>typename T::type</code> exists for type <code>T</code>.</p>
<ul>
<li>The <code>primitive</code> version of <code>has_type_member</code> has two type parameters, with the second parameter having a default value of <code>void</code>.</li>
<li><code>std::void_t&lt;T&gt;</code> returns <code>void</code> for any <code>T</code>. For types that have a member type <code>type</code>, this specialized version is <code>well-formed</code>, so it matches this version; for types without a <code>type</code> member, the deduction of the second template parameter fails, falling back to other versions. This also utilizes <code>SFINAE</code>.
<ul>
<li>This example demonstrates an application of <code>std::void_t</code>.</li>
<li>Without <code>std::void_t</code>, <code>has_type_member&lt;T, typename T::type&gt;</code> would not be a specialization of <code>template &lt;typename, typename = void&gt;</code>. These two forms are essentially equivalent, so even if <code>T::type</code> exists, it would still match the default version.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_type_member : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_type_member</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">typename</span> T::type&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithNonVoidMemberType</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithVoidMemberType</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithNonTypeMemberType</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> type = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WithoutMemberType</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; has_type_member&lt;WithNonVoidMemberType&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; has_type_member&lt;WithVoidMemberType&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; has_type_member&lt;WithNonTypeMemberType&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; has_type_member&lt;WithoutMemberType&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="616-has_to_string"><a class="markdownIt-Anchor" href="#616-has_to_string"></a> 6.1.6 has_to_string</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> has_to_string : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_to_string</span>&lt;T, std::<span class="type">void_t</span>&lt;<span class="keyword">decltype</span>(<span class="built_in">to_string</span>(std::<span class="built_in">declval</span>&lt;T&gt;()))&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(Foo <span class="type">const</span>&amp; foo)</span> </span>&#123;</span><br><span class="line">    std::string buffer;</span><br><span class="line">    buffer += <span class="string">&quot;Foo(&quot;</span>;</span><br><span class="line">    buffer += <span class="string">&quot;val=&quot;</span> + std::<span class="built_in">to_string</span>(foo.val);</span><br><span class="line">    buffer += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    foo.val = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(has_to_string&lt;Foo&gt;::value)</span> </span>&#123;</span><br><span class="line">        std::string str = <span class="built_in">to_string</span>(foo);</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">to_string</span>(foo) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="617-sequence"><a class="markdownIt-Anchor" href="#617-sequence"></a> 6.1.7 sequence</h3>
<p><strong>The core idea is as follows:</strong></p>
<ul>
<li><code>gen_seq&lt;N&gt;</code>: Intended to generate <code>seq&lt;0, 1, 2, 3, ..., N-1&gt;</code>.</li>
<li>Use the recursive expansion <code>gen_seq&lt;size_t N, size_t... S&gt;</code>, where <code>N</code> represents the remaining numbers <code>1, 2, 3, ..., N-1</code>, and <code>S...</code> represents the already generated sequence. In each recursive step, place <code>N-1</code> into the sequence on the right. When <code>N = 0</code>, recursion ends.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get_first</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> First, <span class="type">size_t</span>... Others&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">get_first</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> value = First;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get_last</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> First, <span class="type">size_t</span>... Nums&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">get_last</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> First, <span class="type">size_t</span>... Nums&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">get_last</span> : get_last&lt;Nums...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> First&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">get_last</span>&lt;First&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> value = First;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// seq</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>... N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seq</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> size = <span class="keyword">sizeof</span>...(N);</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> first = get_first&lt;N...&gt;::value;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> last = get_last&lt;N...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// seq_gen</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N, <span class="type">size_t</span>... S&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gen_seq</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N, <span class="type">size_t</span>... S&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gen_seq</span> : gen_seq&lt;N - <span class="number">1</span>, N - <span class="number">1</span>, S...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>... S&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gen_seq</span>&lt;<span class="number">0</span>, S...&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = seq&lt;S...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>... S&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">gen_seq_t</span> = <span class="keyword">typename</span> gen_seq&lt;S...&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size=&quot;</span> &lt;&lt; <span class="type">gen_seq_t</span>&lt;<span class="number">100</span>&gt;::size &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;first=&quot;</span> &lt;&lt; <span class="type">gen_seq_t</span>&lt;<span class="number">100</span>&gt;::first &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;last=&quot;</span> &lt;&lt; <span class="type">gen_seq_t</span>&lt;<span class="number">100</span>&gt;::last &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="618-shared_ptr"><a class="markdownIt-Anchor" href="#618-shared_ptr"></a> 6.1.8 shared_ptr</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> v1 &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line">    T* _p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(U* p) : _p(p) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() &#123; <span class="keyword">delete</span> _p; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;; <span class="comment">// namespace v1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> v2 &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">helper_base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">helper_base</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">helper</span> : <span class="keyword">public</span> helper_base &#123;</span><br><span class="line">    T* _data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">helper</span>(T* p) : _data(p) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">helper</span>() &#123; <span class="keyword">delete</span> _data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span> &#123;</span><br><span class="line">    helper_base* _helper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(U* p) &#123;</span><br><span class="line">        _helper = <span class="keyword">new</span> <span class="built_in">helper</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() &#123; <span class="keyword">delete</span> _helper; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace v2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;~Foo()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test raw pointer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        Foo* f1 = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">        <span class="type">void</span>* f2 = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">        <span class="keyword">delete</span> f1;</span><br><span class="line">        <span class="keyword">delete</span> f2;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test v1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="function">v1::shared_ptr&lt;Foo&gt; <span class="title">f1</span><span class="params">(<span class="keyword">new</span> Foo())</span></span>;</span><br><span class="line">        <span class="function">v1::shared_ptr&lt;<span class="type">void</span>&gt; <span class="title">f2</span><span class="params">(<span class="keyword">new</span> Foo())</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test v2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="function">v2::shared_ptr&lt;Foo&gt; <span class="title">f1</span><span class="params">(<span class="keyword">new</span> Foo())</span></span>;</span><br><span class="line">        <span class="function">v2::shared_ptr&lt;<span class="type">void</span>&gt; <span class="title">f2</span><span class="params">(<span class="keyword">new</span> Foo())</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Test raw pointer</span><br><span class="line">~Foo()</span><br><span class="line">Test v1</span><br><span class="line">~Foo()</span><br><span class="line">Test v2</span><br><span class="line">~Foo()</span><br><span class="line">~Foo()</span><br></pre></td></tr></table></figure>
<h2 id="62-iterator"><a class="markdownIt-Anchor" href="#62-iterator"></a> 6.2 Iterator</h2>
<h3 id="621-static-loop"><a class="markdownIt-Anchor" href="#621-static-loop"></a> 6.2.1 Static Loop</h3>
<p>Inspired by <a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/master/base/base/constexpr_helpers.h">base/base/constexpr_helpers.h</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> Arg&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func_wrapper</span><span class="params">(Func&amp;&amp; func, Arg&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_void_v&lt;std::<span class="type">invoke_result_t</span>&lt;Func, Arg&gt;&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">func</span>(arg);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T Begin, T Inc, <span class="keyword">typename</span> Func, T... Is&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">static_for_impl</span><span class="params">(Func&amp;&amp; f, std::integer_sequence&lt;T, Is...&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">func_wrapper</span>(f, std::integral_constant&lt;T, Begin + Is * Inc&gt;&#123;&#125;) || ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> Begin, <span class="keyword">decltype</span>(Begin) End, <span class="keyword">auto</span> Inc, <span class="keyword">typename</span> Func&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">static_for</span><span class="params">(Func&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> T = <span class="keyword">decltype</span>(Begin);</span><br><span class="line">    <span class="keyword">constexpr</span> T count = (End - Begin + Inc - <span class="number">1</span>) / Inc; <span class="comment">// Number of steps based on increment</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_for_impl</span>&lt;T, Begin, Inc&gt;(std::forward&lt;Func&gt;(f), std::make_integer_sequence&lt;T, count&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Increment by 1: &quot;</span>;</span><br><span class="line">    <span class="built_in">static_for</span>&lt;<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>&gt;([](<span class="keyword">auto</span> i) &#123; std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span>; &#125;); <span class="comment">// Increment by 1</span></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Increment by 2: &quot;</span>;</span><br><span class="line">    <span class="built_in">static_for</span>&lt;<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>&gt;([](<span class="keyword">auto</span> i) &#123; std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span>; &#125;); <span class="comment">// Increment by 2</span></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="622-iterate-over-stdinteger_sequence"><a class="markdownIt-Anchor" href="#622-iterate-over-stdinteger_sequence"></a> 6.2.2 Iterate over std::integer_sequence</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T... Is&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iterate_integer_sequence</span><span class="params">(std::integer_sequence&lt;T, Is...&gt; sequence)</span> </span>&#123;</span><br><span class="line">    ((std::cout &lt;&lt; Is &lt;&lt; <span class="string">&quot; &quot;</span>), ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">iterate_integer_sequence</span>(std::<span class="built_in">make_integer_sequence</span>&lt;<span class="type">int</span>, <span class="number">100</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="623-iterate-over-stdtuple"><a class="markdownIt-Anchor" href="#623-iterate-over-stdtuple"></a> 6.2.3 Iterate over std::tuple</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tuple, <span class="keyword">typename</span> Func, <span class="type">size_t</span>... N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_call_tuple</span><span class="params">(<span class="type">const</span> Tuple&amp; t, Func&amp;&amp; func, std::index_sequence&lt;N...&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="type">void</span>&gt;(std::initializer_list&lt;<span class="type">int</span>&gt;&#123;(<span class="built_in">func</span>(std::<span class="built_in">get</span>&lt;N&gt;(t)), <span class="number">0</span>)...&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args, <span class="keyword">typename</span> Func&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">travel_tuple</span><span class="params">(<span class="type">const</span> std::tuple&lt;Args...&gt;&amp; t, Func&amp;&amp; func)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func_call_tuple</span>(t, std::forward&lt;Func&gt;(func), std::make_index_sequence&lt;<span class="keyword">sizeof</span>...(Args)&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t = std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">4.56</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">travel_tuple</span>(t, [](<span class="keyword">auto</span>&amp;&amp; item) &#123; std::cout &lt;&lt; item &lt;&lt; <span class="string">&quot;,&quot;</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="63-type-deduction"><a class="markdownIt-Anchor" href="#63-type-deduction"></a> 6.3 Type Deduction</h2>
<p><strong><code>using template</code></strong>: When extracting types with <code>Traits</code>, we often need to add <code>typename</code> to disambiguate. Therefore, <code>using</code> templates can further eliminate the need for redundant <code>typename</code>.<br />
<strong><code>static member template</code></strong>: Static member templates.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    INT = <span class="number">0</span>,</span><br><span class="line">    LONG,  <span class="comment">/* 1 */</span></span><br><span class="line">    FLOAT, <span class="comment">/* 2 */</span></span><br><span class="line">    DOUBLE <span class="comment">/* 3 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Type type&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeTraits</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeTraits</span>&lt;Type::INT&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">int32_t</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int32_t</span> default_value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeTraits</span>&lt;Type::LONG&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">int64_t</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int64_t</span> default_value = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeTraits</span>&lt;Type::FLOAT&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">float</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">float</span> default_value = <span class="number">2.2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeTraits</span>&lt;Type::DOUBLE&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">double</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> default_value = <span class="number">3.3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Type type&gt;</span><br><span class="line"><span class="keyword">using</span> CppType = <span class="keyword">typename</span> TypeTraits&lt;type&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> TypeTraits&lt;Type::INT&gt;::type value1 = TypeTraits&lt;Type::INT&gt;::default_value;</span><br><span class="line">    CppType&lt;Type::LONG&gt; value2 = TypeTraits&lt;Type::LONG&gt;::default_value;</span><br><span class="line">    CppType&lt;Type::FLOAT&gt; value3 = TypeTraits&lt;Type::FLOAT&gt;::default_value;</span><br><span class="line">    CppType&lt;Type::DOUBLE&gt; value4 = TypeTraits&lt;Type::DOUBLE&gt;::default_value;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value1=&quot;</span> &lt;&lt; value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value2=&quot;</span> &lt;&lt; value2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value3=&quot;</span> &lt;&lt; value3 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value4=&quot;</span> &lt;&lt; value4 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="64-static-proxy"><a class="markdownIt-Anchor" href="#64-static-proxy"></a> 6.4 Static Proxy</h2>
<p>It’s unclear if this falls strictly within the scope of metaprogramming. For more examples, refer to <a target="_blank" rel="noopener" href="https://github.com/liuyehcf/starrocks/blob/main/be/src/exprs/vectorized/binary_function.h">binary_function.h</a>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OP1</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">apply</span><span class="params">(<span class="type">int32_t</span> l, <span class="type">int32_t</span> r)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OP1(l, r)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> l + r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OP2</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">apply</span><span class="params">(<span class="type">int32_t</span> l, <span class="type">int32_t</span> r)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OP2(l, r)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> l - r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OP3</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">apply</span><span class="params">(<span class="type">int32_t</span> l, <span class="type">int32_t</span> r)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OP3(l, r)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> l * r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OP4</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">apply</span><span class="params">(<span class="type">int32_t</span> l, <span class="type">int32_t</span> r)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;OP4(l, r)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> r == <span class="number">0</span> ? <span class="number">0</span> : l / r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OP&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper1</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">apply</span><span class="params">(<span class="type">int32_t</span> l, <span class="type">int32_t</span> r)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wrapper1 start&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="type">double</span> res = OP::<span class="built_in">apply</span>(l, r);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wrapper1 end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OP&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper2</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">apply</span><span class="params">(<span class="type">int32_t</span> l, <span class="type">int32_t</span> r)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wrapper2 start&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="type">double</span> res = OP::<span class="built_in">apply</span>(l, r);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wrapper2 end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OP&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper3</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">apply</span><span class="params">(<span class="type">int32_t</span> l, <span class="type">int32_t</span> r)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wrapper3 start&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="type">double</span> res = OP::<span class="built_in">apply</span>(l, r);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wrapper3 end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Wrapper3&lt;Wrapper2&lt;Wrapper1&lt;OP1&gt;&gt;&gt;::<span class="built_in">apply</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    Wrapper1&lt;Wrapper2&lt;Wrapper3&lt;OP2&gt;&gt;&gt;::<span class="built_in">apply</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="65-compile-time-branching"><a class="markdownIt-Anchor" href="#65-compile-time-branching"></a> 6.5 Compile-Time Branching</h2>
<p>Sometimes, we want to write different branches of code for different types, but these branches may be incompatible across types. For example, if we want to implement addition, we can use the <code>+</code> operator for <code>int</code>, but for the <code>Foo</code> type, we need to call the <code>add</code> method. In this case, regular branching would fail, resulting in a compilation error during instantiation. We can use <code>if constexpr</code> to implement compile-time branching to handle this scenario.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Foo <span class="title">add_foo</span><span class="params">(<span class="type">const</span> Foo&amp; left, <span class="type">const</span> Foo&amp; right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Foo&#123;left.val + right.val&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(<span class="type">const</span> T&amp; left, <span class="type">const</span> T&amp; right)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same&lt;T, <span class="type">int</span>&gt;::value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_same&lt;T, Foo&gt;::value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">add_foo</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo left, right;</span><br><span class="line">    <span class="built_in">add</span>(left, right);</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Type-specific code must be contained within <code>if constexpr/else if constexpr</code> blocks. Here is an example of incorrect usage: the intention is to return immediately if the type is not arithmetic, but since <code>left + right</code> is outside the static branching, an error will occur when instantiating with <code>Foo</code>.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(<span class="type">const</span> T&amp; left, <span class="type">const</span> T&amp; right)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!std::is_arithmetic&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo left, right;</span><br><span class="line">    <span class="built_in">add</span>(left, right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="66-implement-stdbind"><a class="markdownIt-Anchor" href="#66-implement-stdbind"></a> 6.6 Implement std::bind</h2>
<p><strong>The following example reveals the underlying principles of <code>std::bind</code>. Here’s the meaning of each helper template:</strong></p>
<ul>
<li><code>invoke</code>: Triggers method invocation.</li>
<li><code>seq/gen_seq/gen_seq_t</code>: Generates an integer sequence.</li>
<li><code>placeholder</code>: Placeholder.</li>
<li><code>placeholder_num</code>: Counts the number of placeholders in a given parameter list.</li>
<li><code>bind_return_type</code>: Extracts the return type of a function.</li>
<li><code>select</code>: Extracts arguments from <code>bindArgs</code> and <code>callArgs</code>. If it’s a placeholder, it extracts from <code>callArgs</code>; otherwise, from <code>bindArgs</code>.</li>
<li><code>bind_t</code>: Encapsulates a class with an overloaded <code>operator()</code>.</li>
<li><code>bind</code>: The interface.</li>
</ul>
<p><strong>Core Idea:</strong></p>
<ul>
<li>First, <code>bind</code> needs to return a type, referred to as <code>biner_type</code>, which overloads the <code>operator()</code> function.</li>
<li>The <code>operator()</code> in <code>biner_type</code> has a parameter list that is a parameter pack, <code>Arg...</code>, enabling dynamic adaptation to different bound objects.
<ul>
<li>The length of this parameter pack matches the number of placeholders.</li>
<li>Use <code>static_assert</code> to constrain the parameter count to match the number of placeholders specified in <code>bind</code>.</li>
</ul>
</li>
<li><code>std::tuple</code> is used to store the <code>bind</code> argument list and the parameter list of <code>operator()</code>. Using <code>std::tuple</code> allows easy access to the corresponding argument by index.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// invoke</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">invoke</span><span class="params">(F&amp;&amp; func, Args&amp;&amp;... args)</span> -&gt; <span class="title">decltype</span><span class="params">(std::forward&lt;F&gt;(func)(std::forward&lt;Args&gt;(args)...))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;F&gt;(func)(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">invoke_return_type</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">decltype</span>(<span class="built_in">invoke</span>(std::<span class="built_in">declval</span>&lt;F&gt;(), std::<span class="built_in">declval</span>&lt;Args&gt;()...));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// seq</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>... N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seq</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// seq_gen</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N, <span class="type">size_t</span>... S&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gen_seq</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N, <span class="type">size_t</span>... S&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gen_seq</span> : gen_seq&lt;N - <span class="number">1</span>, N - <span class="number">1</span>, S...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>... S&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gen_seq</span>&lt;<span class="number">0</span>, S...&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = seq&lt;S...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span>... S&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">gen_seq_t</span> = <span class="keyword">typename</span> gen_seq&lt;S...&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// placeholder</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> Num&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">placeholder</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> placeholder&lt;<span class="number">1</span>&gt; _1;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> placeholder&lt;<span class="number">2</span>&gt; _2;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> placeholder&lt;<span class="number">3</span>&gt; _3;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> placeholder&lt;<span class="number">4</span>&gt; _4;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> placeholder&lt;<span class="number">5</span>&gt; _5;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> placeholder&lt;<span class="number">6</span>&gt; _6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... BindArgs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">placeholder_num</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NonPlaceHolderBindArg, <span class="keyword">typename</span>... BindArgs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">placeholder_num</span>&lt;NonPlaceHolderBindArg, BindArgs...&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> value = placeholder_num&lt;BindArgs...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> Num, <span class="keyword">typename</span>... BindArgs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">placeholder_num</span>&lt;placeholder&lt;Num&gt;, BindArgs...&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> value = <span class="number">1</span> + placeholder_num&lt;BindArgs...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BindArg, <span class="keyword">typename</span> TCallArgs&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">select</span><span class="params">(BindArg&amp;&amp; non_place_holder_bind_arg, TCallArgs&amp;&amp; t_call_args)</span> -&gt; BindArg&amp;&amp; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;BindArg&gt;(non_place_holder_bind_arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select N-th element from Tuple</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N, <span class="keyword">typename</span> TCallArgs&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">select</span><span class="params">(placeholder&lt;N&gt; place_holder_bind_arg, TCallArgs&amp;&amp; t_call_args)</span></span></span><br><span class="line"><span class="function">        -&gt; std::<span class="type">conditional_t</span>&lt;std::is_rvalue_reference&lt;std::<span class="type">tuple_element_t</span>&lt;N - 1, std::<span class="type">decay_t</span>&lt;TCallArgs&gt;&gt;&gt;::value,</span></span><br><span class="line"><span class="function">                              std::<span class="type">tuple_element_t</span>&lt;N - 1, std::<span class="type">decay_t</span>&lt;TCallArgs&gt;&gt;,</span></span><br><span class="line"><span class="function">                              <span class="title">decltype</span><span class="params">(std::get&lt;N - <span class="number">1</span>&gt;(t_call_args))</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;</span><br><span class="line">            std::<span class="type">conditional_t</span>&lt;std::is_rvalue_reference&lt;std::<span class="type">tuple_element_t</span>&lt;N - <span class="number">1</span>, std::<span class="type">decay_t</span>&lt;TCallArgs&gt;&gt;&gt;::value,</span><br><span class="line">                               std::<span class="type">tuple_element_t</span>&lt;N - <span class="number">1</span>, std::<span class="type">decay_t</span>&lt;TCallArgs&gt;&gt;,</span><br><span class="line">                               <span class="keyword">decltype</span>(std::<span class="built_in">get</span>&lt;N - <span class="number">1</span>&gt;(std::forward&lt;TCallArgs&gt;(t_call_args)))&gt;&gt;(</span><br><span class="line">            std::<span class="built_in">get</span>&lt;N - <span class="number">1</span>&gt;(std::forward&lt;TCallArgs&gt;(t_call_args)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind_return_type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> TBindArgs, <span class="keyword">typename</span> TCallArgs, <span class="keyword">typename</span> Seq&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bind_return_type</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// represent Seq by form seq&lt;S...&gt;, so we can use S... to generate folding expression</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> TBindArgs, <span class="keyword">typename</span> TCallArgs, <span class="type">size_t</span>... S&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bind_return_type</span>&lt;F, TBindArgs, TCallArgs, seq&lt;S...&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">decltype</span>(<span class="built_in">invoke</span>(std::<span class="built_in">declval</span>&lt;F&gt;(),</span><br><span class="line">                                 <span class="built_in">select</span>(std::<span class="built_in">get</span>&lt;S&gt;(std::<span class="built_in">declval</span>&lt;TBindArgs&gt;()), std::<span class="built_in">declval</span>&lt;TCallArgs&gt;())...));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> TBindArgs, <span class="keyword">typename</span> TCallArgs,</span><br><span class="line">          <span class="keyword">typename</span> Seq = <span class="type">gen_seq_t</span>&lt;std::tuple_size&lt;TBindArgs&gt;::value&gt;&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">bind_return_type_t</span> = <span class="keyword">typename</span> bind_return_type&lt;F, TBindArgs, TCallArgs, Seq&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind_t</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... BindArgs&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bind_t</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> TBindArgs = std::tuple&lt;std::<span class="type">decay_t</span>&lt;BindArgs&gt;...&gt;;</span><br><span class="line">    <span class="keyword">using</span> CallFun = std::<span class="type">decay_t</span>&lt;F&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bind_t</span><span class="params">(F func, BindArgs... bind_args)</span> : _func(func), _t_bind_args(bind_args...) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... CallArgs, <span class="keyword">typename</span> TCallArgs = std::tuple&lt;CallArgs&amp;&amp;...&gt;&gt;</span><br><span class="line">    <span class="type">bind_return_type_t</span>&lt;CallFun, TBindArgs, TCallArgs&gt; <span class="built_in">operator</span>()(CallArgs&amp;&amp;... call_args) &#123;</span><br><span class="line">        <span class="built_in">static_assert</span>(placeholder_num&lt;BindArgs...&gt;::value == <span class="keyword">sizeof</span>...(CallArgs),</span><br><span class="line">                      <span class="string">&quot;number of placeholder must be equal with the number of operator()&#x27;s parameter&quot;</span>);</span><br><span class="line">        <span class="function">TCallArgs <span class="title">t_call_args</span><span class="params">(std::forward&lt;CallArgs&gt;(call_args)...)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> _call(t_call_args, <span class="type">gen_seq_t</span>&lt;std::tuple_size&lt;TBindArgs&gt;::value&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TCallArgs, <span class="type">size_t</span>... S&gt;</span><br><span class="line">    <span class="type">bind_return_type_t</span>&lt;CallFun, TBindArgs, std::<span class="type">decay_t</span>&lt;TCallArgs&gt;&gt; _call(TCallArgs&amp;&amp; t_call_args,</span><br><span class="line">                                                                          seq&lt;S...&gt; <span class="comment">/*unused*/</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">invoke</span>(_func, <span class="built_in">select</span>(std::<span class="built_in">get</span>&lt;S&gt;(_t_bind_args), std::forward&lt;TCallArgs&gt;(t_call_args))...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CallFun _func;</span><br><span class="line">    TBindArgs _t_bind_args;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... BindArgs&gt;</span><br><span class="line"><span class="type">bind_t</span>&lt;std::<span class="type">decay_t</span>&lt;F&gt;, std::<span class="type">decay_t</span>&lt;BindArgs&gt;...&gt; <span class="built_in">bind</span>(F&amp;&amp; func, BindArgs&amp;&amp;... bind_args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">bind_t</span>&lt;std::<span class="type">decay_t</span>&lt;F&gt;, std::<span class="type">decay_t</span>&lt;BindArgs&gt;...&gt;(std::forward&lt;F&gt;(func),</span><br><span class="line">                                                              std::forward&lt;BindArgs&gt;(bind_args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; s, <span class="type">int</span> i, <span class="type">double</span> d)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str=&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;, int=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, double=&quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f1 = <span class="built_in">bind</span>(print, _1, <span class="number">1</span>, <span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">auto</span> f2 = <span class="built_in">bind</span>(print, <span class="string">&quot;fixed_str_2&quot;</span>, _1, <span class="number">2.2</span>);</span><br><span class="line">    <span class="keyword">auto</span> f3 = <span class="built_in">bind</span>(print, <span class="string">&quot;fixed_str_3&quot;</span>, <span class="number">3</span>, _1);</span><br><span class="line">    <span class="keyword">auto</span> f5 = <span class="built_in">bind</span>(print, _1, _2, _3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">f1</span>(<span class="string">&quot;str_1&quot;</span>);</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">3.3</span>);</span><br><span class="line">    <span class="built_in">f5</span>(<span class="string">&quot;str_5&quot;</span>, <span class="number">5</span>, <span class="number">5.5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Simplified version:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// placeholder</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> Num&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">placeholder</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> placeholder&lt;<span class="number">1</span>&gt; _1;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> placeholder&lt;<span class="number">2</span>&gt; _2;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> placeholder&lt;<span class="number">3</span>&gt; _3;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> placeholder&lt;<span class="number">4</span>&gt; _4;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> placeholder&lt;<span class="number">5</span>&gt; _5;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> placeholder&lt;<span class="number">6</span>&gt; _6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate how many placeholders.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... BindArgs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">placeholder_num</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... BindArgs&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> placeholder_num_v = placeholder_num&lt;BindArgs...&gt;::value;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NonPlaceHolderBindArg, <span class="keyword">typename</span>... BindArgs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">placeholder_num</span>&lt;NonPlaceHolderBindArg, BindArgs...&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> value = placeholder_num_v&lt;BindArgs...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> Num, <span class="keyword">typename</span>... BindArgs&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">placeholder_num</span>&lt;placeholder&lt;Num&gt;, BindArgs...&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> value = <span class="number">1</span> + placeholder_num_v&lt;BindArgs...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Select non-placeholder element.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BindArg, <span class="keyword">typename</span> TCallArgs&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">select</span><span class="params">(BindArg&amp;&amp; non_place_holder_bind_arg, TCallArgs&amp;&amp; t_call_args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;BindArg&gt;(non_place_holder_bind_arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Select placeholder element.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N, <span class="keyword">typename</span> TCallArgs&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">select</span><span class="params">(placeholder&lt;N&gt; place_holder_bind_arg, TCallArgs&amp;&amp; t_call_args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;N - <span class="number">1</span>&gt;(std::forward&lt;TCallArgs&gt;(t_call_args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The implementation of bind, provide overloaded operator() to call the original function with placeholders and actual args.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CallFun, <span class="keyword">typename</span>... BindArgs&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bind_t</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> TBindArgs = std::tuple&lt;BindArgs...&gt;;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> TBindArgsSize = std::tuple_size_v&lt;TBindArgs&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bind_t</span><span class="params">(CallFun func, BindArgs... bind_args)</span> : _func(func), _t_bind_args(bind_args...) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... CallArgs, <span class="keyword">typename</span> TCallArgs = std::tuple&lt;CallArgs&amp;&amp;...&gt;&gt;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>()(CallArgs&amp;&amp;... call_args) &#123;</span><br><span class="line">        <span class="built_in">static_assert</span>(placeholder_num_v&lt;BindArgs...&gt; == <span class="keyword">sizeof</span>...(CallArgs),</span><br><span class="line">                      <span class="string">&quot;number of placeholder must be equal with the number of operator()&#x27;s parameter&quot;</span>);</span><br><span class="line">        <span class="comment">// The reason we use TCallArgs is that the size of CallArgs is different from the size of TBindArgs</span></span><br><span class="line">        <span class="comment">// so they cannot be unfolded together at `_call`</span></span><br><span class="line">        <span class="function">TCallArgs <span class="title">t_call_args</span><span class="params">(std::forward&lt;CallArgs&gt;(call_args)...)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> _call(t_call_args, std::<span class="built_in">make_index_sequence</span>&lt;TBindArgsSize&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// represent Seq by form std::index_sequence&lt;S...&gt;, so we can use S... to generate folding expression</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TCallArgs, <span class="type">size_t</span>... S&gt;</span><br><span class="line">    <span class="keyword">auto</span> _call(TCallArgs&amp;&amp; t_call_args, std::index_sequence&lt;S...&gt; <span class="comment">/*unused*/</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _func(<span class="built_in">select</span>(std::<span class="built_in">get</span>&lt;S&gt;(_t_bind_args), std::forward&lt;TCallArgs&gt;(t_call_args))...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The original function</span></span><br><span class="line">    CallFun _func;</span><br><span class="line">    <span class="comment">// Contains all args of original function, including non-placeholder values and placeholders</span></span><br><span class="line">    TBindArgs _t_bind_args;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entrance</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... BindArgs&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bind</span><span class="params">(F&amp;&amp; func, BindArgs&amp;&amp;... bind_args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bind_t</span>(std::forward&lt;F&gt;(func), std::forward&lt;BindArgs&gt;(bind_args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; s, <span class="type">int</span> i, <span class="type">double</span> d)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str=&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;, int=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, double=&quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f1 = <span class="built_in">bind</span>(print, _1, <span class="number">1</span>, <span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">auto</span> f2 = <span class="built_in">bind</span>(print, <span class="string">&quot;fixed_str_2&quot;</span>, _1, <span class="number">2.2</span>);</span><br><span class="line">    <span class="keyword">auto</span> f3 = <span class="built_in">bind</span>(print, <span class="string">&quot;fixed_str_3&quot;</span>, <span class="number">3</span>, _1);</span><br><span class="line">    <span class="keyword">auto</span> f5 = <span class="built_in">bind</span>(print, _1, _2, _3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">f1</span>(<span class="string">&quot;str_1&quot;</span>);</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">3.3</span>);</span><br><span class="line">    <span class="built_in">f5</span>(<span class="string">&quot;str_5&quot;</span>, <span class="number">5</span>, <span class="number">5.5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="67-quick-sort"><a class="markdownIt-Anchor" href="#67-quick-sort"></a> 6.7 Quick Sort</h2>
<p><strong><a target="_blank" rel="noopener" href="https://gist.github.com/cleoold/c26d4e2b4ff56985c42f212a1c76deb9">quicksort in C++ template metaprogramming</a></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> quicksort &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> VALUE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> value = VALUE;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>... VALUES&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">    <span class="comment">// Any derived type can be represented as an Array</span></span><br><span class="line">    <span class="keyword">using</span> array_type = Array;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> EmptyArray = Array&lt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_ARRAY&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FirstOf</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> FIRST_VALUE, <span class="type">int</span>... VALUES&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FirstOf</span>&lt;Array&lt;FIRST_VALUE, VALUES...&gt;&gt; : Value&lt;FIRST_VALUE&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_ARRAY, <span class="type">int</span> VALUE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PrependTo</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> FIRST_VALUE, <span class="type">int</span>... VALUES&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PrependTo</span>&lt;Array&lt;VALUES...&gt;, FIRST_VALUE&gt; : Array&lt;FIRST_VALUE, VALUES...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_ARRAY, <span class="type">int</span> VALUE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppendValueTo</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> LAST_VALUE, <span class="type">int</span>... VALUES&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppendValueTo</span>&lt;Array&lt;VALUES...&gt;, LAST_VALUE&gt; : Array&lt;VALUES..., LAST_VALUE&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_ARRAY, <span class="keyword">typename</span> SOURCE_ARRAY&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppendArrayTo</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_ARRAY, <span class="type">int</span> FIRST_VALUE, <span class="type">int</span>... VALUES&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppendArrayTo</span>&lt;TARGET_ARRAY, Array&lt;FIRST_VALUE, VALUES...&gt;&gt;</span><br><span class="line">        : AppendArrayTo&lt;<span class="keyword">typename</span> AppendValueTo&lt;TARGET_ARRAY, FIRST_VALUE&gt;::array_type, Array&lt;VALUES...&gt;&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_ARRAY&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppendArrayTo</span>&lt;TARGET_ARRAY, EmptyArray&gt; : TARGET_ARRAY &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_ARRAY, <span class="type">int</span> TARGET_VALUE, <span class="type">bool</span> CONDITION&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LessEqualFilterAdviser</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> TARGET_VALUE, <span class="type">int</span> FIRST_VALUE, <span class="type">int</span>... VALUES&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LessEqualFilterAdviser</span>&lt;Array&lt;FIRST_VALUE, VALUES...&gt;, TARGET_VALUE, <span class="literal">true</span>&gt;</span><br><span class="line">        : PrependTo&lt;<span class="keyword">typename</span> LessEqualFilterAdviser&lt;Array&lt;VALUES...&gt;, TARGET_VALUE,</span><br><span class="line">                                                    (FirstOf&lt;Array&lt;VALUES...&gt;&gt;::value &lt;= TARGET_VALUE)&gt;::array_type,</span><br><span class="line">                    FIRST_VALUE&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> TARGET_VALUE, <span class="type">int</span> FIRST_VALUE, <span class="type">int</span>... VALUES&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LessEqualFilterAdviser</span>&lt;Array&lt;FIRST_VALUE, VALUES...&gt;, TARGET_VALUE, <span class="literal">false</span>&gt;</span><br><span class="line">        : LessEqualFilterAdviser&lt;Array&lt;VALUES...&gt;, TARGET_VALUE, (FirstOf&lt;Array&lt;VALUES...&gt;&gt;::value &lt;= TARGET_VALUE)&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> TARGET_VALUE, <span class="type">int</span> FIRST_VALUE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LessEqualFilterAdviser</span>&lt;Array&lt;FIRST_VALUE&gt;, TARGET_VALUE, <span class="literal">true</span>&gt; : Array&lt;FIRST_VALUE&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> TARGET_VALUE, <span class="type">int</span> FIRST_VALUE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LessEqualFilterAdviser</span>&lt;Array&lt;FIRST_VALUE&gt;, TARGET_VALUE, <span class="literal">false</span>&gt; : EmptyArray &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_ARRAY, <span class="type">int</span> TARGET_VALUE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LessEqualFilter</span></span><br><span class="line">        : LessEqualFilterAdviser&lt;TARGET_ARRAY, TARGET_VALUE, (FirstOf&lt;TARGET_ARRAY&gt;::value &lt;= TARGET_VALUE)&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> TARGET_VALUE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LessEqualFilter</span>&lt;EmptyArray, TARGET_VALUE&gt; : EmptyArray &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_ARRAY, <span class="type">int</span> TARGET_VALUE, <span class="type">bool</span> CONDITION&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThanAdvisor</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> TARGET_VALUE, <span class="type">int</span> FIRST_VALUE, <span class="type">int</span>... VALUES&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThanAdvisor</span>&lt;Array&lt;FIRST_VALUE, VALUES...&gt;, TARGET_VALUE, <span class="literal">true</span>&gt;</span><br><span class="line">        : PrependTo&lt;<span class="keyword">typename</span> GreaterThanAdvisor&lt;Array&lt;VALUES...&gt;, TARGET_VALUE,</span><br><span class="line">                                                (FirstOf&lt;Array&lt;VALUES...&gt;&gt;::value &gt; TARGET_VALUE)&gt;::array_type,</span><br><span class="line">                    FIRST_VALUE&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> TARGET_VALUE, <span class="type">int</span> FIRST_VALUE, <span class="type">int</span>... VALUES&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThanAdvisor</span>&lt;Array&lt;FIRST_VALUE, VALUES...&gt;, TARGET_VALUE, <span class="literal">false</span>&gt;</span><br><span class="line">        : GreaterThanAdvisor&lt;Array&lt;VALUES...&gt;, TARGET_VALUE, (FirstOf&lt;Array&lt;VALUES...&gt;&gt;::value &gt; TARGET_VALUE)&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> TARGET_VALUE, <span class="type">int</span> FIRST_VALUE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThanAdvisor</span>&lt;Array&lt;FIRST_VALUE&gt;, TARGET_VALUE, <span class="literal">true</span>&gt; : Array&lt;FIRST_VALUE&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> TARGET_VALUE, <span class="type">int</span> FIRST_VALUE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThanAdvisor</span>&lt;Array&lt;FIRST_VALUE&gt;, TARGET_VALUE, <span class="literal">false</span>&gt; : EmptyArray &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_ARRAY, <span class="type">int</span> TARGET_VALUE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThan</span> : GreaterThanAdvisor&lt;TARGET_ARRAY, TARGET_VALUE, (FirstOf&lt;TARGET_ARRAY&gt;::value &gt; TARGET_VALUE)&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> TARGET_VALUE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterThan</span>&lt;EmptyArray, TARGET_VALUE&gt; : EmptyArray &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*==============================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TARGET_ARRAY&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QuickSort</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> FIRST_VALUE, <span class="type">int</span>... VALUES&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QuickSort</span>&lt;Array&lt;FIRST_VALUE, VALUES...&gt;&gt;</span><br><span class="line">        : AppendArrayTo&lt;</span><br><span class="line">                  <span class="keyword">typename</span> QuickSort&lt;<span class="keyword">typename</span> LessEqualFilter&lt;Array&lt;VALUES...&gt;, FIRST_VALUE&gt;::array_type&gt;::array_type,</span><br><span class="line">                  <span class="keyword">typename</span> PrependTo&lt;<span class="keyword">typename</span> QuickSort&lt;<span class="keyword">typename</span> GreaterThan&lt;Array&lt;VALUES...&gt;,</span><br><span class="line">                                                                             FIRST_VALUE&gt;::array_type&gt;::array_type,</span><br><span class="line">                                     FIRST_VALUE&gt;::array_type&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QuickSort</span>&lt;EmptyArray&gt; : EmptyArray &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace quicksort</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> FIRST_VALUE, <span class="type">int</span>... VALUES&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(quicksort::Array&lt;FIRST_VALUE, VALUES...&gt; <span class="comment">/*unused*/</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; FIRST_VALUE;</span><br><span class="line">    [[maybe_unused]] <span class="type">int</span> _[] = &#123;<span class="number">0</span>, ((<span class="type">void</span>)(std::cout &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; VALUES), <span class="number">0</span>)...&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(quicksort::EmptyArray <span class="comment">/*unused*/</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;()\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>... VALUES&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test_quick_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> original = quicksort::Array&lt;VALUES...&gt;;</span><br><span class="line">    <span class="keyword">using</span> sorted = quicksort::QuickSort&lt;original&gt;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;before: &quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">original</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after : &quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sorted</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test_quick_sort&lt;&gt;();</span><br><span class="line">    <span class="built_in">test_quick_sort</span>&lt;<span class="number">1</span>&gt;();</span><br><span class="line">    <span class="built_in">test_quick_sort</span>&lt;<span class="number">8</span>, <span class="number">1</span>&gt;();</span><br><span class="line">    <span class="built_in">test_quick_sort</span>&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">-3</span>, <span class="number">2</span>, <span class="number">100</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">-8</span>, <span class="number">33</span>, <span class="number">21</span>, <span class="number">3</span>, <span class="number">-4</span>, <span class="number">-4</span>, <span class="number">-4</span>, <span class="number">-7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">88</span>, <span class="number">42</span>, <span class="number">956</span>, <span class="number">21</span>, <span class="number">27</span>,</span><br><span class="line">                    <span class="number">39</span>, <span class="number">55</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">-31</span>, <span class="number">9</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="68-conditional-members"><a class="markdownIt-Anchor" href="#68-conditional-members"></a> 6.8 Conditional Members</h2>
<p>Sometimes, we want certain specialized versions of a template class to include additional fields, while the default version does not contain these extra fields.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Extra</span> &#123;</span><br><span class="line">    T extra_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> : <span class="keyword">public</span> std::<span class="type">conditional_t</span>&lt;std::is_integral&lt;T&gt;::value, Extra&lt;T&gt;, Empty&gt; &#123;</span><br><span class="line">    T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;<span class="type">int</span>&gt; n1;</span><br><span class="line">    n1.value = <span class="number">1</span>;</span><br><span class="line">    n1.extra_value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;<span class="type">double</span>&gt; n2;</span><br><span class="line">    n2.value = <span class="number">3.14</span>;</span><br><span class="line">    <span class="comment">// n2.extra_value = 2.71;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="69-type-guard"><a class="markdownIt-Anchor" href="#69-type-guard"></a> 6.9 Type Guard</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/StarRocks/starrocks/blob/main/be/src/util/guard.h">StarRocks-guard.h</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Guard = <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> type_in = (std::is_same_v&lt;T, Args&gt; || ...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T v, T... args&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> value_in = ((v == args) || ...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">using</span> TypeGuard = std::<span class="type">enable_if_t</span>&lt;((std::is_same_v&lt;T, Args&gt;) || ...), Guard&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TYPE_GUARD is used to define a type guard.</span></span><br><span class="line"><span class="comment">// for an example:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// TYPE_GUARD(DecimalArithmeticOp, is_decimal_arithmetic_op, AddOp, SubOp, MulOp, DivOp);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This macro define a guard and a compile-time conditional expression.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// guard: DecimalArithmeticOp&lt;T&gt;,  it is Guard(i.e. int) if T is AddOp|SubOp|MulOp|DivOp,</span></span><br><span class="line"><span class="comment">//  it is nothing(i.e. cpp template specialization matching failure) otherwise.</span></span><br><span class="line"><span class="comment">// conditional expression: is_decimal_arithmetic_op&lt;T&gt; return true if T is AddOp|SubOp|MulOp|DivOp,</span></span><br><span class="line"><span class="comment">//  return false otherwise.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE_GUARD(guard_name, pred_name, ...)                   \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename T&gt;</span>                                        \</span></span><br><span class="line"><span class="meta">    struct pred_name##_struct &#123;                                  \</span></span><br><span class="line"><span class="meta">        static constexpr bool value = type_in<span class="string">&lt;T, ##__VA_ARGS__&gt;</span>; \</span></span><br><span class="line"><span class="meta">    &#125;;                                                           \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename T&gt;</span>                                        \</span></span><br><span class="line"><span class="meta">    constexpr bool pred_name = pred_name##_struct<span class="string">&lt;T&gt;</span>::value;     \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;typename T&gt;</span>                                        \</span></span><br><span class="line"><span class="meta">    using guard_name = TypeGuard<span class="string">&lt;T, ##__VA_ARGS__&gt;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">TYPE_GUARD</span>(MyGuard, type_is_unsigned_int, <span class="type">uint8_t</span>, <span class="type">uint16_t</span>, <span class="type">uint32_t</span>, <span class="type">uint64_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(type_is_unsigned_int&lt;T&gt;, <span class="string">&quot;type must be ordinal&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> u;</span><br><span class="line">    <span class="built_in">check</span>(u);</span><br><span class="line">    <span class="comment">// double d;</span></span><br><span class="line">    <span class="comment">// check(d);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="610-enum-name"><a class="markdownIt-Anchor" href="#610-enum-name"></a> 6.10 enum name</h2>
<p>There is an key observation inspired by <a target="_blank" rel="noopener" href="https://github.com/Neargye/nameof.git">nameof</a>, the enum name information cannot be generated by template itself but can come from MACRO like <code>__PRETTY_FUNCTION__</code>.</p>
<p>Also, we cannot know the right boundary of a enum. So we can predefine a large enough valeu as the common boundary of all enum classes.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENUM_MIN 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENUM_MAX 128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func, <span class="keyword">typename</span> Arg&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">func_wrapper</span><span class="params">(Func&amp;&amp; func, Arg&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_void_v&lt;std::<span class="type">invoke_result_t</span>&lt;Func, Arg&gt;&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">func</span>(arg);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">static_assert</span>(std::is_same_v&lt;<span class="type">bool</span>, std::<span class="type">invoke_result_t</span>&lt;Func, Arg&gt;&gt;);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T Begin, <span class="keyword">typename</span> Func, T... Is&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">static_for_impl</span><span class="params">(Func&amp;&amp; f, std::integer_sequence&lt;T, Is...&gt; <span class="comment">/*unused*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Support short-circuiting</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">func_wrapper</span>(std::forward&lt;Func&gt;(f), std::integral_constant&lt;T, Begin + Is&gt;&#123;&#125;) || ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> Begin, <span class="keyword">decltype</span>(Begin) End, <span class="keyword">typename</span> Func&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">static_for</span><span class="params">(Func&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> T = <span class="keyword">decltype</span>(Begin);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_for_impl</span>&lt;T, Begin&gt;(std::forward&lt;Func&gt;(f), std::make_integer_sequence&lt;T, End - Begin&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, E v&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">enum_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// __PRETTY_FUNCTION__ is something like: constexpr auto gen_pretry_name() [with E = Color; E v = RED]</span></span><br><span class="line">    std::string_view name = std::string_view&#123;__PRETTY_FUNCTION__, <span class="built_in">sizeof</span>(__PRETTY_FUNCTION__) - <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = name.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((name[i - <span class="number">1</span>] &lt; <span class="string">&#x27;0&#x27;</span> || name[i - <span class="number">1</span>] &gt; <span class="string">&#x27;9&#x27;</span>) &amp;&amp; (name[i - <span class="number">1</span>] &lt; <span class="string">&#x27;a&#x27;</span> || name[i - <span class="number">1</span>] &gt; <span class="string">&#x27;z&#x27;</span>) &amp;&amp;</span><br><span class="line">            (name[i - <span class="number">1</span>] &lt; <span class="string">&#x27;A&#x27;</span> || name[i - <span class="number">1</span>] &gt; <span class="string">&#x27;Z&#x27;</span>) &amp;&amp; (name[i - <span class="number">1</span>] != <span class="string">&#x27;_&#x27;</span>)) &#123;</span><br><span class="line">            name.<span class="built_in">remove_prefix</span>(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        ((name[<span class="number">0</span>] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; name[<span class="number">0</span>] &lt;= <span class="string">&#x27;z&#x27;</span>) || (name[<span class="number">0</span>] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; name[<span class="number">0</span>] &lt;= <span class="string">&#x27;Z&#x27;</span>) || (name[<span class="number">0</span>] == <span class="string">&#x27;_&#x27;</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invalid name.</span></span><br><span class="line">    <span class="keyword">return</span> std::string_view&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">std::string_view <span class="title">enum_name_of</span><span class="params">(E v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> U = std::<span class="type">underlying_type_t</span>&lt;E&gt;;</span><br><span class="line">    std::string_view res;</span><br><span class="line">    static_for&lt;<span class="built_in">static_cast</span>&lt;U&gt;(ENUM_MIN), <span class="built_in">static_cast</span>&lt;U&gt;(ENUM_MAX)&gt;([&amp;](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;U&gt;(i) == <span class="built_in">static_cast</span>&lt;U&gt;(v)) &#123;</span><br><span class="line">            <span class="comment">// Key point: v is not an constexpr, so we need to rebuild v of the same value from an constexpr</span></span><br><span class="line">            <span class="comment">// And here, iterator variable &#x27;i&#x27; is the constexpr we needed.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Using static_cast may has error</span></span><br><span class="line">            <span class="comment">// https://reviews.llvm.org/D130058, https://reviews.llvm.org/D131307</span></span><br><span class="line">            <span class="keyword">constexpr</span> E c_v = __builtin_bit_cast(E, <span class="built_in">static_cast</span>&lt;U&gt;(i));</span><br><span class="line">            res = <span class="built_in">enum_name</span>&lt;E, c_v&gt;();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> print(x) std::cout <span class="string">&lt;&lt; #x &lt;&lt; &quot; -&gt;</span> <span class="string">&#x27;&quot; &lt;&lt; x &lt;&lt; &quot;&#x27;</span><span class="string">&quot; &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">int main() &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    Color color = Color::RED;</span></span></span><br><span class="line"><span class="string"><span class="meta">    print(enum_name_of(color));</span></span></span><br><span class="line"><span class="string"><span class="meta">    color = Color::GREEN;</span></span></span><br><span class="line"><span class="string"><span class="meta">    print(enum_name_of(color));</span></span></span><br><span class="line"><span class="string"><span class="meta">    color = Color::BLUE;</span></span></span><br><span class="line"><span class="string"><span class="meta">    print(enum_name_of(color));</span></span></span><br><span class="line"><span class="string"><span class="meta">    color = static_cast&lt;Color&gt;(100);</span></span></span><br><span class="line"><span class="string"><span class="meta">    print(enum_name_of(color));</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    return 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="7-reference"><a class="markdownIt-Anchor" href="#7-reference"></a> 7 Reference</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/master/base/base/constexpr_helpers.h">ClickHouse</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/happenlee/p/14219925.html">C++雾中风景16:std::make_index_sequence, 来试一试新的黑魔法吧</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Am2is2QCvxY">CppCon 2014: Walter E. Brown “Modern Template Metaprogramming: A Compendium, Part I”</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=a0FliKwcwXE">CppCon 2014: Walter E. Brown “Modern Template Metaprogramming: A Compendium, Part II”</a>
<ul>
<li>Unevaluated operands(sizeof, typeid, decltype, noexcept), 12:30</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/cplusplus-study/fork_stl">fork_stl</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/cplusplus-study/fork_stl/blob/master/include/bind.hpp">bind.hpp</a></li>
</ul>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag"># 原创</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/25/DataStructure-WinnerLoser-Tree/" rel="prev" title="DataStructure-WinnerLoser-Tree">
      <i class="fa fa-chevron-left"></i> DataStructure-WinnerLoser-Tree
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/06/Cpp-Language/" rel="next" title="Cpp-Language">
      Cpp-Language <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-livere">livere</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzY0My8xMDE5OA=="></div>
  </div>
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-introduction"><span class="nav-text"> 1 Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-what-is-metaprogramming"><span class="nav-text"> 1.1 What is Metaprogramming</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-the-position-of-metaprogramming-in-c"><span class="nav-text"> 1.2 The Position of Metaprogramming in C++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-history-of-c-metaprogramming"><span class="nav-text"> 1.3 History of C++ Metaprogramming</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-language-support-for-metaprogramming"><span class="nav-text"> 1.4 Language Support for Metaprogramming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#141-narrow-templates"><span class="nav-text"> 1.4.1 Narrow Templates</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#142-generic-lambda-expressions"><span class="nav-text"> 1.4.2 Generic Lambda Expressions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-basic-operations-of-metaprogramming"><span class="nav-text"> 2 Basic Operations of Metaprogramming</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#21-compile-time-testing"><span class="nav-text"> 2.1 Compile-Time Testing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#211-testing-expressions"><span class="nav-text"> 2.1.1 Testing Expressions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#212-testing-types"><span class="nav-text"> 2.1.2 Testing Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#213-using-if-for-compile-time-testing"><span class="nav-text"> 2.1.3 Using if for Compile-Time Testing</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-compile-time-iteration"><span class="nav-text"> 2.2 Compile-Time Iteration</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#221-iterating-over-fixed-length-templates"><span class="nav-text"> 2.2.1 Iterating over Fixed-Length Templates</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#222-iterating-over-variable-length-templates"><span class="nav-text"> 2.2.2 Iterating over Variable-Length Templates</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#223-simplifying-compile-time-iteration-with-fold-expressions"><span class="nav-text"> 2.2.3 Simplifying Compile-Time Iteration with Fold Expressions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-metaprogramming-vs-regular-programming"><span class="nav-text"> 2.3 Metaprogramming vs. Regular programming</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-basic-applications-of-metaprogramming"><span class="nav-text"> 3 Basic Applications of Metaprogramming</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#31-numerical-computation"><span class="nav-text"> 3.1 Numerical Computation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-type-deduction"><span class="nav-text"> 3.2 Type Deduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-code-generation"><span class="nav-text"> 3.3 Code Generation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-key-challenges-in-metaprogramming"><span class="nav-text"> 4 Key Challenges in Metaprogramming</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#41-complexity"><span class="nav-text"> 4.1 Complexity</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-instantiation-errors"><span class="nav-text"> 4.2 Instantiation Errors</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-code-bloat"><span class="nav-text"> 4.3 Code Bloat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-compile-time-performance"><span class="nav-text"> 4.4 Compile-Time Performance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-debugging-templates"><span class="nav-text"> 4.5 Debugging Templates</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-summary"><span class="nav-text"> 5 Summary</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-applications-of-metaprogramming"><span class="nav-text"> 6 Applications of Metaprogramming</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#61-utility"><span class="nav-text"> 6.1 Utility</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#611-is_same"><span class="nav-text"> 6.1.1 is_same</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#612-rank"><span class="nav-text"> 6.1.2 rank</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#613-one_oftype_invalue_in"><span class="nav-text"> 6.1.3 one_of&#x2F;type_in&#x2F;value_in</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#614-is_copy_assignable"><span class="nav-text"> 6.1.4 is_copy_assignable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#615-has_type_member"><span class="nav-text"> 6.1.5 has_type_member</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#616-has_to_string"><span class="nav-text"> 6.1.6 has_to_string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#617-sequence"><span class="nav-text"> 6.1.7 sequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#618-shared_ptr"><span class="nav-text"> 6.1.8 shared_ptr</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-iterator"><span class="nav-text"> 6.2 Iterator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#621-static-loop"><span class="nav-text"> 6.2.1 Static Loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#622-iterate-over-stdinteger_sequence"><span class="nav-text"> 6.2.2 Iterate over std::integer_sequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#623-iterate-over-stdtuple"><span class="nav-text"> 6.2.3 Iterate over std::tuple</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63-type-deduction"><span class="nav-text"> 6.3 Type Deduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-static-proxy"><span class="nav-text"> 6.4 Static Proxy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#65-compile-time-branching"><span class="nav-text"> 6.5 Compile-Time Branching</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#66-implement-stdbind"><span class="nav-text"> 6.6 Implement std::bind</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#67-quick-sort"><span class="nav-text"> 6.7 Quick Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#68-conditional-members"><span class="nav-text"> 6.8 Conditional Members</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#69-type-guard"><span class="nav-text"> 6.9 Type Guard</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#610-enum-name"><span class="nav-text"> 6.10 enum name</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-reference"><span class="nav-text"> 7 Reference</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liuyehcf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Liuyehcf</p>
  <div class="site-description" itemprop="description">大音希声，大象无形</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">285</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liuyehcf</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qhEhLuMeMOy1zgcBhkqUS6P8-gzGzoHsz',
      appKey     : 'uhkruDLNLNdL5rQjRBY2X9Ke',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
