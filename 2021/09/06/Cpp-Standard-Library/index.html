<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="阅读更多">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp-Standard-Library">
<meta property="og:url" content="http://example.com/2021/09/06/Cpp-Standard-Library/index.html">
<meta property="og:site_name" content="Liuye Notebook">
<meta property="og:description" content="阅读更多">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-09-06T02:54:02.000Z">
<meta property="article:modified_time" content="2025-01-05T16:01:08.000Z">
<meta property="article:author" content="Liuyehcf">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/09/06/Cpp-Standard-Library/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Cpp-Standard-Library | Liuye Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Liuye Notebook</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-explore">

    <a href="/explore/" rel="section"><i class="fa fa-sitemap fa-fw"></i>发现</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/06/Cpp-Standard-Library/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Liuyehcf">
      <meta itemprop="description" content="大音希声，大象无形">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liuye Notebook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Cpp-Standard-Library
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-06 10:54:02" itemprop="dateCreated datePublished" datetime="2021-09-06T10:54:02+08:00">2021-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-06 00:01:08" itemprop="dateModified" datetime="2025-01-06T00:01:08+08:00">2025-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          
            <span id="/2021/09/06/Cpp-Standard-Library/" class="post-meta-item leancloud_visitors" data-flag-title="Cpp-Standard-Library" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/06/Cpp-Standard-Library/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/06/Cpp-Standard-Library/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>阅读更多</strong></p>
<span id="more"></span>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header">C++ Standard Library headers</a></p>
<h1 id="1-algorithm"><a class="markdownIt-Anchor" href="#1-algorithm"></a> 1 algorithm</h1>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/algorithm">Standard library header <algorithm></a></p>
<h2 id="11-modifying-sequence-operations"><a class="markdownIt-Anchor" href="#11-modifying-sequence-operations"></a> 1.1 Modifying Sequence Operations</h2>
<ol>
<li><code>std::copy</code></li>
<li><code>std::copy_if</code></li>
<li><code>std::copy_n</code></li>
<li><code>std::copy_backward</code></li>
<li><code>std::move</code></li>
<li><code>std::move_backward</code></li>
<li><code>std::fill</code></li>
<li><code>std::fill_n</code></li>
<li><code>std::transform</code></li>
<li><code>std::generate</code></li>
<li><code>std::generate_n</code></li>
<li><code>std::remove</code></li>
<li><code>std::remove_if</code></li>
<li><code>std::remove_copy</code></li>
<li><code>std::remove_copy_if</code></li>
<li><code>std::replace</code></li>
<li><code>std::replace_if</code></li>
<li><code>std::replace_copy</code></li>
<li><code>std::replace_copy_if</code></li>
<li><code>std::swap</code></li>
<li><code>std::swap_ranges</code></li>
<li><code>std::iter_swap</code></li>
<li><code>std::reverse</code></li>
<li><code>std::reverse_copy</code></li>
<li><code>std::rotate</code></li>
<li><code>std::rotate_copy</code></li>
<li><code>std::shift_left</code></li>
<li><code>std::shift_right</code></li>
<li><code>std::random_shuffle</code></li>
<li><code>std::shuffle</code></li>
<li><code>std::sample</code></li>
<li><code>std::unique</code></li>
<li><code>std::unique_copy</code></li>
</ol>
<h3 id="111-stdcopy"><a class="markdownIt-Anchor" href="#111-stdcopy"></a> 1.1.1 std::copy</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; source&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; dest1;</span><br><span class="line">    std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(dest1));</span><br><span class="line">    std::<span class="built_in">copy</span>(dest1.<span class="built_in">begin</span>(), dest1.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int32_t</span>&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; dest2;</span><br><span class="line">    dest2.<span class="built_in">resize</span>(source.<span class="built_in">size</span>());</span><br><span class="line">    std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), dest2.<span class="built_in">begin</span>());</span><br><span class="line">    std::<span class="built_in">copy</span>(dest2.<span class="built_in">begin</span>(), dest2.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int32_t</span>&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="112-stdtransform"><a class="markdownIt-Anchor" href="#112-stdtransform"></a> 1.1.2 std::transform</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;std::string&gt; strs&#123;<span class="string">&quot;hello,&quot;</span>, <span class="string">&quot; Jack!&quot;</span>, <span class="string">&quot; How are you?&quot;</span>&#125;;</span><br><span class="line">        std::vector&lt;<span class="type">size_t</span>&gt; sizes;</span><br><span class="line">        std::<span class="built_in">transform</span>(strs.<span class="built_in">begin</span>(), strs.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(sizes),</span><br><span class="line">                       [](<span class="type">const</span> std::string&amp; str) &#123; <span class="keyword">return</span> str.<span class="built_in">size</span>(); &#125;);</span><br><span class="line">        std::string size_str =</span><br><span class="line">                std::<span class="built_in">accumulate</span>(sizes.<span class="built_in">begin</span>(), sizes.<span class="built_in">end</span>(), std::<span class="built_in">string</span>(), [](<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> size) &#123;</span><br><span class="line">                    <span class="keyword">return</span> str.<span class="built_in">empty</span>() ? std::<span class="built_in">to_string</span>(size) : str + <span class="string">&quot;,&quot;</span> + std::<span class="built_in">to_string</span>(size);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; size_str &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">            <span class="type">const</span> std::string name;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> value;</span><br><span class="line">        &#125;;</span><br><span class="line">        std::vector&lt;Foo&gt; foos;</span><br><span class="line">        foos.<span class="built_in">emplace_back</span>(Foo&#123;<span class="string">&quot;foo1&quot;</span>, <span class="number">1</span>&#125;);</span><br><span class="line">        foos.<span class="built_in">emplace_back</span>(Foo&#123;<span class="string">&quot;foo2&quot;</span>, <span class="number">2</span>&#125;);</span><br><span class="line">        foos.<span class="built_in">emplace_back</span>(Foo&#123;<span class="string">&quot;foo3&quot;</span>, <span class="number">3</span>&#125;);</span><br><span class="line">        foos.<span class="built_in">emplace_back</span>(Foo&#123;<span class="string">&quot;foo4&quot;</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        foos.<span class="built_in">emplace_back</span>(Foo&#123;<span class="string">&quot;foo5&quot;</span>, <span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line">        std::map&lt;std::string, <span class="type">int</span>&gt; name_to_value;</span><br><span class="line">        std::<span class="built_in">transform</span>(foos.<span class="built_in">begin</span>(), foos.<span class="built_in">end</span>(), std::<span class="built_in">inserter</span>(name_to_value, name_to_value.<span class="built_in">end</span>()),</span><br><span class="line">                       [](<span class="type">const</span> Foo&amp; foo) &#123; <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(foo.name, foo.value); &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [name, value] : name_to_value) &#123;</span><br><span class="line">            std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="113-stdremove_if"><a class="markdownIt-Anchor" href="#113-stdremove_if"></a> 1.1.3 std::remove_if</h3>
<p>用于将容器中满足条件的元素挪到最后，并返回指向这部分元素的起始迭代器，一般配合<code>erase</code>一起用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; container&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    container.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(container.<span class="built_in">begin</span>(), container.<span class="built_in">end</span>(), [](<span class="type">int</span> v) &#123; <span class="keyword">return</span> v % <span class="number">2</span> != <span class="number">0</span>; &#125;),</span><br><span class="line">                    container.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; v : container) &#123;</span><br><span class="line">        std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-sorting-operations"><a class="markdownIt-Anchor" href="#12-sorting-operations"></a> 1.2 Sorting operations</h2>
<ol>
<li><code>std::is_sorted</code></li>
<li><code>std::is_sorted_until</code></li>
<li><code>std::sort</code></li>
<li><code>std::partial_sort</code></li>
<li><code>std::partial_sort_copy</code></li>
<li><code>std::stable_sort</code></li>
<li><code>std::nth_element</code></li>
<li><code>std::merge</code></li>
<li><code>std::inplace_merge</code></li>
</ol>
<h3 id="121-stdsort"><a class="markdownIt-Anchor" href="#121-stdsort"></a> 1.2.1 std::sort</h3>
<p><strong>注意：<code>comparator</code>要返回的是<code>bool</code>，而非整型</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; nums&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    std::<span class="built_in">copy</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int32_t</span>&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int32_t</span> i, <span class="type">int32_t</span> j) &#123; <span class="keyword">return</span> j &lt; i; &#125;);</span><br><span class="line">    std::<span class="built_in">copy</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int32_t</span>&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; intervals;</span><br><span class="line">    intervals.<span class="built_in">emplace_back</span>(std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    intervals.<span class="built_in">emplace_back</span>(std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">2</span>, <span class="number">6</span>&#125;);</span><br><span class="line">    intervals.<span class="built_in">emplace_back</span>(std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">8</span>, <span class="number">10</span>&#125;);</span><br><span class="line">    intervals.<span class="built_in">emplace_back</span>(std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">15</span>, <span class="number">18</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get wrong order if using i1[0] - i2[0], should be i1[0] &lt; i2[0] here</span></span><br><span class="line">    std::<span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; i1, <span class="keyword">auto</span>&amp; i2) &#123; <span class="keyword">return</span> i1[<span class="number">0</span>] - i2[<span class="number">0</span>]; &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; intervals[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="122-stdmerge"><a class="markdownIt-Anchor" href="#122-stdmerge"></a> 1.2.2 std::merge</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; left&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; right&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; dest1;</span><br><span class="line">    std::<span class="built_in">merge</span>(left.<span class="built_in">begin</span>(), left.<span class="built_in">end</span>(), right.<span class="built_in">begin</span>(), right.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(dest1));</span><br><span class="line">    std::<span class="built_in">copy</span>(dest1.<span class="built_in">begin</span>(), dest1.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int32_t</span>&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; dest2;</span><br><span class="line">    dest2.<span class="built_in">resize</span>(left.<span class="built_in">size</span>() + right.<span class="built_in">size</span>());</span><br><span class="line">    std::<span class="built_in">merge</span>(left.<span class="built_in">begin</span>(), left.<span class="built_in">end</span>(), right.<span class="built_in">begin</span>(), right.<span class="built_in">end</span>(), dest2.<span class="built_in">begin</span>());</span><br><span class="line">    std::<span class="built_in">copy</span>(dest2.<span class="built_in">begin</span>(), dest2.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int32_t</span>&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="123-stdinplace_merge"><a class="markdownIt-Anchor" href="#123-stdinplace_merge"></a> 1.2.3 std::inplace_merge</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; nums&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; dest;</span><br><span class="line">    std::<span class="built_in">inplace_merge</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + <span class="number">5</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">    std::<span class="built_in">copy</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int32_t</span>&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-non-modifying-sequence-operations"><a class="markdownIt-Anchor" href="#13-non-modifying-sequence-operations"></a> 1.3 Non-modifying Sequence Operations</h2>
<ol>
<li><code>std::all_of</code></li>
<li><code>std::any_of</code></li>
<li><code>std::none_of</code></li>
<li><code>std::for_each</code></li>
<li><code>std::for_each_n</code></li>
<li><code>std::count</code></li>
<li><code>std::count_if</code></li>
<li><code>std::mismatch</code></li>
<li><code>std::find</code></li>
<li><code>std::find_if</code></li>
<li><code>std::find_if_not</code></li>
<li><code>std::find_end</code></li>
<li><code>std::find_first_of</code></li>
<li><code>std::adjacent_find</code></li>
<li><code>std::search</code></li>
<li><code>std::search_n</code></li>
<li><code>std::max_element</code>：return iterator of the max element</li>
<li><code>std::min_element</code>：return iterator of the min element</li>
<li><code>std::max</code></li>
<li><code>std::min</code></li>
</ol>
<h3 id="131-stdfor_each"><a class="markdownIt-Anchor" href="#131-stdfor_each"></a> 1.3.1 std::for_each</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; nums&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int32_t</span> num) &#123; std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot;, &quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-binary-search-operations-on-sorted-ranges"><a class="markdownIt-Anchor" href="#14-binary-search-operations-on-sorted-ranges"></a> 1.4 Binary Search Operations (on sorted ranges)</h2>
<ol>
<li><code>std::lower_bound(first, last, value, comp)</code>: Searches for the first element in the partitioned range <code>[first, last)</code> which is not ordered before value.</li>
<li><code>std::upper_bound</code>: Searches for the first element in the partitioned range <code>[first, last)</code> which is ordered after value.</li>
<li><code>std::binary_search</code></li>
<li><code>std::equal_range</code></li>
</ol>
<h3 id="141-stdlower_bound-stdupper_bound"><a class="markdownIt-Anchor" href="#141-stdlower_bound-stdupper_bound"></a> 1.4.1 std::lower_bound &amp; std::upper_bound</h3>
<p><strong>Case 1:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    std::<span class="built_in">copy</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> find_lower_bound = [&amp;nums](<span class="type">int</span> target) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;the lower_bound of &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; is: &quot;</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line">        <span class="keyword">if</span> (it == nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-1</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">find_lower_bound</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0,1,2,3,3,3,4,4,5,10,11,13,</span><br><span class="line">the lower_bound of -1 is: 0</span><br><span class="line">the lower_bound of 0 is: 0</span><br><span class="line">the lower_bound of 1 is: 1</span><br><span class="line">the lower_bound of 2 is: 2</span><br><span class="line">the lower_bound of 3 is: 3</span><br><span class="line">the lower_bound of 4 is: 4</span><br><span class="line">the lower_bound of 5 is: 5</span><br><span class="line">the lower_bound of 6 is: 10</span><br><span class="line">the lower_bound of 7 is: 10</span><br><span class="line">the lower_bound of 8 is: 10</span><br><span class="line">the lower_bound of 9 is: 10</span><br><span class="line">the lower_bound of 10 is: 10</span><br><span class="line">the lower_bound of 11 is: 11</span><br><span class="line">the lower_bound of 12 is: 13</span><br><span class="line">the lower_bound of 13 is: 13</span><br><span class="line">the lower_bound of 14 is: nullptr</span><br></pre></td></tr></table></figure>
<p><strong>Case 2:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>&#125;;</span><br><span class="line">    std::<span class="built_in">copy</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> find_upper_bound = [&amp;nums](<span class="type">int</span> target) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;the upper_bound of &quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot; is: &quot;</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line">        <span class="keyword">if</span> (it == nums.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-1</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">find_upper_bound</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0,1,2,3,3,3,4,4,5,10,11,13,</span><br><span class="line">the upper_bound of -1 is: 0</span><br><span class="line">the upper_bound of 0 is: 1</span><br><span class="line">the upper_bound of 1 is: 2</span><br><span class="line">the upper_bound of 2 is: 3</span><br><span class="line">the upper_bound of 3 is: 4</span><br><span class="line">the upper_bound of 4 is: 5</span><br><span class="line">the upper_bound of 5 is: 10</span><br><span class="line">the upper_bound of 6 is: 10</span><br><span class="line">the upper_bound of 7 is: 10</span><br><span class="line">the upper_bound of 8 is: 10</span><br><span class="line">the upper_bound of 9 is: 10</span><br><span class="line">the upper_bound of 10 is: 11</span><br><span class="line">the upper_bound of 11 is: 13</span><br><span class="line">the upper_bound of 12 is: 13</span><br><span class="line">the upper_bound of 13 is: nullptr</span><br><span class="line">the upper_bound of 14 is: nullptr</span><br></pre></td></tr></table></figure>
<p><strong>Case 3:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> pos;</span><br><span class="line">    <span class="type">int32_t</span> val;</span><br><span class="line">    <span class="built_in">Value</span>(<span class="type">const</span> <span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">int32_t</span> val) : <span class="built_in">pos</span>(pos), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">comp</span><span class="params">(<span class="type">const</span> Value&amp; v1, <span class="type">const</span> Value&amp; v2)</span> </span>&#123; <span class="keyword">return</span> v1.val &lt; v2.val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Value&amp; value) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; value.pos &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; value.val &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lower_bound_insert = [](std::list&lt;Value&gt;&amp; l, <span class="type">const</span> Value&amp; value) &#123;</span><br><span class="line">        l.<span class="built_in">insert</span>(std::<span class="built_in">lower_bound</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), value, Value::comp), value);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> upper_bound_insert = [](std::list&lt;Value&gt;&amp; l, <span class="type">const</span> Value&amp; value) &#123;</span><br><span class="line">        l.<span class="built_in">insert</span>(std::<span class="built_in">upper_bound</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), value, Value::comp), value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        std::list&lt;Value&gt; l;</span><br><span class="line">        <span class="built_in">lower_bound_insert</span>(l, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">lower_bound_insert</span>(l, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">lower_bound_insert</span>(l, &#123;<span class="number">3</span>, <span class="number">2</span>&#125;);</span><br><span class="line">        <span class="built_in">lower_bound_insert</span>(l, &#123;<span class="number">4</span>, <span class="number">2</span>&#125;);</span><br><span class="line">        <span class="built_in">lower_bound_insert</span>(l, &#123;<span class="number">5</span>, <span class="number">2</span>&#125;);</span><br><span class="line">        <span class="built_in">lower_bound_insert</span>(l, &#123;<span class="number">6</span>, <span class="number">2</span>&#125;);</span><br><span class="line">        <span class="built_in">lower_bound_insert</span>(l, &#123;<span class="number">7</span>, <span class="number">3</span>&#125;);</span><br><span class="line">        <span class="built_in">lower_bound_insert</span>(l, &#123;<span class="number">8</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        std::<span class="built_in">copy</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;Value&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        std::list&lt;Value&gt; l;</span><br><span class="line">        <span class="built_in">upper_bound_insert</span>(l, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">upper_bound_insert</span>(l, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">upper_bound_insert</span>(l, &#123;<span class="number">3</span>, <span class="number">2</span>&#125;);</span><br><span class="line">        <span class="built_in">upper_bound_insert</span>(l, &#123;<span class="number">4</span>, <span class="number">2</span>&#125;);</span><br><span class="line">        <span class="built_in">upper_bound_insert</span>(l, &#123;<span class="number">5</span>, <span class="number">2</span>&#125;);</span><br><span class="line">        <span class="built_in">upper_bound_insert</span>(l, &#123;<span class="number">6</span>, <span class="number">2</span>&#125;);</span><br><span class="line">        <span class="built_in">upper_bound_insert</span>(l, &#123;<span class="number">7</span>, <span class="number">3</span>&#125;);</span><br><span class="line">        <span class="built_in">upper_bound_insert</span>(l, &#123;<span class="number">8</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        std::<span class="built_in">copy</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;Value&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(2, 1),(1, 1),(6, 2),(5, 2),(4, 2),(3, 2),(7, 3),(8, 4),</span><br><span class="line">(1, 1),(2, 1),(3, 2),(4, 2),(5, 2),(6, 2),(7, 3),(8, 4),</span><br></pre></td></tr></table></figure>
<h2 id="15-set-operations"><a class="markdownIt-Anchor" href="#15-set-operations"></a> 1.5 Set Operations</h2>
<ol>
<li><code>std::set_intersection</code></li>
<li><code>std::set_union</code></li>
<li><code>std::set_difference</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; nums1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; nums2&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; intersection_res;</span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; union_res;</span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; difference_res;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">set_intersection</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>(), nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(intersection_res));</span><br><span class="line">    std::<span class="built_in">set_union</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>(), nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(union_res));</span><br><span class="line">    std::<span class="built_in">set_difference</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>(), nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(difference_res));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> print = [](<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::vector&lt;<span class="type">int32_t</span>&gt;&amp; nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        std::<span class="built_in">copy</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int32_t</span>&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;intersection&quot;</span>, intersection_res);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;union&quot;</span>, union_res);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;difference&quot;</span>, difference_res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-any"><a class="markdownIt-Anchor" href="#2-any"></a> 2 any</h1>
<p><strong><code>std::any</code>用于持有任意类型的对象，类似于Java中的<code>java.lang.Object</code></strong></p>
<ul>
<li><code>std::any_cast</code>用于将<code>any</code>对象转换成对应的类型。若类型错误则会抛出<code>std::bad_any_cast</code></li>
</ul>
<p><strong>其实现方式也很直观，在堆上分配内存，用该分配的内存存储拷贝后的对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;any&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Object()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Object&amp; obj) &#123; std::cout &lt;&lt; <span class="string">&quot;Object(const Object&amp; obj)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Object</span>(Object&amp;&amp; obj) &#123; std::cout &lt;&lt; <span class="string">&quot;Object(Object&amp;&amp; obj)&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    Object <span class="keyword">operator</span>=(<span class="type">const</span> Object&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Object <span class="keyword">operator</span>=(Object&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object obj1;</span><br><span class="line">    Object obj2;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;declare any&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::any a1 = obj1;</span><br><span class="line">    std::any a2 = std::<span class="built_in">move</span>(obj2);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;any_cast&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    [[maybe_unused]] Object obj3 = std::<span class="built_in">any_cast</span>&lt;Object&gt;(a1);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;any_cast reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    [[maybe_unused]] Object&amp; obj4 = std::<span class="built_in">any_cast</span>&lt;Object&amp;&gt;(a2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-atomic"><a class="markdownIt-Anchor" href="#3-atomic"></a> 3 atomic</h1>
<p><code>compare_exchange_strong(T&amp; expected_value, T new_value)</code>方法的第一个参数是个左值</p>
<ul>
<li>当前值与期望值<code>expected_value</code>相等时，修改当前值为设定值<code>new_value</code>，返回true</li>
<li>当前值与期望值<code>expected_value</code>不等时，将期望值修改为当前值，返回false（这样更加方便循环，否则还得手动再读一次）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::atomic_bool flag = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> expected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="literal">true</span>)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, flag: &quot;</span> &lt;&lt; flag &lt;&lt; <span class="string">&quot;, expected: &quot;</span> &lt;&lt; expected &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="literal">true</span>)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, flag: &quot;</span> &lt;&lt; flag &lt;&lt; <span class="string">&quot;, expected: &quot;</span> &lt;&lt; expected &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result: 1, flag: 1, expected: 0</span><br><span class="line">result: 0, flag: 1, expected: 1</span><br></pre></td></tr></table></figure>
<p><strong><code>compare_exchange_weak(T&amp; expected_value, T new_value)</code>方法与<code>strong</code>版本基本相同，唯一的区别是<code>weak</code>版本允许偶然出乎意料的返回（相等时却返回了false），在大部分场景中，这种意外是可以接受的，通常比<code>strong</code>版本有更高的性能</strong></p>
<h2 id="31-stdmemory_order"><a class="markdownIt-Anchor" href="#31-stdmemory_order"></a> 3.1 std::memory_order</h2>
<p>这是个枚举类型，包含6个枚举值</p>
<ul>
<li><code>memory_order_relaxed</code></li>
<li><code>memory_order_consume</code></li>
<li><code>memory_order_acquire</code></li>
<li><code>memory_order_release</code></li>
<li><code>memory_order_acq_rel</code></li>
<li><code>memory_order_seq_cst</code></li>
</ul>
<h3 id="311-sequential-consistency-ordering"><a class="markdownIt-Anchor" href="#311-sequential-consistency-ordering"></a> 3.1.1 Sequential Consistency Ordering</h3>
<p><code>memory_order_seq_cst</code>属于这种内存模型</p>
<p><code>SC</code>作为默认的内存序，是因为它意味着将程序看做是一个简单的序列。如果对于一个原子变量的操作都是顺序一致的，那么多线程程序的行为就像是这些操作都以一种特定顺序被单线程程序执行</p>
<p><strong>该原子操作前后的读写（包括非原子的读写操作）不能跨过该操作乱序；该原子操作之前的写操作（包括非原子的写操作）都能被所有线程观察到</strong></p>
<h3 id="312-relaxed-ordering"><a class="markdownIt-Anchor" href="#312-relaxed-ordering"></a> 3.1.2 Relaxed Ordering</h3>
<p><code>memory_order_relaxed</code>属于这种内存模型</p>
<ul>
<li>不满足<code>atomic-write happens-before atomic-read</code>的规则</li>
<li>同一个线程内，同一个原子变量的多个操作不可重排</li>
<li>同一个线程内，不同原子变量之间的操作可以重排（x86不允许这么做）</li>
<li>同一个线程内，<code>normal write</code>和<code>atomic write</code>允许重排（x86不允许这么做）</li>
<li>同一个线程内，<code>normal read</code>和<code>atomic read</code>允许重排（x86不允许这么做）</li>
<li><strong>唯一能保证的是，不同线程看到的该变量的修改顺序是一致的</strong></li>
</ul>
<h3 id="313-acquire-release-ordering"><a class="markdownIt-Anchor" href="#313-acquire-release-ordering"></a> 3.1.3 Acquire-Release Ordering</h3>
<p><code>memory_order_release</code>、<code>memory_order_acquire</code>、<code>memory_order_acq_rel</code>属于这种内存模型</p>
<p><code>memory_order_release</code>用于写操作<code>store</code>，<code>memory_order_acquire</code>用于读操作<code>load</code></p>
<ul>
<li><code>memory_order_release</code>「原子操作之前的读写（包括非原子的读写）」不能往后乱序；并且之前的写操作（包括非原子的写操作），会被使用<code>acquire/consume</code>的线程观察到，这里要注意它和<code>seq_cst</code>不同的是只有相关的线程才能观察到写变化，所谓相关线程就是使用<code>acquire</code>或<code>consume</code>模式加载同一个共享变量的线程；而<code>seq_cst</code>是所有线程都观察到了</li>
<li><code>memory_order_acquire</code>「原子操作之后的读写」不能往前乱序；它能看到<code>release</code>线程在调用<code>load</code>之前的那些写操作</li>
<li><code>memory_order_acq_rel</code>是<code>memory_order_release</code>与<code>memory_order_acquire</code>的合并，前后的读写都是不能跨过这个原子操作，但仅相关的线程能看到前面写的变化</li>
<li><code>memory_order_consume</code>和<code>memory_order_acquire</code>比较接近，也是和<code>memory_order_release</code>一起使用的；和<code>memory_order_acquire</code>不一样的地方是加了一个限定条件：依赖于该读操作的后续读写不能往前乱序；它可以看到release线程在调用load之前那些依赖的写操作，依赖于的意思是和该共享变量有关的写操作</li>
</ul>
<p>看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-Thread 1-</span><br><span class="line"> n = 1</span><br><span class="line"> m = 1</span><br><span class="line"> p.store (&amp;n, memory_order_release)</span><br><span class="line"></span><br><span class="line">-Thread 2-</span><br><span class="line"> t = p.load (memory_order_acquire);</span><br><span class="line"> if (*t == 1)</span><br><span class="line">    assert(m == 1);</span><br><span class="line"></span><br><span class="line">-Thread 3-</span><br><span class="line"> t = p.load (memory_order_consume);</span><br><span class="line"> if (*t == 1)</span><br><span class="line">    assert(m == 1);</span><br></pre></td></tr></table></figure>
<ul>
<li>线程2的断言会成功，因为线程1对<code>n</code>和<code>m</code>在store之前修改；线程2在<code>load</code>之后，可以观察到<code>m</code>的修改</li>
<li>但线程3的断言不一定会成功，因为<code>m</code>是和<code>load/store</code>操作不相关的变量，线程3不一定能观察看到</li>
</ul>
<h1 id="4-chrono"><a class="markdownIt-Anchor" href="#4-chrono"></a> 4 chrono</h1>
<h2 id="41-clock"><a class="markdownIt-Anchor" href="#41-clock"></a> 4.1 clock</h2>
<p><strong>三种时钟：</strong></p>
<ol>
<li><code>steady_clock</code>：是单调的时钟。其绝对值无意义，只会增长，适合用于记录程序耗时。</li>
<li><code>system_clock</code>：是系统的时钟，且系统的时钟可以修改，甚至可以网络对时。所以用系统时间计算时间差可能不准</li>
<li><code>high_resolution_clock</code>：是当前系统能够提供的最高精度的时钟。它也是不可以修改的。相当于<code>steady_clock</code>的高精度版本</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> nanos = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::nanoseconds&gt;(end - start).<span class="built_in">count</span>();</span><br><span class="line"><span class="keyword">auto</span> now_nanos = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::nanoseconds&gt;(</span><br><span class="line">        std::chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br></pre></td></tr></table></figure>
<h2 id="42-time_point"><a class="markdownIt-Anchor" href="#42-time_point"></a> 4.2 time_point</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Clock = std::chrono::system_clock;</span><br><span class="line">    <span class="comment">// Convert from std::chrono::time_point to time_t</span></span><br><span class="line">    Clock::time_point now_tp = Clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="type">time_t</span> now_tt = Clock::<span class="built_in">to_time_t</span>(now_tp);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current time (time_t): &quot;</span> &lt;&lt; now_tt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert from time_t to std::tm (local time)</span></span><br><span class="line">    std::tm now_tm = *std::<span class="built_in">localtime</span>(&amp;now_tt);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current time (std::tm): &quot;</span> &lt;&lt; now_tm.tm_hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; now_tm.tm_min &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; now_tm.tm_sec</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert from std::tm to std::chrono::time_point</span></span><br><span class="line">    <span class="type">time_t</span> back_to_tt = std::<span class="built_in">mktime</span>(&amp;now_tm);</span><br><span class="line">    Clock::time_point back_to_tp = Clock::<span class="built_in">from_time_t</span>(back_to_tt);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back to std::chrono::time_point&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-filesystem"><a class="markdownIt-Anchor" href="#5-filesystem"></a> 5 filesystem</h1>
<ol>
<li><code>std::filesystem::copy</code></li>
<li><code>std::filesystem::copy_file</code></li>
<li><code>std::filesystem::exist</code></li>
<li><code>std::filesystem::file_size</code></li>
<li><code>std::filesystem::is_directory</code></li>
<li><code>std::filesystem::is_regular_file</code></li>
<li><code>std::filesystem::remove</code></li>
<li><code>std::filesystem::rename</code></li>
</ol>
<h1 id="6-fstream"><a class="markdownIt-Anchor" href="#6-fstream"></a> 6 fstream</h1>
<h2 id="61-stdifstream"><a class="markdownIt-Anchor" href="#61-stdifstream"></a> 6.1 std::ifstream</h2>
<p><strong>Case 1: Read entire content at one time.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;main.cpp&quot;</span>)</span></span>;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    <span class="comment">// Read entire content</span></span><br><span class="line">    ss &lt;&lt; ifs.<span class="built_in">rdbuf</span>();</span><br><span class="line">    std::cout &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Case 2: Read line.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;main.cpp&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error opening file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(file, line)) &#123;</span><br><span class="line">        std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Case 3: Read content separated by a specific delimiter.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;main.cpp&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error opening file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> delimiter = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(file, line, delimiter)) &#123;</span><br><span class="line">        std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>std::ofstream</code></li>
</ol>
<h1 id="7-functional"><a class="markdownIt-Anchor" href="#7-functional"></a> 7 functional</h1>
<ol>
<li><code>std::less</code>, <code>std::greater</code>, <code>std::less_equal</code>, <code>std::greater_equal</code>: Comparator</li>
<li><code>std::function</code>：其功能类似于函数指针，在需要函数指针的地方，可以传入<code>std::function</code>类型的对象（不是指针）</li>
<li><code>std::bind</code></li>
<li><code>std::hash</code>: Function object, use it like this <code>std::hash&lt;int&gt;()(5)</code></li>
<li><code>std::mem_fn</code></li>
<li><code>std::reference_wrapper</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="keyword">auto</span> <span class="type">const</span> rem, <span class="type">const</span> <span class="keyword">auto</span>&amp; c)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; rem;</span><br><span class="line">    std::ranges::<span class="built_in">copy</span>(c, std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int32_t</span>&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), <span class="number">-4</span>);</span><br><span class="line">    <span class="comment">// can&#x27;t use shuffle on a list (requires random access), but can use it on a vector</span></span><br><span class="line">    std::vector&lt;std::reference_wrapper&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">    std::ranges::<span class="built_in">shuffle</span>(v, std::mt19937&#123;std::random_device&#123;&#125;()&#125;);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Contents of the list: &quot;</span>, l);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Contents of the list, as seen through a shuffled vector: &quot;</span>, v);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doubling the values in the initial list...\n&quot;</span>;</span><br><span class="line">    std::ranges::for_each(l, [](<span class="type">int</span>&amp; i) &#123; i *= <span class="number">2</span>; &#125;);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Contents of the list, as seen through a shuffled vector: &quot;</span>, v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="71-reference"><a class="markdownIt-Anchor" href="#71-reference"></a> 7.1 Reference</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f191e88dcc80">C++11 中的std::function和std::bind</a></li>
</ul>
<h1 id="8-future"><a class="markdownIt-Anchor" href="#8-future"></a> 8 future</h1>
<ol>
<li><code>std::promise</code></li>
<li><code>std::future</code></li>
</ol>
<h1 id="9-iomanip"><a class="markdownIt-Anchor" href="#9-iomanip"></a> 9 iomanip</h1>
<p>iomanip stands for input/output manipulators</p>
<ol>
<li>
<p><code>std::get_time</code>: Refer to <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/io/manip/get_time">std::get_time</a> for all supported time format.</p>
</li>
<li>
<p><code>std::put_time</code></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string date_str = <span class="string">&quot;2023-09-15 20:30&quot;</span>;</span><br><span class="line">    std::tm tm = &#123;&#125;;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">ss</span><span class="params">(date_str)</span></span>;</span><br><span class="line"></span><br><span class="line">    ss &gt;&gt; std::<span class="built_in">get_time</span>(&amp;tm, <span class="string">&quot;%Y-%m-%d %H:%M&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ss.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parse error.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Successfully parsed: &quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;Year: &quot;</span> &lt;&lt; tm.tm_year + <span class="number">1900</span> &lt;&lt; <span class="string">&quot;, Month: &quot;</span> &lt;&lt; tm.tm_mon + <span class="number">1</span> &lt;&lt; <span class="string">&quot;, Day: &quot;</span> &lt;&lt; tm.tm_mday</span><br><span class="line">                &lt;&lt; <span class="string">&quot;, Hour: &quot;</span> &lt;&lt; tm.tm_hour &lt;&lt; <span class="string">&quot;, Minute: &quot;</span> &lt;&lt; tm.tm_min &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="type">time_t</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::tm* now_tm = std::<span class="built_in">localtime</span>(&amp;now_c);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current time: &quot;</span> &lt;&lt; std::<span class="built_in">put_time</span>(now_tm, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>std::get_money</code></p>
</li>
<li>
<p><code>std::put_money</code></p>
</li>
</ol>
<h1 id="10-iostream"><a class="markdownIt-Anchor" href="#10-iostream"></a> 10 iostream</h1>
<ol>
<li><code>std::cout</code></li>
<li><code>std::cin</code></li>
<li><code>std::endl</code></li>
<li><code>std::boolalpha</code></li>
<li><code>std::noboolalpha</code></li>
</ol>
<h1 id="11-iterator"><a class="markdownIt-Anchor" href="#11-iterator"></a> 11 iterator</h1>
<h2 id="111-stream-iterators"><a class="markdownIt-Anchor" href="#111-stream-iterators"></a> 11.1 Stream Iterators</h2>
<ol>
<li><code>std::istream_iterator</code></li>
<li><code>std::ostream_iterator</code></li>
<li><code>std::istreambuf_iterator</code></li>
<li><code>std::ostreambuf_iterator</code></li>
</ol>
<h2 id="112-operations"><a class="markdownIt-Anchor" href="#112-operations"></a> 11.2 Operations</h2>
<ol>
<li><code>std::advance</code></li>
<li><code>std::distance</code></li>
<li><code>std::next</code></li>
<li><code>std::prev</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using std::distance to find the number of elements between two iterators</span></span><br><span class="line">    <span class="keyword">auto</span> first = numbers.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> last = numbers.<span class="built_in">end</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of elements in the vector: &quot;</span> &lt;&lt; std::<span class="built_in">distance</span>(first, last) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of elements in the vector (reverse): &quot;</span> &lt;&lt; std::<span class="built_in">distance</span>(last, first) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Distance between start and 3 is: &quot;</span> &lt;&lt; std::<span class="built_in">distance</span>(it, numbers.<span class="built_in">begin</span>()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Distance between start and 3 is (reverse): &quot;</span> &lt;&lt; std::<span class="built_in">distance</span>(numbers.<span class="built_in">begin</span>(), it) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using std::advance to move an iterator by a specific number of positions</span></span><br><span class="line">    it = numbers.<span class="built_in">begin</span>();</span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>); <span class="comment">// Advance the iterator by 2 positions</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at position 2: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using std::next to get an iterator pointing to an element at a specific position</span></span><br><span class="line">    <span class="keyword">auto</span> nextIt = std::<span class="built_in">next</span>(numbers.<span class="built_in">begin</span>(), <span class="number">3</span>); <span class="comment">// Get an iterator to the element at position 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at position 3: &quot;</span> &lt;&lt; *nextIt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using std::prev to get an iterator pointing to an element at a specific position</span></span><br><span class="line">    <span class="keyword">auto</span> prevIt = std::<span class="built_in">prev</span>(numbers.<span class="built_in">end</span>(), <span class="number">2</span>); <span class="comment">// Get an iterator to the element at position 3 from the end</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at position 3 from the end: &quot;</span> &lt;&lt; *prevIt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Number of elements in the vector: 5</span><br><span class="line">Number of elements in the vector (reverse): -5</span><br><span class="line">Distance between start and 3 is: -2</span><br><span class="line">Distance between start and 3 is (reverse): 2</span><br><span class="line">Value at position 2: 3</span><br><span class="line">Value at position 3: 4</span><br><span class="line">Value at position 3 from the end: 4</span><br></pre></td></tr></table></figure>
<h2 id="113-adaptors"><a class="markdownIt-Anchor" href="#113-adaptors"></a> 11.3 Adaptors</h2>
<ol>
<li><code>std::make_reverse_iterator</code></li>
<li><code>std::make_move_iterator</code></li>
<li><code>make_const_iterator</code></li>
</ol>
<h1 id="12-limits"><a class="markdownIt-Anchor" href="#12-limits"></a> 12 limits</h1>
<ol>
<li><code>std::numeric_limits</code>
<ul>
<li><code>std::numeric_limits&lt;int32_t&gt;::max()</code></li>
</ul>
</li>
</ol>
<h1 id="13-memory"><a class="markdownIt-Anchor" href="#13-memory"></a> 13 memory</h1>
<h2 id="131-stdshared_ptr"><a class="markdownIt-Anchor" href="#131-stdshared_ptr"></a> 13.1 std::shared_ptr</h2>
<p><strong>类型转换</strong></p>
<ul>
<li><code>std::static_pointer_cast</code></li>
<li><code>std::dynamic_pointer_cast</code></li>
<li><code>std::const_pointer_cast</code></li>
<li><code>std::reinterpret_pointer_cast</code></li>
</ul>
<p><strong>只在函数使用指针，但并不保存对象内容</strong></p>
<p>假如我们只需要在函数中，用这个对象处理一些事情，但不打算涉及其生命周期的管理，也不打算通过函数传参延长<code>shared_ptr </code>的生命周期。对于这种情况，可以使用<code>raw pointer</code>或者<code>const shared_ptr&amp;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Widget*)</span></span>;</span><br><span class="line"><span class="comment">// 不发生拷贝，引用计数未增加</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> shared_ptr&lt;Widget&gt;&amp;)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>在函数中保存智能指针</strong></p>
<p>假如我们需要在函数中把这个智能指针保存起来，这个时候建议直接传值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传参时发生拷贝，引用计数增加</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::shared_ptr&lt;Widget&gt; ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样的话，外部传过来值的时候，可以选择<code>move</code>或者赋值。函数内部直接把这个对象通过<code>move</code>的方式保存起来</p>
<h2 id="132-stdenable_shared_from_this"><a class="markdownIt-Anchor" href="#132-stdenable_shared_from_this"></a> 13.2 std::enable_shared_from_this</h2>
<p><strong><code>std::enable_shared_from_this</code>能让一个由<code>std::shared_ptr</code>管理的对象，安全地生成其他额外的<code>std::shared_ptr</code>实例，原实例和新生成的示例共享所有权</strong></p>
<ul>
<li>只能通过<code>std::make_shared</code>来创建实例（不能用<code>new</code>），否则会报错</li>
<li>普通对象（非只能指针管理）调用<code>std::enable_shared_from_this::shared_from_this</code>方法，也会报错</li>
</ul>
<p><strong>有什么用途？当你持有的是某个对象的裸指针时（该对象的生命周期由智能指针管理），但此时你又想获取该对象的智能指针，此时就需要依赖<code>std::enable_shared_from_this</code></strong></p>
<ul>
<li>不能将<code>this</code>直接放入某个<code>std::shared_ptr</code>中，这样会导致<code>delete</code>野指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Demo&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;Demo&gt;();</span><br><span class="line">    <span class="keyword">auto</span> another_ptr = ptr-&gt;<span class="built_in">shared_from_this</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; another_ptr.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="133-stdunique_ptr"><a class="markdownIt-Anchor" href="#133-stdunique_ptr"></a> 13.3 std::unique_ptr</h2>
<ul>
<li><code>release</code>是指让出控制权，不再管理生命周期，而不是释放。要释放的话可以用<code>reset</code>方法，或者直接赋值成<code>nullptr</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;dctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_ptr&lt;Foo&gt; u_ptr = std::<span class="built_in">make_unique</span>&lt;Foo&gt;();</span><br><span class="line">        u_ptr.<span class="built_in">release</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;after calling unique_ptr::release\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_ptr&lt;Foo&gt; u_ptr = std::<span class="built_in">make_unique</span>&lt;Foo&gt;();</span><br><span class="line">        u_ptr.<span class="built_in">reset</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;after calling unique_ptr::reset\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_ptr&lt;Foo&gt; u_ptr = std::<span class="built_in">make_unique</span>&lt;Foo&gt;();</span><br><span class="line">        u_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;after assigning to nullptr direcly\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="134-stdweak_ptr"><a class="markdownIt-Anchor" href="#134-stdweak_ptr"></a> 13.4 std::weak_ptr</h2>
<p>用于指向由<code>std::shared_ptr</code>管理的对象，但不负责管理改对象的生命周期。也就是说，它指向的对象可能已经被析构了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> print = [](<span class="keyword">auto</span>&amp; w_ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> ptr = w_ptr.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;active&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;inactive&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int32_t</span>&gt; s_ptr;</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int32_t</span>&gt; w_ptr = s_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(w_ptr);</span><br><span class="line"></span><br><span class="line">    s_ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int32_t</span>&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print</span>(w_ptr);</span><br><span class="line"></span><br><span class="line">    w_ptr = s_ptr;</span><br><span class="line">    <span class="built_in">print</span>(w_ptr);</span><br><span class="line"></span><br><span class="line">    s_ptr.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">print</span>(w_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="135-pointer-cast"><a class="markdownIt-Anchor" href="#135-pointer-cast"></a> 13.5 Pointer Cast</h2>
<ol>
<li><code>std::static_pointer_cast</code></li>
<li><code>std::dynamic_pointer_cast</code></li>
<li><code>std::const_pointer_cast</code></li>
<li><code>std::reinterpret_pointer_cast</code></li>
</ol>
<h2 id="136-reference"><a class="markdownIt-Anchor" href="#136-reference"></a> 13.6 Reference</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cyhone.com/articles/right-way-to-use-cpp-smart-pointer/">C++ 智能指针的正确使用方式</a></li>
</ul>
<h1 id="14-memory_resource"><a class="markdownIt-Anchor" href="#14-memory_resource"></a> 14 memory_resource</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory_resource&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a polymorphic allocator using the default memory resource</span></span><br><span class="line">    std::pmr::polymorphic_allocator&lt;<span class="type">int</span>&gt; allocator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for an array of integers</span></span><br><span class="line">    <span class="type">int</span>* p = allocator.<span class="built_in">allocate</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the allocated memory</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do something with the allocated memory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deallocate memory when done</span></span><br><span class="line">    allocator.<span class="built_in">deallocate</span>(p, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="15-mutex"><a class="markdownIt-Anchor" href="#15-mutex"></a> 15 mutex</h1>
<ol>
<li>
<p><code>std::mutex</code>：不可重入的互斥量</p>
</li>
<li>
<p><code>std::recursive_mutex</code>：可重入的互斥量</p>
</li>
<li>
<p><code>std::lock_guard</code></p>
<ul>
<li>直接使用<code>std::mutex</code>，如下面的例子。如果<code>getVar</code>方法抛出异常了，那么就会导致<code>m.unlock()</code>方法无法执行，可能会造成死锁</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mutex m;</span><br><span class="line">m.<span class="built_in">lock</span>();</span><br><span class="line">sharedVariable= <span class="built_in">getVar</span>();</span><br><span class="line">m.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>一种优雅的方式是使用<code>std::lock_guard</code>，该对象的析构方法中会进行锁的释放，需要将串行部分放到一个<code>&#123;&#125;</code>中，当退出该作用域时，<code>std::lock_guard</code>对象会析构，并释放锁，在任何正常或异常情况下都能够释放锁</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockGuard</span><span class="params">(m)</span></span>;</span><br><span class="line">    sharedVariable= <span class="built_in">getVar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>std::unique_lock</code>：比<code>std::lock_guard</code>提供更多的操作，允许手动加锁解锁</p>
</li>
<li>
<p><code>std::condition_variable</code></p>
<ul>
<li>需要链接<code>libpthread</code>库，否则<code>wait</code>方法会立即唤醒，且编译不会报错</li>
<li>调用<code>wait</code>方法时，必须获取监视器。而调用<code>notify</code>方法时，无需获取监视器</li>
<li><code>wait</code>方法被唤醒后，仍然处于获取监视器的状态</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::mutex m;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">cv.<span class="built_in">wait</span>(l);</span><br><span class="line"><span class="comment">// wake up here, and still under lock</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>std::call_once</code>、<code>std::once_flag</code></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::once_flag flag;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>([&amp;]() &#123; std::<span class="built_in">call_once</span>(flag, say_hello); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="151-reference"><a class="markdownIt-Anchor" href="#151-reference"></a> 15.1 Reference</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17101922/do-i-have-to-acquire-lock-before-calling-condition-variable-notify-one">Do I have to acquire lock before calling condition_variable.notify_one()?</a></li>
</ul>
<h1 id="16-numeric"><a class="markdownIt-Anchor" href="#16-numeric"></a> 16 numeric</h1>
<ol>
<li>
<p><code>std::accumulate</code></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;std::string&gt; col = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::string res = std::<span class="built_in">accumulate</span>(std::<span class="built_in">begin</span>(col),</span><br><span class="line">                                    std::<span class="built_in">end</span>(col),</span><br><span class="line">                                    std::<span class="built_in">string</span>(),</span><br><span class="line">                                    [](<span class="type">const</span> std::string &amp;a, <span class="type">const</span> std::string &amp;b) &#123;</span><br><span class="line">                                        <span class="keyword">return</span> a.<span class="built_in">empty</span>() ? b</span><br><span class="line">                                                        : a + <span class="string">&quot;, &quot;</span> + b;</span><br><span class="line">                                    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>std::iota</code>：给指定区间以递增的方式赋值</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">    std::ranges::<span class="built_in">copy</span>(nums, std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int32_t</span>&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="17-optional"><a class="markdownIt-Anchor" href="#17-optional"></a> 17 optional</h1>
<ol>
<li><code>std::optional</code>
<ul>
<li><code>std::nullopt</code></li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">create</span><span class="params">(<span class="type">bool</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Godzilla&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">create</span>(<span class="literal">false</span>).<span class="built_in">value_or</span>(<span class="string">&quot;empty&quot;</span>); <span class="comment">// == &quot;empty&quot;</span></span><br><span class="line">    <span class="built_in">create</span>(<span class="literal">true</span>).<span class="built_in">value</span>();            <span class="comment">// == &quot;Godzilla&quot;</span></span><br><span class="line">    <span class="comment">// optional-returning factory functions are usable as conditions of while and if</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> str = <span class="built_in">create</span>(<span class="literal">true</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create(true) is true, str=&quot;</span> &lt;&lt; str.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create(true) is false&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> str = <span class="built_in">create</span>(<span class="literal">false</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create(false) is true, str=&quot;</span> &lt;&lt; str.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create(false) is false&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="18-queue"><a class="markdownIt-Anchor" href="#18-queue"></a> 18 queue</h1>
<h2 id="181-stdpriority_queue"><a class="markdownIt-Anchor" href="#181-stdpriority_queue"></a> 18.1 std::priority_queue</h2>
<p><code>std::priority_queue</code> in C++ Standard Template Library (STL) is a container adapter that provides functionality to maintain a collection of elements sorted by priority. It is typically implemented as a max-heap, meaning the largest element is always at the front of the queue. There are three template parameters in <code>std::priority_queue</code>, each serving a specific purpose:</p>
<ul>
<li><strong>First Template Parameter - <code>T</code>:</strong>
<ul>
<li>This represents the type of elements stored in the priority queue. For example, if you want a priority queue that stores integers, you would use <code>std::priority_queue&lt;int&gt;</code>.</li>
</ul>
</li>
<li><strong>Second Template Parameter - <code>Container</code>:</strong>
<ul>
<li>This specifies the type of the underlying container used to store the elements of the queue. By default, <code>std::priority_queue</code> uses <code>std::vector</code> as its underlying container, but you can use other container types like <code>std::deque</code>. The chosen container must support <code>front()</code>, <code>push_back()</code>, and <code>pop_back()</code> operations.</li>
</ul>
</li>
<li><strong>Third Template Parameter - <code>Compare</code>:</strong>
<ul>
<li>This is a comparison function object that determines the order of priority of the elements. By default, <code>std::priority_queue</code> uses <code>std::less&lt;T&gt;</code>, meaning that larger elements are considered to have higher priority. If you want a min-heap (where the smallest element is at the front), you can use <code>std::greater&lt;T&gt;</code> as this parameter.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Cmp</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Item&amp; i1, <span class="type">const</span> Item&amp; i2)</span> </span>&#123; <span class="keyword">return</span> i1.value &lt; i2.value; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::priority_queue&lt;Item, std::vector&lt;Item&gt;, Item::Cmp&gt; max_heap;</span><br><span class="line"></span><br><span class="line">    max_heap.<span class="built_in">push</span>(&#123;<span class="number">1</span>&#125;);</span><br><span class="line">    max_heap.<span class="built_in">push</span>(&#123;<span class="number">2</span>&#125;);</span><br><span class="line">    max_heap.<span class="built_in">push</span>(&#123;<span class="number">3</span>&#125;);</span><br><span class="line">    max_heap.<span class="built_in">push</span>(&#123;<span class="number">4</span>&#125;);</span><br><span class="line">    max_heap.<span class="built_in">push</span>(&#123;<span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!max_heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; max_heap.<span class="built_in">top</span>().value &lt;&lt; std::endl;</span><br><span class="line">        max_heap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="19-random"><a class="markdownIt-Anchor" href="#19-random"></a> 19 random</h1>
<ol>
<li><code>std::default_random_engine</code></li>
<li><code>std::uniform_int_distribution</code>：左闭右闭区间</li>
</ol>
<h1 id="20-ranges"><a class="markdownIt-Anchor" href="#20-ranges"></a> 20 ranges</h1>
<p><code>ranges</code>可以看做是对于<code>algorithm</code>中算法的封装，可以省去<code>begin()</code>、<code>end()</code>等调用，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; nums&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int32_t</span> num) &#123; std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot;,&quot;</span>; &#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::ranges::for_each(nums, [](<span class="type">int32_t</span> num) &#123; std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot;,&quot;</span>; &#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::ranges::<span class="built_in">copy</span>(nums, std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int32_t</span>&gt;(std::cout, <span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="21-stdexcept"><a class="markdownIt-Anchor" href="#21-stdexcept"></a> 21 stdexcept</h1>
<ol>
<li><code>std::logic_error</code></li>
<li><code>std::invalid_argument</code></li>
<li><code>std::domain_error</code></li>
<li><code>std::length_error</code></li>
<li><code>std::out_of_range</code></li>
<li><code>std::runtime_error</code></li>
<li><code>std::range_error</code></li>
<li><code>std::overflow_error</code></li>
<li><code>std::underflow_error</code></li>
</ol>
<h1 id="22-exception"><a class="markdownIt-Anchor" href="#22-exception"></a> 22 exception</h1>
<ol>
<li>
<p><code>std::uncaught_exceptions</code></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">char</span> id&#123;<span class="string">&#x27;?&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count = std::<span class="built_in">uncaught_exceptions</span>();</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123;</span><br><span class="line">        count == std::<span class="built_in">uncaught_exceptions</span>() ? std::cout &lt;&lt; id &lt;&lt; <span class="string">&quot;.~Foo() called normally\n&quot;</span></span><br><span class="line">                                            : std::cout &lt;&lt; id &lt;&lt; <span class="string">&quot;.~Foo() called during stack unwinding\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo f&#123;<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Foo g&#123;<span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception thrown\n&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;test exception&quot;</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception thrown</span><br><span class="line">g.~Foo() called during stack unwinding</span><br><span class="line">Exception caught: test exception</span><br><span class="line">f.~Foo() called normally</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>std::current_exception</code></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;An error occurred&quot;</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::exception_ptr ptr = std::<span class="built_in">current_exception</span>();</span><br><span class="line">        <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                std::<span class="built_in">rethrow_exception</span>(ptr);</span><br><span class="line">            &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Caught unknown exception&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="221-sstring"><a class="markdownIt-Anchor" href="#221-sstring"></a> 22.1 sstring</h2>
<ol>
<li><code>std::stringstream</code></li>
<li><code>std::istringstream</code>: Use this and <code>std::getline</code> to achieve the function of spliting a string</li>
<li><code>std::ostringstream</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int32_t</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">str</span><span class="params">(<span class="string">&quot;a,b,c,d,e,f,g&quot;</span>)</span></span>;</span><br><span class="line">    std::string next;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(str, next, <span class="string">&#x27;,&#x27;</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; next &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="23-shared_mutex"><a class="markdownIt-Anchor" href="#23-shared_mutex"></a> 23 shared_mutex</h1>
<ol>
<li><code>std::shared_mutex</code></li>
<li><code>std::shared_timed_mutex</code></li>
<li><code>std::shared_lock</code></li>
</ol>
<h1 id="24-string"><a class="markdownIt-Anchor" href="#24-string"></a> 24 string</h1>
<ol>
<li><code>std::string</code>: char</li>
<li><code>std::wstring</code>: wchar_t</li>
<li><code>std::u8string</code>: char8_t</li>
<li><code>std::u16string</code>: char16_t</li>
<li><code>std::u32string</code>: char32_t</li>
<li><code>std::to_string</code></li>
<li><code>std::string::npos</code>: This is a special value equal to the maximum value representable by the type size_type.</li>
<li><code>std::getline</code>: getline reads characters from an input stream and places them into a string.</li>
</ol>
<h1 id="25-thread"><a class="markdownIt-Anchor" href="#25-thread"></a> 25 thread</h1>
<ol>
<li><code>std::thread::hardware_concurrency</code></li>
<li><code>std::this_thread</code></li>
</ol>
<h2 id="251-how-to-set-thread-name"><a class="markdownIt-Anchor" href="#251-how-to-set-thread-name"></a> 25.1 How to set thread name</h2>
<ol>
<li><code>pthread_setname_np/pthread_getname_np</code>，需要引入头文件<code>&lt;pthread.h&gt;</code>，<code>np</code>表示<code>non-portable</code>，即平台相关</li>
<li><code>prctl(PR_GET_NAME, name)/prctl(PR_SET_NAME, name)</code>，需要引入头文件<code>&lt;sys/prctl.h&gt;</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">change_thread_name</span><span class="params">(<span class="type">void</span>* = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// avoid change name before set original thread name</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> original_thread_name[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">prctl</span>(PR_GET_NAME, original_thread_name);</span><br><span class="line">    <span class="type">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; original_thread_name &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; cnt++;</span><br><span class="line">        <span class="built_in">prctl</span>(PR_SET_NAME, ss.<span class="built_in">str</span>().<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> current_thread_name[<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">prctl</span>(PR_GET_NAME, current_thread_name);</span><br><span class="line">        std::cout &lt;&lt; current_thread_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_thread_by_pthread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, change_thread_name, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(tid, <span class="string">&quot;pthread&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_thread_by_std</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func = []() &#123; <span class="built_in">change_thread_name</span>(); &#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(t.<span class="built_in">native_handle</span>(), <span class="string">&quot;std-thread&quot;</span>);</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">333</span>));</span><br><span class="line">    <span class="built_in">create_thread_by_pthread</span>();</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">333</span>));</span><br><span class="line">    <span class="built_in">create_thread_by_std</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">prctl</span>(PR_SET_NAME, <span class="string">&quot;main&quot;</span>);</span><br><span class="line">    <span class="built_in">change_thread_name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="252-how-to-set-thread-affinity"><a class="markdownIt-Anchor" href="#252-how-to-set-thread-affinity"></a> 25.2 How to set thread affinity</h2>
<p>下面示例代码用于测试各个CPU的性能</p>
<ul>
<li><code>CPU_ZERO</code>：初始化</li>
<li><code>CPU_SET</code>：添加与某个CPU的亲和性，可以多次设置不同的CPU</li>
<li><code>CPU_ISSET</code>：判断是否与某个CPU存在亲和性</li>
<li><code>pthread_setaffinity_np</code>：设置某个线程的CPU亲和性</li>
<li><code>pthread_getaffinity_np</code>：获取某个线程的CPU亲和性</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread = <span class="built_in">pthread_self</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">cpu_set_t</span> cpuset;</span><br><span class="line">    <span class="built_in">CPU_ZERO</span>(&amp;cpuset);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">1</span>, &amp;cpuset);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">2</span>, &amp;cpuset);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">3</span>, &amp;cpuset);</span><br><span class="line">    <span class="built_in">CPU_SET</span>(<span class="number">4</span>, &amp;cpuset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind to core 1,2,3,4</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_setaffinity_np</span>(thread, <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_getaffinity_np</span>(thread, <span class="built_in">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;cpuset) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CPU_SETSIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CPU_ISSET</span>(i, &amp;cpuset)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;core &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="26-tuple"><a class="markdownIt-Anchor" href="#26-tuple"></a> 26 tuple</h1>
<ol>
<li>
<p><code>std::tuple</code></p>
</li>
<li>
<p><code>std::apply</code>：触发方法调用，其中，参数被分装在一个<code>tuple</code>中</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">apply</span>(add, std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2</span>)) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">apply</span>(add, std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>)) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>std::tie</code></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">int32_t</span>, std::string&gt; <span class="title">createPair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">pair</span>&lt;<span class="type">int32_t</span>, std::string&gt;(<span class="number">1</span>, <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int32_t</span>, std::string, <span class="type">float</span>&gt; <span class="title">createTuple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tuple</span>&lt;<span class="type">int32_t</span>, std::string, <span class="type">float</span>&gt;(<span class="number">2</span>, <span class="string">&quot;Hi, World!&quot;</span>, <span class="number">3.14f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> num;</span><br><span class="line">    std::string str;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">tie</span>(num, std::ignore) = <span class="built_in">createPair</span>();</span><br><span class="line">    std::<span class="built_in">tie</span>(num, str, std::ignore) = <span class="built_in">createTuple</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="27-type_traits"><a class="markdownIt-Anchor" href="#27-type_traits"></a> 27 type_traits</h1>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/type_traits">Standard library header &lt;type_traits&gt;</a></p>
<h2 id="271-helper-class"><a class="markdownIt-Anchor" href="#271-helper-class"></a> 27.1 Helper Class</h2>
<ol>
<li><code>std::integral_constant</code></li>
<li><code>std::bool_constant</code></li>
<li><code>std::true_type</code></li>
<li><code>std::false_type</code></li>
</ol>
<h2 id="272-primary-type-categories"><a class="markdownIt-Anchor" href="#272-primary-type-categories"></a> 27.2 Primary type categories</h2>
<ol>
<li><code>std::is_void</code></li>
<li><code>std::is_null_pointer</code></li>
<li><code>std::is_integral</code></li>
<li><code>std::is_array</code></li>
<li><code>std::is_pointer</code></li>
<li>…</li>
</ol>
<h2 id="273-composite-type-categories"><a class="markdownIt-Anchor" href="#273-composite-type-categories"></a> 27.3 Composite type categories</h2>
<ol>
<li><code>std::is_fundamental</code></li>
<li><code>std::is_arithmetic</code></li>
<li><code>std::is_scalar</code></li>
<li><code>std::is_reference</code></li>
<li><code>std::is_member_pointer</code></li>
<li>…</li>
</ol>
<h2 id="274-type-properties"><a class="markdownIt-Anchor" href="#274-type-properties"></a> 27.4 Type properties</h2>
<ol>
<li><code>std::is_const</code></li>
<li><code>std::is_volatile</code></li>
<li><code>std::is_final</code></li>
<li><code>std::is_empty</code></li>
<li><code>std::is_abstract</code></li>
<li>…</li>
</ol>
<h2 id="275-supported-operations"><a class="markdownIt-Anchor" href="#275-supported-operations"></a> 27.5 Supported operations</h2>
<ol>
<li><code>std::is_constructible</code></li>
<li><code>std::is_copy_constructible</code></li>
<li><code>std::is_assignable</code></li>
<li><code>std::is_copy_assignable</code></li>
<li><code>std::is_destructible</code></li>
<li>…</li>
</ol>
<h2 id="276-property-queries"><a class="markdownIt-Anchor" href="#276-property-queries"></a> 27.6 Property queries</h2>
<ol>
<li><code>std::alignment_of</code></li>
<li><code>std::rank</code></li>
<li><code>std::extent</code></li>
</ol>
<h2 id="277-type-relationships"><a class="markdownIt-Anchor" href="#277-type-relationships"></a> 27.7 Type relationships</h2>
<ol>
<li><code>std::is_same</code></li>
<li><code>std::is_base_of</code></li>
<li>…</li>
</ol>
<h2 id="278-const-volatility-specifiers"><a class="markdownIt-Anchor" href="#278-const-volatility-specifiers"></a> 27.8 Const-volatility specifiers</h2>
<ol>
<li><code>std::remove_cv</code></li>
<li><code>std::remove_const</code></li>
<li><code>std::remove_volatile</code></li>
<li><code>std::add_cv</code></li>
<li><code>std::add_const</code></li>
<li><code>std::add_volatile</code></li>
</ol>
<h2 id="279-references"><a class="markdownIt-Anchor" href="#279-references"></a> 27.9 References</h2>
<ol>
<li><code>std::remove_reference</code></li>
<li><code>std::add_lvalue_reference</code></li>
<li><code>std::add_rvalue_reference</code></li>
</ol>
<h2 id="2710-pointers"><a class="markdownIt-Anchor" href="#2710-pointers"></a> 27.10 Pointers</h2>
<ol>
<li><code>std::remove_pointer</code></li>
<li><code>std::add_pointer</code></li>
</ol>
<h2 id="2711-sign-modifiers"><a class="markdownIt-Anchor" href="#2711-sign-modifiers"></a> 27.11 Sign modifiers</h2>
<ol>
<li><code>std::make_signed</code></li>
<li><code>std::make_unsigned</code></li>
</ol>
<h2 id="2712-arrays"><a class="markdownIt-Anchor" href="#2712-arrays"></a> 27.12 Arrays</h2>
<ol>
<li><code>std::remove_extent</code></li>
<li><code>std::remove_all_extents</code></li>
</ol>
<h2 id="2713-miscellaneous-transformations"><a class="markdownIt-Anchor" href="#2713-miscellaneous-transformations"></a> 27.13 Miscellaneous transformations</h2>
<ol>
<li><code>std::enable_if_t</code>: Often used in SFINAE.</li>
<li><code>std::conditional</code></li>
<li><code>std::underlying_type</code>: Get the underlying numeric type of enum type.</li>
<li><code>std::void_t</code>: Often used in SFINAE.</li>
<li><code>std::decay</code>: Applies reference-remove, cv-qualifiers-remove (const and volatile), array-to-pointer, and function-to-pointer implicit conversions to the type T.
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/25732386/what-is-stddecay-and-when-it-should-be-used">What is std::decay and when it should be used?</a></li>
<li><a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2069.html">N2609</a></li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_decay_equ = std::is_same_v&lt;std::<span class="type">decay_t</span>&lt;T&gt;, U&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(is_decay_equ&lt;<span class="type">int</span>&amp;, <span class="type">int</span>&gt;);</span><br><span class="line">    <span class="built_in">static_assert</span>(is_decay_equ&lt;<span class="type">int</span>&amp;&amp;, <span class="type">int</span>&gt;);</span><br><span class="line">    <span class="built_in">static_assert</span>(is_decay_equ&lt;<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">int</span>&gt;);</span><br><span class="line">    <span class="built_in">static_assert</span>(is_decay_equ&lt;<span class="type">int</span>[<span class="number">2</span>], <span class="type">int</span>*&gt;);</span><br><span class="line">    <span class="built_in">static_assert</span>(is_decay_equ&lt;<span class="type">int</span>[<span class="number">2</span>][<span class="number">3</span>], <span class="built_in">int</span>(*)[<span class="number">3</span>]&gt;);</span><br><span class="line">    <span class="built_in">static_assert</span>(is_decay_equ&lt;<span class="built_in">void</span>(<span class="type">int</span>, <span class="type">int</span>), <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">int</span>)&gt;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2714-alias"><a class="markdownIt-Anchor" href="#2714-alias"></a> 27.14 Alias</h2>
<p><code>using template</code>，用于简化上述模板。例如<code>std::enable_if_t</code>等价于<code>typename enable_if&lt;b,T&gt;::type</code></p>
<ol>
<li>
<p><code>std::enable_if_t</code></p>
</li>
<li>
<p><code>std::conditional_t</code></p>
</li>
<li>
<p><code>std::remove_reference_t</code></p>
</li>
<li>
<p><code>std::result_of_t</code></p>
</li>
<li>
<p><code>std::invoke_result_t</code></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">create_char</span><span class="params">(<span class="type">char</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">create_int</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">create_double</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="type">invoke_result_t</span>&lt;<span class="keyword">decltype</span>(create_char), <span class="type">char</span>&gt; c1;</span><br><span class="line">    std::<span class="type">invoke_result_t</span>&lt;<span class="keyword">decltype</span>(&amp;create_char), <span class="type">char</span>&gt; c2;</span><br><span class="line"></span><br><span class="line">    std::<span class="type">invoke_result_t</span>&lt;<span class="keyword">decltype</span>(Foo::create_int), <span class="type">int</span>&gt; i1;</span><br><span class="line">    std::<span class="type">invoke_result_t</span>&lt;<span class="keyword">decltype</span>(&amp;Foo::create_int), <span class="type">int</span>&gt; i2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::invoke_result_t&lt;decltype(Foo::create_double), Foo, int&gt; d1;</span></span><br><span class="line">    std::<span class="type">invoke_result_t</span>&lt;<span class="keyword">decltype</span>(&amp;Foo::create_double), Foo, <span class="type">int</span>&gt; d2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>…</p>
</li>
</ol>
<h2 id="2715-stdmove"><a class="markdownIt-Anchor" href="#2715-stdmove"></a> 27.15 std::move</h2>
<p><strong>Implementation:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>Essentially, it performs a type transformation, and the returned type is guaranteed to be an rvalue.</p>
<p>For non-reference type parameters, using std::move during argument passing will invoke the move constructor to create the argument. Here’s an example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Default ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(Foo&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Move ctor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_foo</span><span class="params">(Foo foo)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test_foo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="built_in">test_foo</span>(std::<span class="built_in">move</span>(foo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2716-stdforward"><a class="markdownIt-Anchor" href="#2716-stdforward"></a> 27.16 std::forward</h2>
<p><code>std::forward</code>主要用于实现模板的完美转发：因为对于一个变量而言，无论该变量的类型是左值引用还是右值引用，变量本身都是左值，如果直接将变量传递到下一个方法中，那么一定是按照左值来匹配重载函数的，而<code>std::forward</code>就是为了解决这个问题。请看下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;left reference version&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">func</span><span class="params">(<span class="type">int</span>&amp;&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;right reference version&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::string <span class="title">dispatch_without_forward</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::string <span class="title">dispatch_with_forward</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST(expr) std::cout <span class="string">&lt;&lt; #expr &lt;&lt; &quot; -&gt;</span> <span class="string">&quot; &lt;&lt; expr &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">int main() &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    int value = 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">    int&amp; value_l_ref = value;</span></span></span><br><span class="line"><span class="string"><span class="meta">    auto get_r_value = []() &#123; return 2; &#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(dispatch_without_forward(value));</span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(dispatch_without_forward(value_l_ref));</span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(dispatch_without_forward(get_r_value()));</span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(dispatch_without_forward(1));</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::cout &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(dispatch_with_forward(value));</span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(dispatch_with_forward(value_l_ref));</span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(dispatch_with_forward(get_r_value()));</span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(dispatch_with_forward(1));</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::cout &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(func(std::forward&lt;int&gt;(value)));</span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(func(std::forward&lt;int&amp;&gt;(value)));</span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(func(std::forward&lt;int&amp;&amp;&gt;(value)));</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::cout &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(func(std::forward&lt;int&gt;(value_l_ref)));</span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(func(std::forward&lt;int&amp;&gt;(value_l_ref)));</span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(func(std::forward&lt;int&amp;&amp;&gt;(value_l_ref)));</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::cout &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(func(std::forward&lt;int&gt;(get_r_value())));</span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(func(std::forward&lt;int&amp;&amp;&gt;(get_r_value())));</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::cout &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(func(std::forward&lt;int&gt;(1)));</span></span></span><br><span class="line"><span class="string"><span class="meta">    TEST(func(std::forward&lt;int&amp;&amp;&gt;(1)));</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">    return 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>输出如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dispatch_without_forward(value) -&gt; left reference version</span><br><span class="line">dispatch_without_forward(value_l_ref) -&gt; left reference version</span><br><span class="line">dispatch_without_forward(get_r_value()) -&gt; left reference version</span><br><span class="line">dispatch_without_forward(1) -&gt; left reference version</span><br><span class="line"></span><br><span class="line">dispatch_with_forward(value) -&gt; left reference version</span><br><span class="line">dispatch_with_forward(value_l_ref) -&gt; left reference version</span><br><span class="line">dispatch_with_forward(get_r_value()) -&gt; right reference version</span><br><span class="line">dispatch_with_forward(1) -&gt; right reference version</span><br><span class="line"></span><br><span class="line">func(std::forward&lt;int&gt;(value)) -&gt; right reference version</span><br><span class="line">func(std::forward&lt;int&amp;&gt;(value)) -&gt; left reference version</span><br><span class="line">func(std::forward&lt;int&amp;&amp;&gt;(value)) -&gt; right reference version</span><br><span class="line"></span><br><span class="line">func(std::forward&lt;int&gt;(value_l_ref)) -&gt; right reference version</span><br><span class="line">func(std::forward&lt;int&amp;&gt;(value_l_ref)) -&gt; left reference version</span><br><span class="line">func(std::forward&lt;int&amp;&amp;&gt;(value_l_ref)) -&gt; right reference version</span><br><span class="line"></span><br><span class="line">func(std::forward&lt;int&gt;(get_r_value())) -&gt; right reference version</span><br><span class="line">func(std::forward&lt;int&amp;&amp;&gt;(get_r_value())) -&gt; right reference version</span><br><span class="line"></span><br><span class="line">func(std::forward&lt;int&gt;(1)) -&gt; right reference version</span><br><span class="line">func(std::forward&lt;int&amp;&amp;&gt;(1)) -&gt; right reference version</span><br></pre></td></tr></table></figure>
<p><strong>在使用<code>std::forward</code>时，模板实参都是需要显式指定的，而不是推断出来的</strong></p>
<p><strong><code>std::forward</code>标准库的实现如下：</strong></p>
<ul>
<li>如果模板实参是左值、左值引用或右值引用，那么匹配第一个方法
<ul>
<li>左值：<code>_Tp&amp;&amp;</code>得到的是个右值（很奇怪吧，因为一般都不是这么用的）</li>
<li><strong>左值引用：<code>_Tp&amp;&amp;</code>得到的是个左值引用（完美转发会用到）</strong></li>
<li><strong>右值应用：<code>_Tp&amp;&amp;</code>得到的是个右值引用（完美转发会用到）</strong></li>
</ul>
</li>
<li>如果模板实参是左值或右值，那么匹配的是第二个方法
<ul>
<li>右值：<code>_Tp&amp;&amp;</code>得到的是个右值</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">                  <span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="27161-forwarding-reference"><a class="markdownIt-Anchor" href="#27161-forwarding-reference"></a> 27.16.1 forwarding reference</h3>
<p><strong>当且仅当<code>T</code>是函数模板的模板类型形参时，<code>T&amp;&amp;</code>才能称为<code>forwarding reference</code>，而其他任何形式，都不是<code>forwarding reference</code>。例如如下示例代码：</strong></p>
<ul>
<li><strong><code>std::vector&lt;T&gt;&amp;&amp;</code>就不是<code>forwarding reference</code>，而只是一个<code>r-value reference</code></strong></li>
<li><strong><code>C(T&amp;&amp; t)</code>中的<code>T&amp;&amp;</code>也不是<code>forwarding reference</code>，因为类型<code>T</code>在实例化<code>C</code>时，已经可以确定了，无需推导</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(T&amp;&amp; t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gt</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(std::<span class="built_in">move</span>(t)); <span class="comment">// Noncompliant : std::move applied to a forwarding reference</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    <span class="built_in">g</span>(s);</span><br><span class="line">    <span class="built_in">g</span>(std::forward&lt;S&gt;(s)); <span class="comment">// Noncompliant : S isn&#x27;t a forwarding reference.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    std::forward&lt;T&gt;(t); <span class="comment">// Noncompliant : std::vector&lt;T&gt;&amp;&amp; isn&#x27;t a forwarding reference.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="comment">// In class template argument deduction, template parameter of a class template is never a forwarding reference.</span></span><br><span class="line">    <span class="built_in">C</span>(T&amp;&amp; t) &#123;</span><br><span class="line">        <span class="built_in">g</span>(std::forward&lt;T&gt;(t)); <span class="comment">// Noncompliant : T&amp;&amp; isn&#x27;t a forwarding reference. It is an r-value reference.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>上述程序正确的写法是：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(T&amp;&amp; t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gt</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">g</span>(std::forward(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S s;</span><br><span class="line">    <span class="built_in">g</span>(s);</span><br><span class="line">    <span class="built_in">g</span>(std::<span class="built_in">move</span>(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">move</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="built_in">C</span>(T&amp;&amp; t) &#123; <span class="built_in">g</span>(std::<span class="built_in">move</span>(t)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="28-unordered_map"><a class="markdownIt-Anchor" href="#28-unordered_map"></a> 28 unordered_map</h1>
<h1 id="29-unordered_set"><a class="markdownIt-Anchor" href="#29-unordered_set"></a> 29 unordered_set</h1>
<p>Both <code>equal</code> and <code>hash</code> functions should be marked with <code>const</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> value1;</span><br><span class="line">    <span class="type">int32_t</span> value2;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Item&amp; other) <span class="type">const</span> &#123; <span class="keyword">return</span> value1 == other.value1 &amp;&amp; value2 == other.value2; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Eq</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Item&amp; i1, <span class="type">const</span> Item&amp; i2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i1.value1 == i2.value2 &amp;&amp; i1.value2 == i2.value2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Hash</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Item&amp; i)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;<span class="type">int32_t</span>&gt;()(i.value1) ^ std::<span class="built_in">hash</span>&lt;<span class="type">int32_t</span>&gt;()(i.value2); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Item&amp; item) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; item.value1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; item.value2 &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Use member function operator== as equal function</span></span><br><span class="line">        std::unordered_set&lt;Item, Item::Hash&gt; visited;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> add = [](<span class="keyword">auto</span>&amp; visited, <span class="type">const</span> Item&amp; item) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> it = visited.<span class="built_in">insert</span>(item); it.second) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;add &quot;</span> &lt;&lt; item &lt;&lt; <span class="string">&quot; successfully&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cout &lt;&lt; item &lt;&lt; <span class="string">&quot; already exists&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">add</span>(visited, &#123;.value1 = <span class="number">1</span>, .value2 = <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">add</span>(visited, &#123;.value1 = <span class="number">1</span>, .value2 = <span class="number">2</span>&#125;);</span><br><span class="line">        <span class="built_in">add</span>(visited, &#123;.value1 = <span class="number">2</span>, .value2 = <span class="number">2</span>&#125;);</span><br><span class="line">        <span class="built_in">add</span>(visited, &#123;.value1 = <span class="number">3</span>, .value2 = <span class="number">3</span>&#125;);</span><br><span class="line">        <span class="built_in">add</span>(visited, &#123;.value1 = <span class="number">1</span>, .value2 = <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Use type Item::Eq as equal function</span></span><br><span class="line">        std::unordered_set&lt;Item, Item::Hash, Item::Eq&gt; visited;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> add = [](<span class="keyword">auto</span>&amp; visited, <span class="type">const</span> Item&amp; item) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> it = visited.<span class="built_in">insert</span>(item); it.second) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;add &quot;</span> &lt;&lt; item &lt;&lt; <span class="string">&quot; successfully&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cout &lt;&lt; item &lt;&lt; <span class="string">&quot; already exists&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">add</span>(visited, &#123;.value1 = <span class="number">1</span>, .value2 = <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="built_in">add</span>(visited, &#123;.value1 = <span class="number">1</span>, .value2 = <span class="number">2</span>&#125;);</span><br><span class="line">        <span class="built_in">add</span>(visited, &#123;.value1 = <span class="number">2</span>, .value2 = <span class="number">2</span>&#125;);</span><br><span class="line">        <span class="built_in">add</span>(visited, &#123;.value1 = <span class="number">3</span>, .value2 = <span class="number">3</span>&#125;);</span><br><span class="line">        <span class="built_in">add</span>(visited, &#123;.value1 = <span class="number">1</span>, .value2 = <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="30-utility"><a class="markdownIt-Anchor" href="#30-utility"></a> 30 utility</h1>
<ol>
<li>
<p><code>std::exchange</code>：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; nums&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> visit_first = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> previous = std::<span class="built_in">exchange</span>(visit_first, <span class="literal">true</span>)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>std::pair</code>：本质上，它是<code>std::tuple</code>的一个特例</p>
</li>
<li>
<p><code>std::declval</code>：用来配合<code>decltype</code>进行类型推导，其实现原理如下：</p>
<ul>
<li><code>__declval</code>是一个用于返回指定类型的方法（只有定义无实现，因为只用于类型推导）</li>
<li><code>_Tp __declval(long);</code>版本用于<code>void</code>这种类型，因为<code>void</code>没有引用类型</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @cond undocumented</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up = _Tp&amp;&amp;&gt;</span><br><span class="line">_Up __declval(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">_Tp __declval(<span class="type">long</span>);</span><br><span class="line"><span class="comment">/// @endcond</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">declval</span><span class="params">()</span> <span class="keyword">noexcept</span> -&gt; <span class="title">decltype</span><span class="params">(__declval&lt;_Tp&gt;(<span class="number">0</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>示例如下：</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Default</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NonDefault</span> &#123;</span><br><span class="line">    <span class="built_in">NonDefault</span>(<span class="type">const</span> NonDefault&amp;) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">NonDefault <span class="title">get_non_default</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">Default</span>().<span class="built_in">foo</span>()) n1 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// decltype(NonDefault().foo()) n2 = n1;               // will not compile</span></span><br><span class="line">    <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;NonDefault&gt;().<span class="built_in">foo</span>()) n2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">get_non_default</span>().<span class="built_in">foo</span>()) n3 = <span class="number">3</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;n1 = &quot;</span> &lt;&lt; n1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;n2 = &quot;</span> &lt;&lt; n2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;n3 = &quot;</span> &lt;&lt; n3 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>std::integer_sequence</code></p>
</li>
<li>
<p><code>std::make_integer_sequence</code></p>
</li>
<li>
<p><code>std::integer_sequence</code></p>
</li>
<li>
<p><code>std::make_integer_sequence</code></p>
</li>
</ol>
<h2 id="301-how-to-return-pair-containing-reference-type"><a class="markdownIt-Anchor" href="#301-how-to-return-pair-containing-reference-type"></a> 30.1 How to return pair containing reference type</h2>
<p>示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::pair&lt;<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp;, <span class="type">int</span>&gt; <span class="built_in">get_data_1</span>() &#123; <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(_data, _data.<span class="built_in">size</span>()); &#125;</span><br><span class="line">    std::pair&lt;<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp;, <span class="type">int</span>&gt; <span class="built_in">get_data_2</span>() &#123; <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(std::<span class="built_in">ref</span>(_data), _data.<span class="built_in">size</span>()); &#125;</span><br><span class="line">    std::pair&lt;<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp;, <span class="type">int</span>&gt; <span class="built_in">get_data_3</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> std::pair&lt;<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp;, <span class="type">int</span>&gt;(_data, _data.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; _data&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thing t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> printer = [](<span class="keyword">auto</span>&amp; pair) &#123;</span><br><span class="line">        std::ranges::<span class="built_in">copy</span>(pair.first, std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot;, &quot;</span>));</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pair1 = t.<span class="built_in">get_data_1</span>();</span><br><span class="line">    <span class="comment">// printer(pair1); // crash</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pair2 = t.<span class="built_in">get_data_2</span>();</span><br><span class="line">    <span class="built_in">printer</span>(pair2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pair3 = t.<span class="built_in">get_data_3</span>();</span><br><span class="line">    <span class="built_in">printer</span>(pair3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>首先，我们先看一下<code>std::make_pair</code>的源码，如下：</p>
<ul>
<li><code>__decay_and_strip</code>：对于<code>std::reference_wrapper</code>，会除去<code>std::reference_wrapper</code>的封装，并返回引用类型；对于其他类型，则返回非引用类型</li>
</ul>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _T1, <span class="keyword">typename</span> _T2&gt;</span><br><span class="line"><span class="keyword">constexpr</span> pair&lt;<span class="keyword">typename</span> __decay_and_strip&lt;_T1&gt;::__type,</span><br><span class="line">                <span class="keyword">typename</span> __decay_and_strip&lt;_T2&gt;::__type&gt;</span><br><span class="line"><span class="built_in">make_pair</span>(_T1&amp;&amp; __x, _T2&amp;&amp; __y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __decay_and_strip&lt;_T1&gt;::__type __ds_type1;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __decay_and_strip&lt;_T2&gt;::__type __ds_type2;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;__ds_type1, __ds_type2&gt; 	      __pair_type;</span><br><span class="line">    <span class="keyword">return</span> __pair_type(std::forward&lt;_T1&gt;(__x), std::forward&lt;_T2&gt;(__y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>get_data_1</code>：错误方式。因为<code>std::make_pair</code>会创建类型为<code>std::pair&lt;std::vector&lt;int&gt;, int&gt;</code>的对象，然后再转型成<code>std::pair&lt;const std::vector&lt;int&gt;&amp;, int&gt;</code>，于是引用会错误初始化（绑定到了临时对象），导致后续错误</p>
</li>
<li>
<p><code>get_data_2</code>：正确方式。由于<code>std::ref</code>（返回类型是<code>std::reference_wrapper</code>）的存在，<code>std::make_pair</code>会创建类型为<code>std::pair&lt;const std::vector&lt;int&gt;&amp;, int&gt;</code>的对象，此时引用会正确初始化</p>
</li>
<li>
<p><code>get_data_3</code>：正确方式，不用<code>std::make_pair</code>，引用会正确初始化</p>
</li>
</ul>
<h1 id="31-variant"><a class="markdownIt-Anchor" href="#31-variant"></a> 31 variant</h1>
<ol>
<li><code>std::visit</code></li>
<li><code>std::variant</code>：类型安全的union。只允许以正确的类型进行访问
<ul>
<li><code>std::get&lt;&#123;type&#125;&gt;</code>：通过指定类型访问</li>
<li><code>std::get&lt;&#123;index&#125;&gt;</code>：通过指定序号访问</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>&gt; v;</span><br><span class="line">    v = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(v) &lt;&lt; std::endl;</span><br><span class="line">    v = <span class="number">1.2</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(v) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="311-dynamic-binding"><a class="markdownIt-Anchor" href="#311-dynamic-binding"></a> 31.1 Dynamic Binding</h2>
<p><code>std::variant</code>结合<code>std::visit</code>可以实现动态分派，示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(std::variant&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> visitor = [](<span class="keyword">auto</span>&amp; item) &#123;</span><br><span class="line">        <span class="keyword">using</span> type = std::<span class="type">remove_reference_t</span>&lt;<span class="keyword">decltype</span>(item)&gt;;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;type&gt;)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;is integral&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_floating_point_v&lt;type&gt;) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;is floating_point&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::<span class="built_in">visit</span>(visitor, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>&gt; v;</span><br><span class="line">    v = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">visit</span>(v);</span><br><span class="line">    v = <span class="number">1.2</span>;</span><br><span class="line">    <span class="built_in">visit</span>(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>大致实现原理如下：</strong></p>
<ul>
<li>赋值时，会维护<code>std::variant::index</code>属性</li>
<li>每个<code>Visitor,variant</code>对会生成一个<code>vtable</code>，里面记录了所有的函数指针，并按照<code>std::variant</code>各个类型声明的顺序排序</li>
<li>在用<code>std::visit</code>进行访问时，会用<code>std::variant::index</code>找到<code>vtable</code>中的函数指针，并进行调用</li>
</ul>
<h1 id="32-containers"><a class="markdownIt-Anchor" href="#32-containers"></a> 32 Containers</h1>
<ol>
<li><code>&lt;vector&gt;</code>：其内部就是一个数组。当进行扩容缩容时，会进行数据的拷贝或移动，因此要求对应的类型至少拥有拷贝构造函数和移动构造函数中的一个。例如，<code>std::vector&lt;std::atomic_bool&gt;</code>是无法调用<code>push_back</code>或者<code>emplace_back</code>来增加元素的</li>
<li><code>&lt;array&gt;</code></li>
<li><code>&lt;list&gt;</code></li>
<li><code>&lt;queue&gt;</code></li>
<li><code>&lt;deque&gt;</code>：通过二级数组实现，第一级数组用于存放数据，第二级数组用于存放第一级数组的信息（首地址等）。当需要扩容时，会增加一个新的一级数组，而原有数据是不需要移动的</li>
<li><code>&lt;map&gt;</code></li>
<li><code>&lt;unordered_map&gt;</code></li>
<li><code>&lt;set&gt;</code></li>
<li><code>&lt;unordered_set&gt;</code></li>
</ol>
<h2 id="321-tips"><a class="markdownIt-Anchor" href="#321-tips"></a> 32.1 Tips</h2>
<ol>
<li><code>std::map</code>或者<code>std::set</code>用下标访问后，即便访问前元素不存在，也会插入一个默认值。因此下标访问是非<code>const</code>的</li>
<li>容器在扩容时，调用的是元素的拷贝构造函数</li>
<li><code>std::vector&lt;T&gt; v(n)</code>会生成<code>n</code>个对应元素的默认值，而不是起到预留<code>n</code>个元素的空间的作用</li>
<li>不要将<code>end</code>方法返回的迭代器传入<code>erase</code>方法</li>
</ol>
<h1 id="33-simd"><a class="markdownIt-Anchor" href="#33-simd"></a> 33 SIMD</h1>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11228855/header-files-for-x86-simd-intrinsics">Header files for x86 SIMD intrinsics</a></p>
<ol>
<li><code>&lt;mmintrin.h&gt;</code>：MMX</li>
<li><code>&lt;xmmintrin.h&gt;</code>：SSE</li>
<li><code>&lt;emmintrin.h&gt;</code>：SSE2</li>
<li><code>&lt;pmmintrin.h&gt;</code>：SSE3</li>
<li><code>&lt;tmmintrin.h&gt;</code>：SSSE3</li>
<li><code>&lt;smmintrin.h&gt;</code>：SSE4.1</li>
<li><code>&lt;nmmintrin.h&gt;</code>：SSE4.2</li>
<li><code>&lt;ammintrin.h&gt;</code>：SSE4A</li>
<li><code>&lt;wmmintrin.h&gt;</code>：AES</li>
<li><strong><code>&lt;immintrin.h&gt;</code></strong>：AVX, AVX2, FMA
<ul>
<li>一般用这个即可，包含上述其他的头文件</li>
</ul>
</li>
</ol>
<p><strong>注意，<code>gcc</code>、<code>clang</code>默认禁止使用向量化相关的类型以及操作，在使用上述头文件时，需要指定对应的编译参数：</strong></p>
<ul>
<li><code>-mmmx</code></li>
<li><code>-msse</code></li>
<li><code>-msse2</code></li>
<li><code>-msse3</code></li>
<li><code>-mssse3</code></li>
<li><code>-msse4</code></li>
<li><code>-msse4a</code></li>
<li><code>-msse4.1</code></li>
<li><code>-msse4.2</code></li>
<li><code>-mavx</code></li>
<li><code>-mavx2</code></li>
<li><code>-mavx512f</code></li>
<li><code>-mavx512pf</code>, supports prefetching for gather/scatter, mentioned by <a href="/resources/paper/Interleaved-Multi-Vectorizing.pdf">Interleaved Multi-Vectorizing</a></li>
<li><code>-mavx512er</code></li>
<li><code>-mavx512cd</code></li>
<li><code>-mavx512vl</code></li>
<li><code>-mavx512bw</code></li>
<li><code>-mavx512dq</code></li>
<li><code>-mavx512ifma</code></li>
<li><code>-mavx512vbmi</code></li>
<li>…</li>
</ul>
<h1 id="34-c-standard-library"><a class="markdownIt-Anchor" href="#34-c-standard-library"></a> 34 C Standard Library</h1>
<p>Since <code>C++</code> is a superset of <code>C</code>, the standard library of <code>C</code> has also been added to the <code>std</code> namespace, but the header files differ: <code>xxx.h -&gt; cxxx</code>. Among them, <code>xxx.h</code> is the original <code>C</code> standard library header file, and its symbols are not in any namespace; <code>cxxx</code> is the corresponding <code>C++</code> version of the header file, and its symbols are in the <code>std</code> namespace.</p>
<ol>
<li><code>cstddef</code>
<ul>
<li><code>size_t</code></li>
</ul>
</li>
<li><code>cstdint</code>
<ul>
<li><code>int8_t/int16_t/int32_t/int64_t</code></li>
</ul>
</li>
<li><code>cerrno</code>: The error codes for system calls and some library functions are written to the global variable <code>errno</code>.</li>
<li><code>cstdio</code>
<ul>
<li><code>std::tmpnam</code>: Use with caution for the following reasons:
<ul>
<li>The tmpnam() function generates a different string each time it is called, up to TMP_MAX times. If it is called more than TMP_MAX times, the behavior is implementation defined.</li>
</ul>
</li>
<li><code>std::printf</code></li>
</ul>
</li>
<li><code>cstring</code>
<ul>
<li><code>std::memset</code>: Use <code>&lt;num&gt; * sizeof(&lt;type&gt;)</code> to obtain the length.</li>
<li><code>std::memcpy</code>: Use <code>&lt;num&gt; * sizeof(&lt;type&gt;)</code> to obtain the length.</li>
<li><code>std::strcmp</code>: Compare two <code>const char *</code> to check if they are identical.</li>
</ul>
</li>
<li><code>cstdlib</code>
<ul>
<li><strong>Memory Allocation Related</strong>
<ul>
<li><code>malloc/free</code>: Functions from <code>C</code> that can also be used in <code>C++</code>. <code>malloc</code> allocates memory of a specified size, and <code>free</code> releases the allocated memory.</li>
<li><code>calloc</code>: Allocates a specified number of contiguous memory spaces and initializes them to 0.</li>
<li><code>realloc</code>: Resizes previously allocated memory.</li>
<li><code>aligned_alloc</code>: Allocates memory of a specified size and ensures it is aligned to a specific byte boundary.</li>
<li><code>posix_memalign</code>: Allocates memory of a specified size and ensures it is aligned to a specified byte boundary.</li>
<li><code>memalign</code>: Allocates memory of a specified size and ensures it is aligned to a specific byte boundary.</li>
<li><code>valloc</code>: Allocates memory of a specified size and ensures it is aligned to the page size.</li>
<li><code>pvalloc</code>: Allocates memory of a specified size and ensures it is aligned to the page size.</li>
</ul>
</li>
<li><code>std::atexit</code>: Registers a hook method to be called upon program exit.</li>
<li><code>std::system</code>: Used to execute commands.</li>
<li><code>std::mkstemp</code>: Creates a temporary file, requiring a filename template where the last six characters are <code>XXXXXX</code>, which will be replaced by random characters.</li>
<li><code>std::atoi</code></li>
<li><code>std::atol</code></li>
<li><code>std::atoll</code></li>
<li><code>std::getenv</code></li>
<li><code>setenv</code>: A POSIX API, not included in the C++ standard library.</li>
</ul>
</li>
<li><code>cctype</code>
<ul>
<li><code>std::isblank</code>: Returns true only for spaces and horizontal tabs.</li>
<li><code>std::isspace</code>: Returns true for spaces, form feed, newline, carriage return, horizontal tab, and vertical tab.</li>
</ul>
</li>
<li>POSIX headers
<ol>
<li><code>fcntl.h</code>: Provides an interface for controlling file descriptors. It includes constants and function declarations for working with file descriptors, managing file locks, and configuring file options.</li>
<li><code>unistd.h</code>: (Unix Standard) Provides access to the POSIX (Portable Operating System Interface) operating system API. It is available on Unix-based operating systems (like Linux and macOS) and offers a collection of system calls and library functions for various low-level operations.
<ul>
<li>General POSIX functions like <code>fork</code>, <code>exec</code>, <code>pipe</code>, <code>getpid</code>.</li>
<li>File operations: <code>read</code>, <code>write</code>, <code>close</code>, <code>lseek</code>.</li>
<li>Process management: <code>getuid</code>, <code>setuid</code>.</li>
</ul>
</li>
<li><code>signal.h</code>: Provides signal handling: <code>signal</code>, <code>sigaction</code>, <code>raise</code>.</li>
<li><code>pthread.h</code>: Provides thread operations: <code>pthread_create</code>, <code>pthread_join</code>, <code>pthread_mutex_lock</code>.</li>
<li><code>sys/stat.h</code>: Provides file status functions: <code>stat</code>, <code>fstat</code>, <code>lstat</code>.</li>
</ol>
</li>
</ol>
<h2 id="341-csignal"><a class="markdownIt-Anchor" href="#341-csignal"></a> 34.1 csignal</h2>
<p>各种信号都定义在<code>signum.h</code>这个头文件中</p>
<p>下面的示例代码用于捕获<code>OOM</code>并输出当时的进程状态信息</p>
<ul>
<li>化级别用<code>O0</code>，否则<code>v.reserve</code>会被优化掉</li>
<li><code>ulimit -v 1000000</code>：设置进程最大内存</li>
<li><code>./main &lt;size&gt;</code>：不断增大<code>size</code>，可以发现<code>VmPeak</code>和<code>VmSize</code>不断增大。继续增大<code>size</code>，当触发<code>OOM</code>时，<code>VmPeak</code>和<code>VmSize</code>这两个值都很小，不会包含那个造成<code>OOM</code>的对象的内存</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display_self_status</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;/proc/self/status&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> BUFFER_SIZE = <span class="number">512</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!in.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        in.<span class="built_in">getline</span>(buf, BUFFER_SIZE);</span><br><span class="line">        std::cout &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Cath a signal, sig=&quot;</span> &lt;&lt; sig &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">display_self_status</span>();</span><br><span class="line">    <span class="built_in">exit</span>(sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> sig = SIGHUP; sig &lt;= SIGSYS; sig++) &#123;</span><br><span class="line">        <span class="built_in">signal</span>(sig, func);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">display_self_status</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trigger OOM</span></span><br><span class="line">    std::vector&lt;<span class="type">int64_t</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">reserve</span>(std::<span class="built_in">atoi</span>(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">display_self_status</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="342-execute-command"><a class="markdownIt-Anchor" href="#342-execute-command"></a> 34.2 Execute Command</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> file_name[] = <span class="string">&quot;/tmp/fileXXXXXX&quot;</span>;</span><br><span class="line">    <span class="built_in">mkstemp</span>(file_name);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;tmp_file=&quot;</span> &lt;&lt; file_name &lt;&lt; std::endl;</span><br><span class="line">    std::<span class="built_in">system</span>((<span class="string">&quot;ls -l &gt; &quot;</span> + std::<span class="built_in">string</span>(file_name)).<span class="built_in">c_str</span>());</span><br><span class="line">    std::cout &lt;&lt; std::ifstream(file_name).<span class="built_in">rdbuf</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="35-builtin-functions"><a class="markdownIt-Anchor" href="#35-builtin-functions"></a> 35 Builtin Functions</h1>
<p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">6.63 Other Built-in Functions Provided by GCC</a></p>
<ol>
<li><code>__builtin_unreachable</code></li>
<li><code>__builtin_prefetch</code></li>
<li><code>__builtin_expect</code>
<ul>
<li><code>#define LIKELY(x) __builtin_expect(!!(x), 1)</code></li>
<li><code>#define UNLIKELY(x) __builtin_expect(!!(x), 0)</code></li>
</ul>
</li>
<li><code>__builtin_bswap32</code>: Perform a byte-swap operation on a 32-bit integer. Byte-swapping reverses the byte order of a value, which is useful for handling data in systems with different endianness (e.g., converting between big-endian and little-endian formats).</li>
<li><code>__builtin_offsetof(type, member)</code>: Calculate member’s offset.
<ul>
<li>One alternative implementation is: <code>#define my_offsetof(type, member) ((size_t) &amp; (((type*)0)-&gt;member))</code></li>
</ul>
</li>
</ol>
<h1 id="36-frequently-used-compoments-for-interview"><a class="markdownIt-Anchor" href="#36-frequently-used-compoments-for-interview"></a> 36 Frequently-Used Compoments for Interview</h1>
<p><strong>Data Structure:</strong></p>
<ul>
<li><code>std::vector</code></li>
<li><code>std::list</code>
<ul>
<li><code>splice</code></li>
</ul>
</li>
<li><code>std::map</code></li>
<li><code>std::set</code></li>
<li><code>std::stack</code></li>
<li><code>std::queue</code></li>
<li><code>std::priority_queue</code></li>
</ul>
<p><strong>Algorithm:</strong></p>
<ul>
<li><code>std::sort</code></li>
<li><code>std::lower_bound</code>,<code>std::upper_bound</code> : binary search.</li>
<li><code>std::find</code></li>
<li><code>std::remove_if</code>: return the iterator pointing at the first elements to be removed.</li>
<li><code>std::erase_if</code>: remove the specific elements.</li>
<li><code>std::set_intersection</code>、<code>std::set_union</code>、<code>std::set_difference</code></li>
</ul>
<p><strong>Function Objects:</strong></p>
<ul>
<li><code>std::hash</code></li>
<li><code>std::less</code>/<code>std::less_equals</code>/<code>std::greater</code>/<code>std::greater_equal</code></li>
<li><code>std::equal_to</code></li>
</ul>
<p><strong>I/O:</strong></p>
<ul>
<li><code>std::ifstream</code>、<code>std::ofstream</code></li>
<li><code>std::getline</code></li>
<li><code>std::get_time</code>、<code>std::put_time</code></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag"># 原创</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/09/06/Cpp-Language/" rel="prev" title="Cpp-Language">
      <i class="fa fa-chevron-left"></i> Cpp-Language
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/06/Cpp-Tools-GDB/" rel="next" title="Cpp-Tools-GDB">
      Cpp-Tools-GDB <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-livere">livere</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzY0My8xMDE5OA=="></div>
  </div>
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-algorithm"><span class="nav-text"> 1 algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-modifying-sequence-operations"><span class="nav-text"> 1.1 Modifying Sequence Operations</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#111-stdcopy"><span class="nav-text"> 1.1.1 std::copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#112-stdtransform"><span class="nav-text"> 1.1.2 std::transform</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#113-stdremove_if"><span class="nav-text"> 1.1.3 std::remove_if</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-sorting-operations"><span class="nav-text"> 1.2 Sorting operations</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#121-stdsort"><span class="nav-text"> 1.2.1 std::sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#122-stdmerge"><span class="nav-text"> 1.2.2 std::merge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#123-stdinplace_merge"><span class="nav-text"> 1.2.3 std::inplace_merge</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-non-modifying-sequence-operations"><span class="nav-text"> 1.3 Non-modifying Sequence Operations</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#131-stdfor_each"><span class="nav-text"> 1.3.1 std::for_each</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-binary-search-operations-on-sorted-ranges"><span class="nav-text"> 1.4 Binary Search Operations (on sorted ranges)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#141-stdlower_bound-stdupper_bound"><span class="nav-text"> 1.4.1 std::lower_bound &amp; std::upper_bound</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-set-operations"><span class="nav-text"> 1.5 Set Operations</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-any"><span class="nav-text"> 2 any</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-atomic"><span class="nav-text"> 3 atomic</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#31-stdmemory_order"><span class="nav-text"> 3.1 std::memory_order</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#311-sequential-consistency-ordering"><span class="nav-text"> 3.1.1 Sequential Consistency Ordering</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#312-relaxed-ordering"><span class="nav-text"> 3.1.2 Relaxed Ordering</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#313-acquire-release-ordering"><span class="nav-text"> 3.1.3 Acquire-Release Ordering</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-chrono"><span class="nav-text"> 4 chrono</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#41-clock"><span class="nav-text"> 4.1 clock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-time_point"><span class="nav-text"> 4.2 time_point</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-filesystem"><span class="nav-text"> 5 filesystem</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-fstream"><span class="nav-text"> 6 fstream</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#61-stdifstream"><span class="nav-text"> 6.1 std::ifstream</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-functional"><span class="nav-text"> 7 functional</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#71-reference"><span class="nav-text"> 7.1 Reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-future"><span class="nav-text"> 8 future</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-iomanip"><span class="nav-text"> 9 iomanip</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-iostream"><span class="nav-text"> 10 iostream</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-iterator"><span class="nav-text"> 11 iterator</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#111-stream-iterators"><span class="nav-text"> 11.1 Stream Iterators</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#112-operations"><span class="nav-text"> 11.2 Operations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#113-adaptors"><span class="nav-text"> 11.3 Adaptors</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-limits"><span class="nav-text"> 12 limits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-memory"><span class="nav-text"> 13 memory</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#131-stdshared_ptr"><span class="nav-text"> 13.1 std::shared_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#132-stdenable_shared_from_this"><span class="nav-text"> 13.2 std::enable_shared_from_this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#133-stdunique_ptr"><span class="nav-text"> 13.3 std::unique_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#134-stdweak_ptr"><span class="nav-text"> 13.4 std::weak_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#135-pointer-cast"><span class="nav-text"> 13.5 Pointer Cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#136-reference"><span class="nav-text"> 13.6 Reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-memory_resource"><span class="nav-text"> 14 memory_resource</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-mutex"><span class="nav-text"> 15 mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#151-reference"><span class="nav-text"> 15.1 Reference</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-numeric"><span class="nav-text"> 16 numeric</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-optional"><span class="nav-text"> 17 optional</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-queue"><span class="nav-text"> 18 queue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#181-stdpriority_queue"><span class="nav-text"> 18.1 std::priority_queue</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-random"><span class="nav-text"> 19 random</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-ranges"><span class="nav-text"> 20 ranges</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-stdexcept"><span class="nav-text"> 21 stdexcept</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-exception"><span class="nav-text"> 22 exception</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#221-sstring"><span class="nav-text"> 22.1 sstring</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-shared_mutex"><span class="nav-text"> 23 shared_mutex</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-string"><span class="nav-text"> 24 string</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-thread"><span class="nav-text"> 25 thread</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#251-how-to-set-thread-name"><span class="nav-text"> 25.1 How to set thread name</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#252-how-to-set-thread-affinity"><span class="nav-text"> 25.2 How to set thread affinity</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-tuple"><span class="nav-text"> 26 tuple</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-type_traits"><span class="nav-text"> 27 type_traits</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#271-helper-class"><span class="nav-text"> 27.1 Helper Class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#272-primary-type-categories"><span class="nav-text"> 27.2 Primary type categories</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#273-composite-type-categories"><span class="nav-text"> 27.3 Composite type categories</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#274-type-properties"><span class="nav-text"> 27.4 Type properties</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#275-supported-operations"><span class="nav-text"> 27.5 Supported operations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#276-property-queries"><span class="nav-text"> 27.6 Property queries</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#277-type-relationships"><span class="nav-text"> 27.7 Type relationships</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#278-const-volatility-specifiers"><span class="nav-text"> 27.8 Const-volatility specifiers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#279-references"><span class="nav-text"> 27.9 References</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2710-pointers"><span class="nav-text"> 27.10 Pointers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2711-sign-modifiers"><span class="nav-text"> 27.11 Sign modifiers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2712-arrays"><span class="nav-text"> 27.12 Arrays</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2713-miscellaneous-transformations"><span class="nav-text"> 27.13 Miscellaneous transformations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2714-alias"><span class="nav-text"> 27.14 Alias</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2715-stdmove"><span class="nav-text"> 27.15 std::move</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2716-stdforward"><span class="nav-text"> 27.16 std::forward</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#27161-forwarding-reference"><span class="nav-text"> 27.16.1 forwarding reference</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-unordered_map"><span class="nav-text"> 28 unordered_map</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-unordered_set"><span class="nav-text"> 29 unordered_set</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-utility"><span class="nav-text"> 30 utility</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#301-how-to-return-pair-containing-reference-type"><span class="nav-text"> 30.1 How to return pair containing reference type</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-variant"><span class="nav-text"> 31 variant</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#311-dynamic-binding"><span class="nav-text"> 31.1 Dynamic Binding</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-containers"><span class="nav-text"> 32 Containers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#321-tips"><span class="nav-text"> 32.1 Tips</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-simd"><span class="nav-text"> 33 SIMD</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-c-standard-library"><span class="nav-text"> 34 C Standard Library</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#341-csignal"><span class="nav-text"> 34.1 csignal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#342-execute-command"><span class="nav-text"> 34.2 Execute Command</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-builtin-functions"><span class="nav-text"> 35 Builtin Functions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36-frequently-used-compoments-for-interview"><span class="nav-text"> 36 Frequently-Used Compoments for Interview</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liuyehcf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Liuyehcf</p>
  <div class="site-description" itemprop="description">大音希声，大象无形</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">285</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liuyehcf</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qhEhLuMeMOy1zgcBhkqUS6P8-gzGzoHsz',
      appKey     : 'uhkruDLNLNdL5rQjRBY2X9Ke',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
