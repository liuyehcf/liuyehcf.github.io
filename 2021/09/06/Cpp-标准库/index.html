<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="阅读更多">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp-标准库">
<meta property="og:url" content="http://example.com/2021/09/06/Cpp-%E6%A0%87%E5%87%86%E5%BA%93/index.html">
<meta property="og:site_name" content="Liuye Notebook">
<meta property="og:description" content="阅读更多">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-09-06T02:54:02.000Z">
<meta property="article:modified_time" content="2022-03-31T15:10:19.595Z">
<meta property="article:author" content="Liuyehcf">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/09/06/Cpp-%E6%A0%87%E5%87%86%E5%BA%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Cpp-标准库 | Liuye Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Liuye Notebook</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-explore">

    <a href="/explore/" rel="section"><i class="fa fa-sitemap fa-fw"></i>发现</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/06/Cpp-%E6%A0%87%E5%87%86%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Liuyehcf">
      <meta itemprop="description" content="大音希声，大象无形">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liuye Notebook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Cpp-标准库
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-06 10:54:02" itemprop="dateCreated datePublished" datetime="2021-09-06T10:54:02+08:00">2021-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-31 23:10:19" itemprop="dateModified" datetime="2022-03-31T23:10:19+08:00">2022-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          
            <span id="/2021/09/06/Cpp-%E6%A0%87%E5%87%86%E5%BA%93/" class="post-meta-item leancloud_visitors" data-flag-title="Cpp-标准库" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/09/06/Cpp-%E6%A0%87%E5%87%86%E5%BA%93/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/06/Cpp-%E6%A0%87%E5%87%86%E5%BA%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>阅读更多</strong></p>
<a id="more"></a>
<h1 id="1-any"><a class="markdownIt-Anchor" href="#1-any"></a> 1 any</h1>
<p><strong><code>std::any</code>用于持有任意类型的对象，类似于Java中的<code>java.lang.Object</code></strong></p>
<ul>
<li><code>std::any_cast</code>用于将<code>any</code>对象转换成对应的类型。若类型错误则会抛出<code>std::bad_any_cast</code></li>
</ul>
<h1 id="2-atomic"><a class="markdownIt-Anchor" href="#2-atomic"></a> 2 atomic</h1>
<h2 id="21-内存一致性模型"><a class="markdownIt-Anchor" href="#21-内存一致性模型"></a> 2.1 内存一致性模型</h2>
<h3 id="211-sequential-consistency-model"><a class="markdownIt-Anchor" href="#211-sequential-consistency-model"></a> 2.1.1 Sequential consistency model</h3>
<blockquote>
<p>the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program</p>
</blockquote>
<p><strong><code>Sequential consistency model（SC）</code>，也称为顺序一致性模型，其实就是规定了两件事情：</strong></p>
<ol>
<li><strong>每个线程内部的指令都是按照程序规定的顺序（program order）执行的（单个线程的视角）</strong></li>
<li><strong>线程执行的交错顺序可以是任意的，但是所有线程所看见的整个程序的总体执行顺序都是一样的（整个程序的视角）</strong>
<ul>
<li>即不能存在这样一种情况，对于写操作<code>W1</code>和<code>W2</code>，处理器1看来，顺序是：<code>W1 -&gt; W2</code>；而处理器2看来，顺序是：<code>W2 -&gt; W1</code></li>
</ul>
</li>
</ol>
<h3 id="212-relaxed-consistency-model"><a class="markdownIt-Anchor" href="#212-relaxed-consistency-model"></a> 2.1.2 Relaxed consistency model</h3>
<p><strong><code>Relaxed consistency model</code>也称为宽松内存一致性模型，它的特点是：</strong></p>
<ol>
<li><strong>唯一的要求是在同一线程中，对同一原子变量的访问不可以被重排（单个线程的视角）</strong></li>
<li><strong>除了保证操作的原子性之外，没有限定前后指令的顺序，其他线程看到数据的变化顺序也可能不一样（整个程序的视角）</strong></li>
</ol>
<h2 id="22-stdatomic"><a class="markdownIt-Anchor" href="#22-stdatomic"></a> 2.2 std::atomic</h2>
<p><code>compare_exchange_strong(T&amp; expected_value, T new_value)</code>方法的第一个参数是个左值</p>
<ul>
<li>当前值与期望值<code>expected_value</code>相等时，修改当前值为设定值<code>new_value</code>，返回true</li>
<li>当前值与期望值<code>expected_value</code>不等时，将期望值修改为当前值，返回false（这样更加方便循环，否则还得手动再读一次）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="keyword">atomic_bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> expected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="literal">true</span>)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, flag: &quot;</span> &lt;&lt; flag &lt;&lt; <span class="string">&quot;, expected: &quot;</span> &lt;&lt; expected &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="literal">true</span>)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, flag: &quot;</span> &lt;&lt; flag &lt;&lt; <span class="string">&quot;, expected: &quot;</span> &lt;&lt; expected &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result: 1, flag: 1, expected: 0</span><br><span class="line">result: 0, flag: 1, expected: 1</span><br></pre></td></tr></table></figure>
<p><strong><code>compare_exchange_weak(T&amp; expected_value, T new_value)</code>方法与<code>strong</code>版本基本相同，唯一的区别是<code>weak</code>版本允许偶然出乎意料的返回（相等时却返回了false），在大部分场景中，这种意外是可以接受的，通常比<code>strong</code>版本有更高的性能</strong></p>
<h2 id="23-stdmemory_order"><a class="markdownIt-Anchor" href="#23-stdmemory_order"></a> 2.3 std::memory_order</h2>
<p>这是个枚举类型，包含6个枚举值</p>
<ul>
<li><code>memory_order_relaxed</code></li>
<li><code>memory_order_consume</code></li>
<li><code>memory_order_acquire</code></li>
<li><code>memory_order_release</code></li>
<li><code>memory_order_acq_rel</code></li>
<li><code>memory_order_seq_cst</code></li>
</ul>
<h3 id="231-顺序一致次序sequential-consisten-ordering"><a class="markdownIt-Anchor" href="#231-顺序一致次序sequential-consisten-ordering"></a> 2.3.1 顺序一致次序（sequential consisten ordering）</h3>
<p><code>memory_order_seq_cst</code>属于这种内存模型</p>
<p><code>SC</code>作为默认的内存序，是因为它意味着将程序看做是一个简单的序列。如果对于一个原子变量的操作都是顺序一致的，那么多线程程序的行为就像是这些操作都以一种特定顺序被单线程程序执行</p>
<p><strong>该原子操作前后的读写（包括非原子的读写操作）不能跨过该操作乱序；该原子操作之前的写操作（包括非原子的写操作）都能被所有线程观察到</strong></p>
<h3 id="232-松弛次序relaxed-ordering"><a class="markdownIt-Anchor" href="#232-松弛次序relaxed-ordering"></a> 2.3.2 松弛次序（relaxed ordering）</h3>
<p><code>memory_order_relaxed</code>属于这种内存模型</p>
<p>在原子变量上采用<code>relaxed ordering</code>的操作不参与<code>synchronized-with</code>关系。在同一线程内对同一变量的操作仍保持<code>happens-before</code>关系，但这与别的线程无关</p>
<p>在<code>relaxed ordering</code>中唯一的要求是在同一线程中，对同一原子变量的访问不可以被重排</p>
<h3 id="233-获取-释放次序acquire-release-ordering"><a class="markdownIt-Anchor" href="#233-获取-释放次序acquire-release-ordering"></a> 2.3.3 获取-释放次序（acquire-release ordering）</h3>
<p><code>memory_order_release</code>、<code>memory_order_acquire</code>、<code>memory_order_acq_rel</code>属于这种内存模型</p>
<p><code>memory_order_release</code>用于写操作<code>store</code>，<code>memory_order_acquire</code>用于读操作<code>load</code></p>
<ul>
<li><code>memory_order_release</code>「原子操作之前的读写（包括非原子的读写）」不能往后乱序；并且之前的写操作（包括非原子的写操作），会被使用<code>acquire/consume</code>的线程观察到，这里要注意它和<code>seq_cst</code>不同的是只有相关的线程才能观察到写变化，所谓相关线程就是使用<code>acquire</code>或<code>consume</code>模式加载同一个共享变量的线程；而<code>seq_cst</code>是所有线程都观察到了</li>
<li><code>memory_order_acquire</code>「原子操作之后的读写」不能往前乱序；它能看到<code>release</code>线程在调用<code>load</code>之前的那些写操作</li>
<li><code>memory_order_acq_rel</code>是<code>memory_order_release</code>与<code>memory_order_acquire</code>的合并，前后的读写都是不能跨过这个原子操作，但仅相关的线程能看到前面写的变化</li>
<li><code>memory_order_consume</code>和<code>memory_order_acquire</code>比较接近，也是和<code>memory_order_release</code>一起使用的；和<code>memory_order_acquire</code>不一样的地方是加了一个限定条件：依赖于该读操作的后续读写不能往前乱序；它可以看到release线程在调用load之前那些依赖的写操作，依赖于的意思是和该共享变量有关的写操作</li>
</ul>
<p>看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-Thread 1-</span><br><span class="line"> n = 1</span><br><span class="line"> m = 1</span><br><span class="line"> p.store (&amp;n, memory_order_release)</span><br><span class="line"></span><br><span class="line">-Thread 2-</span><br><span class="line"> t = p.load (memory_order_acquire);</span><br><span class="line"> if (*t == 1)</span><br><span class="line">    assert(m == 1);</span><br><span class="line"></span><br><span class="line">-Thread 3-</span><br><span class="line"> t = p.load (memory_order_consume);</span><br><span class="line"> if (*t == 1)</span><br><span class="line">    assert(m == 1);</span><br></pre></td></tr></table></figure>
<ul>
<li>线程2的断言会成功，因为线程1对<code>n</code>和<code>m</code>在store之前修改；线程2在<code>load</code>之后，可以观察到<code>m</code>的修改</li>
<li>但线程3的断言不一定会成功，因为<code>m</code>是和<code>load/store</code>操作不相关的变量，线程3不一定能观察看到</li>
</ul>
<h2 id="24-参考"><a class="markdownIt-Anchor" href="#24-参考"></a> 2.4 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107092432">C++11 - atomic类型和内存模型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.apiref.com/cpp-zh/cpp/atomic/memory_order.html">doc-std::memory_order</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24301047">如何理解 C++11 的六种 memory order？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiayy/p/3246157.html">并行编程——内存模型之顺序一致性</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91406250">漫谈内存一致性模型</a></li>
</ul>
<h1 id="3-chrono"><a class="markdownIt-Anchor" href="#3-chrono"></a> 3 chrono</h1>
<h2 id="31-clock"><a class="markdownIt-Anchor" href="#31-clock"></a> 3.1 clock</h2>
<p><strong>三种时钟：</strong></p>
<ol>
<li><code>steady_clock</code>：是单调的时钟。其绝对值无意义，只会增长，适合用于记录程序耗时。</li>
<li><code>system_clock</code>：是系统的时钟，且系统的时钟可以修改，甚至可以网络对时。所以用系统时间计算时间差可能不准</li>
<li><code>high_resolution_clock</code>：是当前系统能够提供的最高精度的时钟。它也是不可以修改的。相当于<code>steady_clock</code>的高精度版本</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto start = std::chrono::steady_clock::now();</span><br><span class="line">auto end = std::chrono::steady_clock::now();</span><br><span class="line">auto nanos = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - start).count();</span><br></pre></td></tr></table></figure>
<h1 id="4-functional"><a class="markdownIt-Anchor" href="#4-functional"></a> 4 functional</h1>
<ol>
<li><code>std::function</code>：其功能类似于函数指针，在需要函数指针的地方，可以传入<code>std::function</code>类型的对象（不是指针）</li>
<li><code>std::bind</code></li>
<li><code>std::mem_fn</code></li>
</ol>
<h2 id="41-参考"><a class="markdownIt-Anchor" href="#41-参考"></a> 4.1 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f191e88dcc80">C++11 中的std::function和std::bind</a></li>
</ul>
<h1 id="5-future"><a class="markdownIt-Anchor" href="#5-future"></a> 5 future</h1>
<ol>
<li><code>std::promise</code></li>
<li><code>std::future</code></li>
</ol>
<h1 id="6-limits"><a class="markdownIt-Anchor" href="#6-limits"></a> 6 limits</h1>
<ol>
<li><code>std::numeric_limits</code>
<ul>
<li><code>std::numeric_limits&lt;int32_t&gt;::max()</code></li>
</ul>
</li>
</ol>
<h1 id="7-memory"><a class="markdownIt-Anchor" href="#7-memory"></a> 7 memory</h1>
<h2 id="71-stdshared_ptr"><a class="markdownIt-Anchor" href="#71-stdshared_ptr"></a> 7.1 std::shared_ptr</h2>
<p><strong>只在函数使用指针，但并不保存对象内容</strong></p>
<p>假如我们只需要在函数中，用这个对象处理一些事情，但不打算涉及其生命周期的管理，也不打算通过函数传参延长<code>shared_ptr</code>的生命周期。对于这种情况，可以使用<code>raw pointer</code>或者<code>const shared_ptr&amp;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Widget*)</span></span>;</span><br><span class="line"><span class="comment">// 不发生拷贝，引用计数未增加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> shared_ptr&lt;Widget&gt;&amp;)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>在函数中保存智能指针</strong></p>
<p>假如我们需要在函数中把这个智能指针保存起来，这个时候建议直接传值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传参时发生拷贝，引用计数增加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(std::shared_ptr&lt;Widget&gt; ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样的话，外部传过来值的时候，可以选择<code>move</code>或者赋值。函数内部直接把这个对象通过<code>move</code>的方式保存起来</p>
<h2 id="72-stdenable_shared_from_this"><a class="markdownIt-Anchor" href="#72-stdenable_shared_from_this"></a> 7.2 std::enable_shared_from_this</h2>
<p><strong><code>std::enable_shared_from_this</code>能让一个由<code>std::shared_ptr</code>管理的对象，安全地生成其他额外的<code>std::shared_ptr</code>实例，原实例和新生成的示例共享所有权</strong></p>
<ul>
<li>只能通过<code>std::make_shared</code>来创建实例（不能用<code>new</code>），否则会报错</li>
<li>普通对象（非只能指针管理）调用<code>std::enable_shared_from_this::shared_from_this</code>方法，也会报错</li>
</ul>
<p><strong>有什么用途？当你持有的是某个对象的裸指针时（该对象的生命周期由智能指针管理），但此时你又想获取该对象的智能指针，此时就需要依赖<code>std::enable_shared_from_this</code></strong></p>
<ul>
<li>不能将<code>this</code>直接放入某个<code>std::shared_ptr</code>中，这样会导致<code>delete</code>野指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> :</span> <span class="keyword">public</span> std::enable_shared_from_this&lt;Demo&gt; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = std::make_shared&lt;Demo&gt;();</span><br><span class="line">    <span class="keyword">auto</span> another_ptr = ptr-&gt;<span class="built_in">shared_from_this</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; another_ptr.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="73-stdunique_ptr"><a class="markdownIt-Anchor" href="#73-stdunique_ptr"></a> 7.3 std::unique_ptr</h2>
<h2 id="74-参考"><a class="markdownIt-Anchor" href="#74-参考"></a> 7.4 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cyhone.com/articles/right-way-to-use-cpp-smart-pointer/">C++ 智能指针的正确使用方式</a></li>
</ul>
<h1 id="8-mutex"><a class="markdownIt-Anchor" href="#8-mutex"></a> 8 mutex</h1>
<ol>
<li>
<p><code>std::mutex</code></p>
</li>
<li>
<p><code>std::lock_guard</code></p>
<ul>
<li>直接使用<code>std::mutex</code>，如下面的例子。如果<code>getVar</code>方法抛出异常了，那么就会导致<code>m.unlock()</code>方法无法执行，可能会造成死锁</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mutex m;</span><br><span class="line">m.<span class="built_in">lock</span>();</span><br><span class="line">sharedVariable= <span class="built_in">getVar</span>();</span><br><span class="line">m.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>一种优雅的方式是使用<code>std::lock_guard</code>，该对象的析构方法中会进行锁的释放，需要将串行部分放到一个<code>&#123;&#125;</code>中，当退出该作用域时，<code>std::lock_guard</code>对象会析构，并释放锁，在任何正常或异常情况下都能够释放锁</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">std::mutex m,</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lockGuard</span><span class="params">(m)</span></span>;</span><br><span class="line">sharedVariable= <span class="built_in">getVar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>std::unique_lock</code></p>
</li>
<li>
<p><code>std::condition_variable</code></p>
<ul>
<li>调用<code>wait</code>方法时，必须获取监视器。而调用<code>notify</code>方法时，无需获取监视器</li>
</ul>
</li>
</ol>
<h2 id="81-参考"><a class="markdownIt-Anchor" href="#81-参考"></a> 8.1 参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/17101922/do-i-have-to-acquire-lock-before-calling-condition-variable-notify-one">Do I have to acquire lock before calling condition_variable.notify_one()?</a></li>
</ul>
<h1 id="9-numeric"><a class="markdownIt-Anchor" href="#9-numeric"></a> 9 numeric</h1>
<ol>
<li><code>std::accumulate</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;std::string&gt; col = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::string res = std::<span class="built_in">accumulate</span>(std::<span class="built_in">begin</span>(col),</span><br><span class="line">                                    std::<span class="built_in">end</span>(col),</span><br><span class="line">                                    std::<span class="built_in">string</span>(),</span><br><span class="line">                                    [](<span class="keyword">const</span> std::string &amp;a, <span class="keyword">const</span> std::string &amp;b) &#123;</span><br><span class="line">                                        <span class="keyword">return</span> a.<span class="built_in">empty</span>() ? b</span><br><span class="line">                                                        : a + <span class="string">&quot;, &quot;</span> + b;</span><br><span class="line">                                    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="10-optional"><a class="markdownIt-Anchor" href="#10-optional"></a> 10 optional</h1>
<ol>
<li><code>std::optional</code></li>
</ol>
<h1 id="11-string"><a class="markdownIt-Anchor" href="#11-string"></a> 11 string</h1>
<ol>
<li><code>std::string</code></li>
<li><code>std::to_string</code></li>
</ol>
<h1 id="12-thread"><a class="markdownIt-Anchor" href="#12-thread"></a> 12 thread</h1>
<p><strong>如何设置或修改线程名：</strong></p>
<ol>
<li><code>pthread_setname_np/pthread_getname_np</code>，需要引入头文件<code>&lt;pthread.h&gt;</code>，<code>np</code>表示<code>non-portable</code>，即平台相关</li>
<li><code>prctl(PR_GET_NAME, name)/prctl(PR_SET_NAME, name)</code>，需要引入头文件<code>&lt;sys/prctl.h&gt;</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">change_thread_name</span><span class="params">(<span class="keyword">void</span>* = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// avoid change name before set original thread name</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> original_thread_name[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">prctl</span>(PR_GET_NAME, original_thread_name);</span><br><span class="line">    <span class="keyword">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; original_thread_name &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; cnt++;</span><br><span class="line">        <span class="built_in">prctl</span>(PR_SET_NAME, ss.<span class="built_in">str</span>().<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> current_thread_name[<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">prctl</span>(PR_GET_NAME, current_thread_name);</span><br><span class="line">        std::cout &lt;&lt; current_thread_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_thread_by_pthread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, change_thread_name, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(tid, <span class="string">&quot;pthread&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_thread_by_std</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; func = []() &#123; <span class="built_in">change_thread_name</span>(); &#125;;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(t.<span class="built_in">native_handle</span>(), <span class="string">&quot;std-thread&quot;</span>);</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">333</span>));</span><br><span class="line">    <span class="built_in">create_thread_by_pthread</span>();</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">333</span>));</span><br><span class="line">    <span class="built_in">create_thread_by_std</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">prctl</span>(PR_SET_NAME, <span class="string">&quot;main&quot;</span>);</span><br><span class="line">    <span class="built_in">change_thread_name</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="13-type_traits"><a class="markdownIt-Anchor" href="#13-type_traits"></a> 13 type_traits</h1>
<p><strong>具体分类可以参考<code>&lt;type_traits&gt;</code>头文件的注释</strong></p>
<h2 id="131-谓词模板"><a class="markdownIt-Anchor" href="#131-谓词模板"></a> 13.1 谓词模板</h2>
<p>用于判断类型</p>
<ol>
<li><code>std::is_void</code></li>
<li><code>std::is_array</code></li>
<li>…</li>
</ol>
<h2 id="132-属性模板"><a class="markdownIt-Anchor" href="#132-属性模板"></a> 13.2 属性模板</h2>
<p>用于调整类型信息</p>
<ol>
<li><code>std::remove_reference</code></li>
<li><code>std::add_lvalue_reference_t</code></li>
<li><code>std::add_rvalue_reference_t</code></li>
</ol>
<h2 id="133-别名模板"><a class="markdownIt-Anchor" href="#133-别名模板"></a> 13.3 别名模板</h2>
<p>只是一种简写，例如<code>std::enable_if_t</code>等价于<code>typename enable_if&lt;b,T&gt;::type</code></p>
<ol>
<li><code>std::enable_if_t</code></li>
<li><code>std::conditional_t</code></li>
<li><code>std::remove_reference_t</code></li>
<li><code>std::result_of_t</code></li>
<li><code>std::invoke_result_t</code></li>
<li>…</li>
</ol>
<h2 id="134-stdmove"><a class="markdownIt-Anchor" href="#134-stdmove"></a> 13.4 std::move</h2>
<p>标准库的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>本质上，就是做了一次类型转换，返回的一定是个右值</p>
<h2 id="135-stdforward"><a class="markdownIt-Anchor" href="#135-stdforward"></a> 13.5 std::forward</h2>
<p><code>std::forward</code>主要用于实现模板的完美转发：因为对于一个变量而言，无论该变量的类型是左值引用还是右值引用，变量本身都是左值，如果直接将变量传递到下一个方法中，那么一定是按照左值来匹配重载函数的，而<code>std::forward</code>就是为了解决这个问题。请看下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;left reference version, value=&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;&amp;value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;right reference version, value=&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_without_forward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_with_forward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dispatch_without_forward</span>(value); <span class="comment">// left reference version, value=0</span></span><br><span class="line">    <span class="built_in">dispatch_without_forward</span>(<span class="number">1</span>); <span class="comment">// left reference version, value=1</span></span><br><span class="line"></span><br><span class="line">    value = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">dispatch_with_forward</span>(value); <span class="comment">// left reference version, value=2</span></span><br><span class="line">    <span class="built_in">dispatch_with_forward</span>(<span class="number">3</span>); <span class="comment">// right reference version, value=3</span></span><br><span class="line"></span><br><span class="line">    value = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;<span class="keyword">int</span>&gt;(value)); <span class="comment">// right reference version, value=4 (!!! very strange !!!)</span></span><br><span class="line">    value = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;<span class="keyword">int</span> &amp;&gt;(value)); <span class="comment">// left reference version, value=5</span></span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;<span class="keyword">int</span> &amp;&amp;&gt;(<span class="number">6</span>)); <span class="comment">// right reference version, value=6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准库的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">                  <span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>在使用<code>std::forward</code>时，模板实参都是需要显式指定的，而不是推断出来的</strong></p>
<ul>
<li>如果模板实参是左值、左值引用或右值引用，那么匹配第一个方法
<ul>
<li>左值：<code>_Tp&amp;&amp;</code>得到的是个右值（很奇怪吧，因为一般都不是这么用的）</li>
<li><strong>左值引用：<code>_Tp&amp;&amp;</code>得到的是个左值引用（完美转发会用到）</strong></li>
<li><strong>右值应用：<code>_Tp&amp;&amp;</code>得到的是个右值引用（完美转发会用到）</strong></li>
</ul>
</li>
<li>如果模板实参是左值或右值，那么匹配的是第二个方法
<ul>
<li>右值：<code>_Tp&amp;&amp;</code>得到的是个右值</li>
</ul>
</li>
</ul>
<h1 id="14-utility"><a class="markdownIt-Anchor" href="#14-utility"></a> 14 utility</h1>
<ol>
<li><code>std::pair</code></li>
</ol>
<h1 id="15-容器"><a class="markdownIt-Anchor" href="#15-容器"></a> 15 容器</h1>
<ol>
<li><code>&lt;vector&gt;</code></li>
<li><code>&lt;array&gt;</code></li>
<li><code>&lt;list&gt;</code></li>
<li><code>&lt;queue&gt;</code></li>
<li><code>&lt;deque&gt;</code></li>
<li><code>&lt;map&gt;</code></li>
<li><code>&lt;unordered_map&gt;</code></li>
<li><code>&lt;set&gt;</code></li>
<li><code>&lt;unordered_set&gt;</code></li>
</ol>
<h2 id="151-tips"><a class="markdownIt-Anchor" href="#151-tips"></a> 15.1 Tips</h2>
<ol>
<li><code>std::map</code>和<code>std::unordered_map</code>的<code>value</code>是<code>Pointer Stability</code>，即地址在容器自身容量调整前后是不会变的</li>
<li><code>std::map</code>或者<code>std::set</code>用下标访问后，即便访问前元素不存在，也会插入一个默认值。因此下标访问是非<code>const</code>的</li>
</ol>
<h1 id="16-c标准库"><a class="markdownIt-Anchor" href="#16-c标准库"></a> 16 C标准库</h1>
<ol>
<li><code>stdio.h</code></li>
<li><code>stddef.h</code></li>
<li><code>stdint.h</code></li>
<li><code>cstdlib</code>
<ul>
<li><code>std::atoi</code></li>
<li><code>std::atol</code></li>
<li><code>std::atoll</code></li>
</ul>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag"># 原创</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/09/06/Cpp-%E8%AF%AD%E8%A8%80/" rel="prev" title="Cpp-语言">
      <i class="fa fa-chevron-left"></i> Cpp-语言
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/06/Cpp-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" rel="next" title="Cpp-常用技巧">
      Cpp-常用技巧 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-livere">livere</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzY0My8xMDE5OA=="></div>
  </div>
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-any"><span class="nav-text"> 1 any</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-atomic"><span class="nav-text"> 2 atomic</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B"><span class="nav-text"> 2.1 内存一致性模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#211-sequential-consistency-model"><span class="nav-text"> 2.1.1 Sequential consistency model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#212-relaxed-consistency-model"><span class="nav-text"> 2.1.2 Relaxed consistency model</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-stdatomic"><span class="nav-text"> 2.2 std::atomic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-stdmemory_order"><span class="nav-text"> 2.3 std::memory_order</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#231-%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%AC%A1%E5%BA%8Fsequential-consisten-ordering"><span class="nav-text"> 2.3.1 顺序一致次序（sequential consisten ordering）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#232-%E6%9D%BE%E5%BC%9B%E6%AC%A1%E5%BA%8Frelaxed-ordering"><span class="nav-text"> 2.3.2 松弛次序（relaxed ordering）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#233-%E8%8E%B7%E5%8F%96-%E9%87%8A%E6%94%BE%E6%AC%A1%E5%BA%8Facquire-release-ordering"><span class="nav-text"> 2.3.3 获取-释放次序（acquire-release ordering）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-%E5%8F%82%E8%80%83"><span class="nav-text"> 2.4 参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-chrono"><span class="nav-text"> 3 chrono</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#31-clock"><span class="nav-text"> 3.1 clock</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-functional"><span class="nav-text"> 4 functional</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#41-%E5%8F%82%E8%80%83"><span class="nav-text"> 4.1 参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-future"><span class="nav-text"> 5 future</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-limits"><span class="nav-text"> 6 limits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-memory"><span class="nav-text"> 7 memory</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#71-stdshared_ptr"><span class="nav-text"> 7.1 std::shared_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72-stdenable_shared_from_this"><span class="nav-text"> 7.2 std::enable_shared_from_this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#73-stdunique_ptr"><span class="nav-text"> 7.3 std::unique_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#74-%E5%8F%82%E8%80%83"><span class="nav-text"> 7.4 参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-mutex"><span class="nav-text"> 8 mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#81-%E5%8F%82%E8%80%83"><span class="nav-text"> 8.1 参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-numeric"><span class="nav-text"> 9 numeric</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-optional"><span class="nav-text"> 10 optional</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-string"><span class="nav-text"> 11 string</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-thread"><span class="nav-text"> 12 thread</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-type_traits"><span class="nav-text"> 13 type_traits</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#131-%E8%B0%93%E8%AF%8D%E6%A8%A1%E6%9D%BF"><span class="nav-text"> 13.1 谓词模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#132-%E5%B1%9E%E6%80%A7%E6%A8%A1%E6%9D%BF"><span class="nav-text"> 13.2 属性模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#133-%E5%88%AB%E5%90%8D%E6%A8%A1%E6%9D%BF"><span class="nav-text"> 13.3 别名模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#134-stdmove"><span class="nav-text"> 13.4 std::move</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#135-stdforward"><span class="nav-text"> 13.5 std::forward</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-utility"><span class="nav-text"> 14 utility</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-%E5%AE%B9%E5%99%A8"><span class="nav-text"> 15 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#151-tips"><span class="nav-text"> 15.1 Tips</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-c%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text"> 16 C标准库</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liuyehcf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Liuyehcf</p>
  <div class="site-description" itemprop="description">大音希声，大象无形</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">286</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">103</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liuyehcf</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qhEhLuMeMOy1zgcBhkqUS6P8-gzGzoHsz',
      appKey     : 'uhkruDLNLNdL5rQjRBY2X9Ke',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
