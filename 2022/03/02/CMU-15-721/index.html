<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="阅读更多">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU-15-721">
<meta property="og:url" content="http://example.com/2022/03/02/CMU-15-721/index.html">
<meta property="og:site_name" content="Liuye Notebook">
<meta property="og:description" content="阅读更多">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/CMU-15-721/1-1.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/1-2.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/1-3.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/1-4.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/1-5.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/3-1.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/3-2.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/3-3.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/4-1.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/4-2.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/4-3.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/6-1.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/7-1.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/7-2.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/7-3.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/7-4.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/7-5.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/7-6.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/7-7.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/7-8.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/8-1.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/8-2.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/8-3.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/8-4.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/8-5.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/8-6.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/8-7.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/9-1.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/9-2.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/9-3.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/9-4.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/9-5.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/9-6.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/9-7.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/9-8.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/9-9.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/10-1.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/11-1.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/11-2.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/11-3.png">
<meta property="og:image" content="http://example.com/images/CMU-15-721/11-4.png">
<meta property="article:published_time" content="2022-03-02T01:04:53.000Z">
<meta property="article:modified_time" content="2022-03-26T03:18:00.258Z">
<meta property="article:author" content="Liuyehcf">
<meta property="article:tag" content="摘录">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/CMU-15-721/1-1.png">

<link rel="canonical" href="http://example.com/2022/03/02/CMU-15-721/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CMU-15-721 | Liuye Notebook</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Liuye Notebook</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-explore">

    <a href="/explore/" rel="section"><i class="fa fa-sitemap fa-fw"></i>发现</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/02/CMU-15-721/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Liuyehcf">
      <meta itemprop="description" content="大音希声，大象无形">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liuye Notebook">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CMU-15-721
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-02 09:04:53" itemprop="dateCreated datePublished" datetime="2022-03-02T09:04:53+08:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-26 11:18:00" itemprop="dateModified" datetime="2022-03-26T11:18:00+08:00">2022-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Database/" itemprop="url" rel="index"><span itemprop="name">Database</span></a>
                </span>
            </span>

          
            <span id="/2022/03/02/CMU-15-721/" class="post-meta-item leancloud_visitors" data-flag-title="CMU-15-721" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/02/CMU-15-721/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/02/CMU-15-721/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>阅读更多</strong></p>
<a id="more"></a>
<h1 id="1-history"><a class="markdownIt-Anchor" href="#1-history"></a> 1 history</h1>
<p><strong><code>1960s - Integrated Data Store, IDS</code></strong></p>
<ul>
<li><code>Network data model</code>：见下图</li>
<li><code>Tuple-at-a-time</code></li>
<li><img src="/images/CMU-15-721/1-1.png" alt="1-1" /></li>
</ul>
<p><strong><code>1960s - Information Management System, IMS</code></strong></p>
<ul>
<li><code>Hierarchical data model</code>：见下图</li>
<li><code>Programmer-defined physical storage format</code></li>
<li><code>Tuple-at-a-time</code></li>
<li><img src="/images/CMU-15-721/1-2.png" alt="1-2" /></li>
</ul>
<p><strong><code>1970s - Relational Model</code></strong></p>
<ul>
<li><code>Store database in simple data structures</code></li>
<li><code>Access data through high-level language</code></li>
<li><code>Physical storage left up to implementation</code></li>
<li><img src="/images/CMU-15-721/1-3.png" alt="1-3" /></li>
<li>早期的实现包括
<ul>
<li><code>System R</code></li>
<li><code>INGRES</code></li>
<li><code>Oracle</code></li>
</ul>
</li>
</ul>
<p><strong><code>1980s - Relational Model</code></strong></p>
<ul>
<li><code>Relation Model</code>在角逐中胜出，<code>SEQUEL</code>演变成为<code>SQL</code></li>
<li><code>Oracle</code>在商业角逐中胜出</li>
<li><code>Stonebraker</code>创立了<code>Postgre</code></li>
</ul>
<p><strong><code>1980s - Object-Oriented Databases</code></strong></p>
<ul>
<li>大多数这一阶段产生的<code>DBMS</code>在今天都不存在了，但是这些技术以另一种方式存在，比如<code>JSON/XML</code>等</li>
<li><img src="/images/CMU-15-721/1-4.png" alt="1-4" /></li>
<li><img src="/images/CMU-15-721/1-5.png" alt="1-5" /></li>
</ul>
<p><strong><code>1990s - Boring Days</code></strong></p>
<ul>
<li>这十年中，数据库系统没有重大进步</li>
<li>微软借鉴了<code>Sybase</code>，创立了<code>SQL Server</code></li>
<li><code>Mysql</code>出现，作为<code>mSQL</code>的一种替代方案</li>
<li><code>Postgres</code>支持<code>SQL</code></li>
<li><code>SQLite</code>在2000年早期出现</li>
</ul>
<p><strong><code>2000s - Internet Boom</code></strong></p>
<ul>
<li>网络大发展，分布式兴起</li>
<li>原有的数据库都是重量级且及其昂贵的，在分布式的场景中不再有优势</li>
<li>各大公司都独立开发中间件，用以支持<code>DBMS</code>的水平伸缩</li>
</ul>
<p><strong><code>2000s - Data Warehouses</code></strong></p>
<ul>
<li><code>OLAP</code>兴起</li>
<li><code>Relational / SQL</code></li>
<li>分布式、<code>Shared-Noting</code>架构</li>
<li>列存大放异彩</li>
</ul>
<p><strong><code>2000s - NoSQL Systems</code></strong></p>
<ul>
<li>专注于高可用和高可扩展</li>
<li><code>Non-relational data model</code>，例如键值对</li>
<li>无<code>ACID</code>事务</li>
<li><code>API</code>取代了<code>SQL</code></li>
</ul>
<p><strong><code>2010s - NewSQL</code></strong></p>
<ul>
<li>在支持<code>ACID</code>事务的同时，提供与<code>NoSQL</code>相当的性能</li>
<li><code>Relational / SQL</code></li>
<li>分布式</li>
</ul>
<p><strong><code>2010s - Hybrid Systems</code></strong></p>
<ul>
<li><code>Hybrid Transactional-Analytical Processing, HTAP</code></li>
<li>同时提供<code>OLTP</code>和<code>OLAP</code>的功能和性能</li>
<li>分布式、<code>Shared-Noting</code>架构</li>
<li><code>Relational / SQL</code></li>
</ul>
<p><strong><code>2010s - Cloud Systems</code></strong></p>
<ul>
<li><code>DBaaS, Database-as-a-service</code></li>
</ul>
<p><strong><code>2010s - Shared-Disk Engines</code></strong></p>
<ul>
<li>存储计算分离</li>
<li>通常用于数据湖（<code>Data Lake</code>）</li>
</ul>
<p><strong><code>2010s - Graph Systems</code></strong></p>
<ul>
<li>提供了针对图形的API</li>
<li>研究表明，尚不清楚使用以图形为中心的执行引擎和存储管理器是否有任何好处</li>
</ul>
<p><strong><code>2010s - Timeseries Systems</code></strong></p>
<ul>
<li>时序数据库，主要存储时序相关的数据</li>
</ul>
<p><strong><code>Andy's Thoughts</code></strong></p>
<ul>
<li>随着专用系统扩展其领域范围，<code>DBMS</code>类别的分界线将随着时间的推移而继续模糊</li>
<li>我相信关系模型和声明式查询语言促进了更好的数据工程</li>
</ul>
<h1 id="2-inmemory"><a class="markdownIt-Anchor" href="#2-inmemory"></a> 2 inmemory</h1>
<h2 id="21-disk-oriented-dbmss"><a class="markdownIt-Anchor" href="#21-disk-oriented-dbmss"></a> 2.1 Disk-Oriented DBMSs</h2>
<p><strong><code>Buffer Pool</code></strong></p>
<p><strong><code>Steal + No-Force</code></strong></p>
<p><strong>示意图参考课件中的<code>7 ~ 13</code>页</strong></p>
<h2 id="22-in-memory-dbmss"><a class="markdownIt-Anchor" href="#22-in-memory-dbmss"></a> 2.2 In-Memory DBMSs</h2>
<p><strong>首批商用的<code>In-Memory DBMS</code>在<code>1990s</code>发布，包括：</strong></p>
<ul>
<li><code>TimesTen</code></li>
<li><code>DataBlitz</code></li>
<li><code>Altibase</code></li>
</ul>
<p><strong>索引：</strong></p>
<ul>
<li><code>1980s</code>提出了专门的主存索引，当时高速缓存和内存访问速度大致相当</li>
<li>但后来高速缓存的速度远远大于内存的访问速度时，内存优化索引的性能比<code>B+</code>树差，因为它们不支持缓存（为啥会不支持缓存）</li>
</ul>
<p><strong>执行查询计划：</strong></p>
<ul>
<li>由于数据都在内存中，顺序访问不再比随机访问快</li>
<li>传统的<code>tuple-at-a-time</code>的访问方式会因为函数调用的开销而变得很慢。这一情况在<code>OLAP</code>中更加突出</li>
</ul>
<p><strong><code>Logging &amp; Recovery</code></strong></p>
<ul>
<li><code>In-Memory DBMS</code>也需要将<code>WAL</code>写入非易失性存储上，因为系统可能随时崩溃</li>
<li>由于不存在<code>Dirty Page</code>，因此无需追踪整个系统中的<code>LSN</code></li>
</ul>
<p><strong>性能瓶颈：对于<code>In-Memory DBMS</code>来说，<code>I/O</code>不再是性能瓶颈，同时其他开销也会被放大：</strong></p>
<ul>
<li><code>Locking/Latching</code></li>
<li><code>Cache-line misses</code></li>
<li><code>Pointer chasing</code></li>
<li><code>Predicate evaluations</code></li>
<li><code>Data movement &amp; copying</code></li>
<li><code>Networking</code></li>
</ul>
<h2 id="23-concurrency-control-bottlenecks"><a class="markdownIt-Anchor" href="#23-concurrency-control-bottlenecks"></a> 2.3 Concurrency Control Bottlenecks</h2>
<p>对于<code>In-Memory DBMS</code>而言，事务获取锁的开销和访问数据的开销相当</p>
<ul>
<li><code>DBMS</code>可以将<code>Lock Information</code>与数据存储在一起，提高<code>CPU Cache Locality</code></li>
<li>需要用<code>CAS</code>替代<code>Mutex</code></li>
</ul>
<p><strong><code>Concurrency Control Schemes</code></strong></p>
<ul>
<li><code>Two-Phase Locking, 2PL</code>
<ul>
<li><code>DeadLock Detection</code></li>
<li><code>DeadLock Prevention</code></li>
<li><strong>示意图参考课件中的<code>30 ~ 37</code>页</strong></li>
</ul>
</li>
<li><code>Timestamp Ordering, T/O</code>
<ul>
<li><code>Basic T/O</code></li>
<li><code>Optimistic Concurrency Control, OCC</code></li>
<li><strong>示意图参考课件中的<code>40 ~ 63</code>页</strong></li>
</ul>
</li>
</ul>
<p><strong>仿真结果参考课件中的<code>71 ~ 75</code>页</strong></p>
<ul>
<li><code>Schemes</code>
<ul>
<li><code>DL_DETECT</code>：<code>2PL w/ DeadLock Detection</code></li>
<li><code>NO_WAIT</code>：<code>2PL w/ Non-waiting Prevention</code></li>
<li><code>WAIT_DIE``2PL w/ Wait-and-Die Prevention</code></li>
<li><code>TIMESTAMP</code>：<code>Basic T/O Algorithm</code></li>
<li><code>MVCC</code>：<code>Multi-Version T/O</code></li>
<li><code>OCC</code>：<code>Optimistic Concurrency Control</code></li>
</ul>
</li>
<li><code>Bottlenecks</code>
<ul>
<li><code>Lock Thrashing</code>：<code>DL_DETECT</code>、<code>WAIT_DIE</code>
<ul>
<li>按照<code>primary key</code>的顺序来获取锁，彻底消除死锁</li>
</ul>
</li>
<li><code>Timestamp Allocation</code>：<code>WAIT_DIE</code>、<code>All T/O Algorithm</code>
<ul>
<li><code>Mutex</code></li>
<li><code>Atomic Addition</code></li>
<li><code>Batched Atomic Addition</code></li>
<li><code>Hardware Clock</code></li>
<li><code>Hardware Counter</code></li>
</ul>
</li>
<li><code>Memory Allocations</code>：<code>OCC</code>、<code>MVCC</code>
<ul>
<li>不要使用默认的<code>malloc</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="3-mvcc1"><a class="markdownIt-Anchor" href="#3-mvcc1"></a> 3 mvcc1</h1>
<p><code>DBMS</code>对每个逻辑对象维护了多个物理版本</p>
<ul>
<li>当事务写某个对象时，会创建该对象的一个新的物理版本</li>
<li>当事务读某个对象时，会读取事物开始时该对象的最新版本。用时间戳来判断可见性</li>
<li>写操作不阻塞读操作</li>
<li>读操作不阻塞写操作</li>
</ul>
<p><strong><code>Snapshot Isolation, SI</code>：</strong></p>
<ul>
<li>若两个事务同时更新同一个对象，那么时间上较早写入的事务获胜</li>
<li>会产生<code>Write Skew Anomaly</code>，示意图参考课件中的<code>5 ~ 9</code>页</li>
</ul>
<p><img src="/images/CMU-15-721/3-1.png" alt="3-1" /></p>
<p><strong><code>MVCC</code>主要设计点：</strong></p>
<ul>
<li><code>Concurrency Control Protocol</code>
<ul>
<li><img src="/images/CMU-15-721/3-2.png" alt="3-2" /></li>
<li><code>Timestamp Ordering</code>
<ul>
<li><code>read-ts</code>：用于记录最近一次读取的时间</li>
<li>若<code>Latch</code>未被其他事务持有，且<code>Tid</code>介于<code>begin-ts</code>和<code>end-ts</code>之间，那么该记录对事务<code>T</code>可见</li>
<li>若<code>Latch</code>未被其他事务持有，且<code>Tid &gt; read-ts</code>，那么事务<code>T</code>可以创建当前记录的一个新版本</li>
</ul>
</li>
<li><code>Optimistic Concurrency Control</code></li>
<li><code>Two-Phase Locking</code>
<ul>
<li>使用<code>read-cnt</code>作为<code>Shared Lock</code>；使用<code>txn-id</code>以及<code>read-cnt</code>作为<code>Exclusive Lock</code></li>
<li>若<code>txn-id = 0</code>，那么递增<code>read-cnt</code>字段来表示获取<code>Shared Lock</code></li>
<li>若<code>txn-id = 0 &amp;&amp; read-cnt == 0</code>，那么将<code>txn-id</code>设置成当前事务的<code>Tid</code>，且递增<code>read-cnt</code>字段来表示获取<code>Exclusive Lock</code></li>
</ul>
</li>
<li><strong>示意图参考课件中的<code>15 ~ 40</code>页</strong></li>
</ul>
</li>
<li><code>Version Storage</code>
<ul>
<li><code>Append-Only Storage</code>
<ul>
<li>新版本会追加到<code>table</code>所在的同一个存储空间</li>
<li><code>Version Chain Ordering</code>
<ul>
<li><code>Oldest-to-Newest(O2N)</code>
<ul>
<li>新版本追加到链的尾部</li>
<li>查找时，需要遍历整个链</li>
</ul>
</li>
<li><code>Newest-to-Oldest(N2O)</code>
<ul>
<li>新版本插入到链的首部，有额外的更新指针的操作</li>
<li>查找时，无需遍历整个链</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>Time-Travel Storage</code>
<ul>
<li>维护两个数据表，一个叫做<code>Main Table</code>，另一个叫做<code>Time-Travel Table</code></li>
<li>每次更新时，都会将当前记录移动到<code>Time-Travel Table</code></li>
<li>同一记录的所有版本以<code>Newest-to-Oldest</code>的方式关联起来</li>
</ul>
</li>
<li><code>Delta Storage</code>
<ul>
<li>维护两个数据表，一个叫做<code>Main Table</code>，另一个叫做<code>Delta Storage Segment</code></li>
<li>每次更新时，将数值的变化表达式记录到<code>Delta Storage Segment</code>中</li>
<li>可以通过重放<code>Delta Storage Segment</code>来重建老的版本</li>
</ul>
</li>
<li><code>Non-Inline Attributes</code>
<ul>
<li>维护两个数据表，一个叫做<code>Main Table</code>，另一个叫做<code>Variable-Length Data</code></li>
<li>通过指针复用那些在多个版本间没有变化的属性
<ul>
<li>需要额外维护计数器</li>
<li>内存分配复杂</li>
</ul>
</li>
<li><img src="/images/CMU-15-721/3-3.png" alt="3-3" /></li>
</ul>
</li>
</ul>
</li>
<li><code>Garbage Collection</code>
<ul>
<li><code>DBMS</code>需要持续移除那些可回收的版本
<ul>
<li>对任何事务都不可见的版本</li>
<li>终止的事务创建的版本</li>
</ul>
</li>
<li>主要设计要点包括
<ul>
<li>如何查找过期版本</li>
<li>如何判断版本是否可回收</li>
<li>到哪查找过期版本</li>
</ul>
</li>
<li>实现方式
<ul>
<li><code>Tuple-Level</code>
<ul>
<li>直接检查每个元组</li>
<li><code>Background Vacuuming</code>：周期性地扫描数据表，由额外的线程池完成</li>
<li><code>Cooperative Cleaning</code>：在事务查找最新的可见版本时，进行清理。由事务线程完成，只能用于<code>O2N</code></li>
</ul>
</li>
<li><code>Transaction-Level</code>
<ul>
<li>事务记录了数据修改前的版本，因此可以通过事务查找这些过期版本</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>Index Management</code>
<ul>
<li><code>Primary Key Indexes</code>：总是指向<code>Version Chain Header</code></li>
<li><code>Secondary Indexes</code>：更加复杂
<ul>
<li><code>Logical Pointers</code>
<ul>
<li>每个<code>Tuple</code>需要维护一个固定的标识符（不同版本中，该标识符保持一致）</li>
<li>需要一个中间层，来做标识符到物理地址的转换（物理地址指向<code>Version Chain Header</code>）</li>
<li>标识符可以是<code>Primary Key</code>或者<code>Tuple Id</code></li>
</ul>
</li>
<li><code>Physical Pointers</code>
<ul>
<li>维护一个指向<code>Version Chain Header</code>的指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><code>MVCC Indexes</code></strong></p>
<ul>
<li><code>MVCC DBMS</code>通常不在索引上直接存储版本信息</li>
<li>索引需要支持<code>Duplicate Key</code>，同一个<code>Key</code>可能指向不同的<code>Logical Tuple Snapshot</code></li>
<li><strong>示意图参考课件中的<code>87 ~ 93</code>页</strong></li>
</ul>
<h1 id="4-mvcc2"><a class="markdownIt-Anchor" href="#4-mvcc2"></a> 4 mvcc2</h1>
<h2 id="41-microsoft-hekaton-sql-server"><a class="markdownIt-Anchor" href="#41-microsoft-hekaton-sql-server"></a> 4.1 Microsoft Hekaton (SQL Server)</h2>
<p><strong><code>Hekaton MVCC</code>：</strong></p>
<ul>
<li>记录的每个版本都维护了两个时间戳
<ul>
<li><code>BEGIN-TS</code>：活跃事务的<code>BeginTS</code>，或者是已提交事务的<code>CommitTS</code></li>
<li><code>END-TS</code>：<code>Infinity</code>，或者是已提交事务的<code>CommitTS</code></li>
<li><strong>示意图参考课件中的<code>6 ~ 24</code>页</strong></li>
</ul>
</li>
<li>维护了一个全局的<code>Transaction state map</code>
<ul>
<li><code>ACTIVE</code>：事务进行中</li>
<li><code>VALIDATING</code>：事务触发了<code>Commit</code>，且<code>DBMS</code>正在校验合法性</li>
<li><code>COMMITTED</code>：事务已经结束，但是尚未修改由该事务创建的所有版本的时间戳</li>
<li><code>TERMINATED</code>：事务已经结束，且已经修改由该事务创建的所有版本的时间戳</li>
</ul>
</li>
<li><img src="/images/CMU-15-721/4-1.png" alt="4-1" /></li>
<li>只使用<code>Lock-Free</code>的数据结构
<ul>
<li>唯一的串行点是时间戳的分配</li>
</ul>
</li>
</ul>
<h2 id="42-tum-hyper"><a class="markdownIt-Anchor" href="#42-tum-hyper"></a> 4.2 TUM HyPer</h2>
<p><strong><code>HyPer MVCC</code>：</strong></p>
<ul>
<li><code>Delta Storage</code>以及<code>Column Storage</code>
<ul>
<li>非索引字段可以原地更新</li>
<li>插入、删除操作会更新索引</li>
<li><code>N2O Version Chain</code></li>
<li><code>No Predicate Locks</code>、<code>No Scan Checks</code></li>
</ul>
</li>
<li>通过直接终止那些试图修改未提交记录的事务，来避免写冲突</li>
<li><strong>示意图参考课件中的<code>33 ~ 37</code>页（完全没看懂）</strong></li>
</ul>
<h2 id="43-sap-hana"><a class="markdownIt-Anchor" href="#43-sap-hana"></a> 4.3 SAP HANA</h2>
<p><strong><code>SAP HANA MVCC</code>：</strong></p>
<ul>
<li><code>Time-Travel Storage</code>（<code>N2O</code>）</li>
<li><code>Main Data Table</code>中存储的是最老的版本</li>
<li>每个<code>Tuple</code>维护一个标识位，用于表示<code>Version Space</code>中是否有新版本</li>
<li>维护一个<code>Hash Table</code>，用于映射<code>Record Identifier</code>和<code>Version Chain Header</code></li>
<li><img src="/images/CMU-15-721/4-2.png" alt="4-2" /></li>
</ul>
<h2 id="44-cmu-cicada"><a class="markdownIt-Anchor" href="#44-cmu-cicada"></a> 4.4 CMU Cicada</h2>
<p><strong><code>CMU Cicada MVCC</code>：</strong></p>
<ul>
<li><code>In-Memory DBMS</code></li>
<li><code>Append-Only-Storage</code>（<code>N2O</code>）</li>
<li><code>Best-effort Inlining</code>
<ul>
<li><img src="/images/CMU-15-721/4-3.png" alt="4-3" /></li>
</ul>
</li>
</ul>
<h2 id="45-summary"><a class="markdownIt-Anchor" href="#45-summary"></a> 4.5 Summary</h2>
<p><strong><code>MVCC Limitations</code>：</strong></p>
<ul>
<li><code>Computation &amp; Storage Overhead</code>
<ul>
<li>大多数<code>MVCC</code>方案都会使用间接的方式来搜索<code>Version Chain</code>，这会增加<code>CPU Cache Miss</code></li>
<li>需要频繁的垃圾回收，来减小版本搜索的开销</li>
</ul>
</li>
<li><code>Shared Memory Writes</code>
<ul>
<li>大多数<code>MVCC</code>方案将版本信息存储在全局的内存中，而没有考虑局部性（<code>CPU Cache Miss</code>）</li>
</ul>
</li>
<li><code>Timestamp Allocation</code>
<ul>
<li>所有线程访问同一个<code>Counter</code></li>
</ul>
</li>
</ul>
<p><strong><code>OCC LIMITATIONS</code>：</strong></p>
<ul>
<li><code>Frequent Aborts</code>
<ul>
<li>频繁地终止事务，尤其是高并发场景下</li>
</ul>
</li>
<li><code>Extra Reads &amp; Writes</code>
<ul>
<li>事务需要将记录拷贝到私有的空间，来保证可重复度</li>
<li>同时，提交时需要检查读是否满足一致性</li>
</ul>
</li>
<li><code>Index Contention</code></li>
</ul>
<h1 id="5-mvcc3"><a class="markdownIt-Anchor" href="#5-mvcc3"></a> 5 mvcc3</h1>
<h2 id="51-mvcc-deletes"><a class="markdownIt-Anchor" href="#51-mvcc-deletes"></a> 5.1 MVCC Deletes</h2>
<p>当一个<code>Tuple</code>的所有版本都逻辑删除后，<code>DBMS</code>才会对其进行物理删除</p>
<p><strong>如何表示逻辑删除？有如下两种方式：</strong></p>
<ol>
<li><code>Deleted Flag</code>
<ul>
<li>在最新的版本后面增加一个标志位，用于表示逻辑删除</li>
</ul>
</li>
<li><code>Tombstone Tuple</code>
<ul>
<li>创建一个空的物理版本来表示逻辑删除</li>
<li>用一个独立的<code>Pool</code>来存储这些<code>Tombstone Tuple</code>，每个<code>Tombstone Tuple</code>只需要<code>1-bit</code>的存储空间</li>
</ul>
</li>
</ol>
<h2 id="52-garbage-collection"><a class="markdownIt-Anchor" href="#52-garbage-collection"></a> 5.2 Garbage Collection</h2>
<p><strong>设计要点：</strong></p>
<ul>
<li><code>Index Clean-up</code></li>
<li><code>Version Tracking Level</code>
<ul>
<li><code>Tuple-Level</code>
<ul>
<li><code>Background Vacuuming</code></li>
<li><code>Cooperative Cleaning</code></li>
</ul>
</li>
<li><code>Transaction-Level</code></li>
<li><code>Epochs</code></li>
</ul>
</li>
<li><code>Frequency</code>：<code>Trade-off</code>，过于频繁，浪费CPU资源，且降低事务的效率；过于不频繁，浪费存储空间，降低版本查找的效率
<ul>
<li><code>Periodically</code>：定期触发，或者某些指标达到阈值后触发</li>
<li><code>Continuously</code>：将清理过程作为事务处理的一部分</li>
</ul>
</li>
<li><code>Granularity</code>
<ul>
<li><code>Single Version</code>
<ul>
<li>单独追踪每个版本的可见性，单独回收</li>
<li>控制粒度更细，但是开销大</li>
</ul>
</li>
<li><code>Group Version</code>
<ul>
<li>以分组的方式管理版本，且以分组为单位进行回收。每个分组包含多个版本</li>
<li>开销较低，但是会延迟回收（分组中的所有版本都可以回收时，才能回收整个分组）</li>
</ul>
</li>
<li><code>Table</code>（P29，没懂）</li>
</ul>
</li>
<li><code>Comparison Unit</code>
<ul>
<li><code>Timestamp</code>
<ul>
<li>用一个全局最小的时间戳来判断版本是否可以回收</li>
<li>实现简单</li>
</ul>
</li>
<li><code>Interval</code>
<ul>
<li>用区间来判断可见性</li>
<li>实现复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="53-block-compaction"><a class="markdownIt-Anchor" href="#53-block-compaction"></a> 5.3 Block Compaction</h2>
<p><code>DBMS</code>需要将那些未满的块合并成更少的块，以减少内存使用量</p>
<h1 id="6-oltpindexes1"><a class="markdownIt-Anchor" href="#6-oltpindexes1"></a> 6 oltpindexes1</h1>
<h2 id="61-in-memory-t-tree"><a class="markdownIt-Anchor" href="#61-in-memory-t-tree"></a> 6.1 In-Memory T-Tree</h2>
<p><code>B+ Tree</code>是为了提高在速度较低的存储介质上的访问速度。而<code>T-Tree</code>是针对内存数据库的一种替代方案，它基于<code>AVL Tree</code></p>
<p><strong><code>T-Tree</code>的节点包含如下属性</strong></p>
<ul>
<li><code>Data Pointers</code>：指向数据的指针</li>
<li><code>Parent Pointer</code>：指向父节点的指针</li>
<li><code>Left Child Pointer</code>：指向左孩子的指针</li>
<li><code>Right Child Pointer</code>：指向右孩子的指针</li>
<li><code>Max-K</code>：当前节点指向的数据中的最大值。若<code>Key &gt; Max-K</code>，那么<code>Key</code>可能存在于右孩子中</li>
<li><code>Min-K</code>：当前节点指向的数据中的最小值。若<code>Key &lt; Min-K</code>，那么<code>Key</code>可能存在于左孩子中</li>
</ul>
<p><strong>优势：</strong></p>
<ul>
<li>由于其不直接存储节点数据，因此占用内存更少</li>
</ul>
<p><strong>劣势：</strong></p>
<ul>
<li>难以平衡</li>
<li>难以实现并发安全</li>
</ul>
<p><strong>示意图参考课件中的<code>7 ~ 22</code>页</strong></p>
<h2 id="62-latch-free-bw-tree"><a class="markdownIt-Anchor" href="#62-latch-free-bw-tree"></a> 6.2 Latch-Free Bw-Tree</h2>
<p><a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/research/publication/the-bw-tree-a-b-tree-for-new-hardware/">Microsoft-bw-tree</a></p>
<p>A new form of B tree, Bw-tree achieves its very high performance via a latch-free approach that effectively exploits the processor caches of modern multi-core chips.</p>
<h3 id="621-delta-updates"><a class="markdownIt-Anchor" href="#621-delta-updates"></a> 6.2.1 Delta Updates</h3>
<p><strong>更新时，生成对应的<code>Delta</code>，<code>Delta</code>指向原链表头，然后通过<code>CAS</code>操作替换<code>Mapping Table</code>中的指针，使其指向自己。若失败，则终止或重试</strong></p>
<p><img src="/images/CMU-15-721/6-1.png" alt="6-1" /></p>
<p><strong>示意图参考课件中的<code>23 ~ 40</code>页</strong></p>
<h3 id="622-garbage-collection"><a class="markdownIt-Anchor" href="#622-garbage-collection"></a> 6.2.2 Garbage Collection</h3>
<p>我们需要知道何时可以安全地为<code>Latch-Free Index</code>中的已删除节点回收内存</p>
<ul>
<li><code>Reference Counting</code>
<ul>
<li>计数为<code>0</code>时，可以删除</li>
<li>在多核CPU上，并发性能较差。因为递增递减计数器，会导致大量的缓存一致性流量</li>
<li>我们其实并不关心计数器的大小是多少，而只是希望在计数值为<code>0</code>的时候可以进行回收（允许延迟，不必立即回收）</li>
</ul>
</li>
<li><code>Epoch-based Reclamation</code>（没懂）
<ul>
<li>维护一个全局的<code>Epoch Counter</code>，并对其进行周期性地更新
<ul>
<li>跟踪在一个<code>Epoch</code>期间哪些线程进入索引以及它们何时离开</li>
</ul>
</li>
<li>标记删除节点时标记节点的当前<code>Epoch</code>
<ul>
<li>一旦所有线程都离开该<code>Epoch</code>，就可以回收该节点</li>
</ul>
</li>
<li>操作用一个<code>Epoch</code>进行标记
<ul>
<li>每个<code>Epoch</code>都会跟踪属于它的线程以及可以回收的对象</li>
<li>线程在每个操作之前加入一个<code>Epoch</code>，并发布可以为当前<code>Epoch</code>回收的对象（不一定是它加入的那个）</li>
</ul>
</li>
<li><strong>示意图参考课件中的<code>49 ~ 57</code>页</strong></li>
</ul>
</li>
<li><code>Hazard Pointers</code></li>
</ul>
<h3 id="623-structure-modifications"><a class="markdownIt-Anchor" href="#623-structure-modifications"></a> 6.2.3 Structure Modifications</h3>
<p><strong><code>Split Delta Record</code>：</strong></p>
<ul>
<li>标记<code>Page</code>的某个<code>Key Range</code>现在位于另一个<code>Page</code></li>
<li>使用<code>Logical Pointer</code>指向<code>New Page</code></li>
</ul>
<p><strong><code>Separator Delta Record</code>：</strong></p>
<ul>
<li>在修改<code>Page</code>的<code>Parent</code>中记录<code>New Page</code>的搜索范围</li>
</ul>
<p><strong>示意图参考课件中的<code>59 ~ 70</code>页</strong></p>
<h2 id="63-b-tree-optimistic-latching"><a class="markdownIt-Anchor" href="#63-b-tree-optimistic-latching"></a> 6.3 B+ Tree Optimistic Latching</h2>
<p><strong>优化1：<code>Pre-Allocated Delta Records</code></strong></p>
<ul>
<li>在<code>Page</code>中预先分配空间，用于存放<code>Delta</code></li>
</ul>
<p><strong>优化2：<code>Mapping Table Expansion</code></strong></p>
<ul>
<li>最高效的内存数据结构就是数组。但是为每个索引都分配一个完整的数组会比较浪费</li>
<li>使用虚拟内存分配整个数组。仅在访问对应偏移量的时候，才分配对应的物理内存（如何实现？？？）</li>
</ul>
<h1 id="7-oltpindexes2"><a class="markdownIt-Anchor" href="#7-oltpindexes2"></a> 7 oltpindexes2</h1>
<h2 id="71-latches"><a class="markdownIt-Anchor" href="#71-latches"></a> 7.1 Latches</h2>
<p><strong><code>Latch</code>方案的目标：</strong></p>
<ul>
<li>更小的内存占用</li>
<li>执行效率更高（无冲突）</li>
<li>当前线程等待时间过长时，取消调度线程</li>
</ul>
<p><strong><code>Latch</code>的实现方案：</strong></p>
<ul>
<li><code>Test-and-Set Spinlock</code>
<ul>
<li>高效（指令简单）</li>
<li>扩展性差，<code>Cache</code>不友好，<code>OS</code>不优化（在最坏的情况下，可能浪费大量CPU资源）</li>
<li><code>std::atomic&lt;T&gt;</code></li>
</ul>
</li>
<li><code>Blocking OS Mutex</code>
<ul>
<li>使用简单</li>
<li>扩展性差（每个<code>lock</code>/<code>unlock</code>大约花费25ns）</li>
<li><code>std::mutex</code></li>
</ul>
</li>
<li><code>Adaptive Spinlock</code>
<ul>
<li>在用户态自旋一段时间</li>
<li>若在自旋期间无法获取锁，就会让出CPU，并记录到<code>Parking Lot</code>中</li>
<li>线程在进入自旋期间，看下是否有其他线程位于<code>Parking Lot</code>中，若是，择直接将自己挂起，避免无效自旋</li>
<li>苹果的<code>WTF::ParkingLot</code></li>
</ul>
</li>
<li><code>Queue-based Spinlock</code>
<ul>
<li>比<code>Mutex</code>更高效，且具有更好的<code>Cache Locality</code></li>
<li><code>std::atomic&lt;Latch*&gt;</code></li>
</ul>
</li>
<li><code>Reader-Writer Locks</code>
<ul>
<li>允许并发读</li>
<li>需要分别管理<code>Read Queue</code>、<code>Write Queue</code>，以防止饿死</li>
<li>可以基于<code>Spinlock</code>实现</li>
</ul>
</li>
</ul>
<h2 id="72-b-tree"><a class="markdownIt-Anchor" href="#72-b-tree"></a> 7.2 B+ Tree</h2>
<p><strong><code>B+ Tree</code>是一种平衡树，其访问、插入、删除的复杂度都是<code>O(log n)</code></strong></p>
<p><strong>在访问一颗<code>B+ Tree</code>的过程中，需要获取或者释放<code>Latch</code></strong></p>
<ul>
<li>当某个节点的孩子节点都被认为是安全时，可以释放该节点的<code>Latch</code>
<ul>
<li>安全意味着，不会发生<code>Split</code>以及<code>Merge</code>操作</li>
</ul>
</li>
<li><code>Search</code>：从根节点开始，向下重复执行如下过程
<ul>
<li>获取孩子节点的<code>Read Latch</code></li>
<li>释放父节点的<code>Read Latch</code></li>
</ul>
</li>
<li><code>Insert/Delete</code>：从根节点开始，向下重复执行如下过程
<ul>
<li>获取孩子节点的<code>Write Latch</code></li>
<li>若孩子是安全的，那么释放该孩子节点的所有祖先节点的<code>Write Latch</code></li>
</ul>
</li>
<li><strong>示意图参考课件中的<code>35 ~ 49</code>页</strong></li>
</ul>
<p><strong>对于<code>Insert/Delete</code>的访问流程，由于直接沿路径加了<code>Write Latch</code>，这样很容易导致整个流程串行化，一个优化方式是：</strong></p>
<ul>
<li>假设目标的<code>Leaf Node</code>是安全的，先用<code>Read Latch</code>访问，如果在访问路径中发现任何不安全的节点，再退回到上面这个版本</li>
<li><strong>示意图参考课件中的<code>51 ~ 54</code>页</strong></li>
</ul>
<p><strong><code>Versioned Latch</code></strong></p>
<ul>
<li>每个节点维护一个版本信息（<code>Counter</code>）</li>
<li>写操作获取<code>Latch</code>时，会递增该版本信息（释放不会递减）</li>
<li>读操作查看<code>Latch</code>是否可用，但是不获取它，只是记录当时的版本信息。在读操作找到目标叶子节点后，再检查版本信息是否发生过变化。若发生过变化，那么终止或者重试读操作</li>
<li>
<ul>
<li><strong>示意图参考课件中的<code>56 ~ 69</code>页（没看懂）</strong></li>
</ul>
</li>
</ul>
<h2 id="73-trie-index"><a class="markdownIt-Anchor" href="#73-trie-index"></a> 7.3 Trie Index</h2>
<p><code>Trie Index</code>又称为字典树或者前缀树</p>
<ul>
<li>其形状只依赖于<code>Key Space</code>以及其长度</li>
<li>不需要平衡操作</li>
<li>所有操作的复杂度是<code>O(k)</code>，其中<code>k</code>是<code>Key</code>的长度</li>
<li><code>Key</code>是隐式存储的，从根到叶节点的整条路径，表示了某个<code>Key</code></li>
<li><strong>示意图参考课件中的<code>75 ~ 83</code>页</strong></li>
</ul>
<p><strong><code>Radix Tree</code></strong></p>
<ul>
<li>作为唯一孩子节点的每个节点都与其父节点合并</li>
<li>又称为<code>Patricia Tree</code></li>
<li>会产生假阳性（<code>False Positive</code>），所以<code>DBMS</code>需要再次校验<code>Key</code>是否匹配</li>
</ul>
<h3 id="731-judy-array"><a class="markdownIt-Anchor" href="#731-judy-array"></a> 7.3.1 Judy Array</h3>
<p><strong><code>Judy Array</code>是<code>256-Way Radix Tree</code>的变体，是第一种已知的能够实现自适应节点表示的<code>Radix Tree</code>：</strong></p>
<ul>
<li>支持下三种类型：
<ol>
<li><code>Judy1</code>：将<code>Integer Key</code>映射成单个<code>bit, true or false</code></li>
<li><code>JudyL</code>：将<code>Integer Key</code>映射成<code>Integer Value</code></li>
<li><code>JudySL</code>：将<code>Variable-Length Key</code>映射成<code>Integer Value</code></li>
</ol>
</li>
<li>节点的元数据被打包成一个<code>128-bit</code>的<code>Judy Pointers</code>，存储在父节点中
<ul>
<li><code>Node Type</code>
<ul>
<li><code>Linear Node</code>：稀疏
<ul>
<li>分为左右两部分，左边存储排序后的<code>Key</code>，右边存储对应于<code>Key</code>的指向孩子的指针</li>
<li><img src="/images/CMU-15-721/7-1.png" alt="7-1" /></li>
</ul>
</li>
<li><code>Bitmap Node</code>：常规（好像理解的不太对）
<ul>
<li>包含一个长度为256的<code>Bitmap</code>，用于表示某个<code>Key</code>是否存在（<code>Key</code>大小为<code>1-byte</code>，范围是0-255，正好作为<code>Bitmap</code>数组的下标）</li>
<li>每<code>8-bit</code>一组，总共分为32组，可以隐式存储32个<code>Key</code></li>
<li><img src="/images/CMU-15-721/7-2.png" alt="7-2" /></li>
<li><img src="/images/CMU-15-721/7-3.png" alt="7-3" /></li>
</ul>
</li>
<li><code>Uncompressed Node</code>：密集
<ul>
<li>类似于下面要介绍的<code>ART-Node256</code></li>
</ul>
</li>
</ul>
</li>
<li><code>Population Count</code></li>
<li><code>Child Key Prefix / Value</code></li>
<li><code>64-bit Child Pointer</code></li>
</ul>
</li>
</ul>
<h3 id="732-art"><a class="markdownIt-Anchor" href="#732-art"></a> 7.3.2 ART</h3>
<p><strong><code>Adapative Radix Tree, ART</code></strong></p>
<ul>
<li><a href="/resources/The-Adaptive-Radix-Tree-ARTful-Indexing-for-Main-Memory-Databases.pdf">ART-Paper</a></li>
<li>被应用于<code>TUM HyPer DBMS</code></li>
<li><code>256-Way Radix Tree</code>，基于分布，支持不同的节点类型</li>
<li>每个节点的元数据存储在其<code>Header</code>中</li>
</ul>
<p><strong><code>ART vs. Judy</code></strong></p>
<ul>
<li><code>Judy</code>有3中不同的节点类型。<code>ART</code>有4种不同的的节点类型（基于孩子的数量）</li>
<li><code>Judy</code>是一个通用的关联数组。它拥有键和值。<code>ART</code>是表索引，不需要覆盖完整的键，其值是指向元组的指针</li>
</ul>
<p><strong><code>ART</code>的节点类型：</strong></p>
<ul>
<li><code>Node4</code>
<ul>
<li><code>Node4</code>包含两个最大长度为4的数组，一个数组用于存储<code>Key</code>（<code>1-byte</code>），另一个用于存储<code>Pointer</code>（<code>8-byte</code>）。<code>Key</code>和<code>Pointer</code>一一对应。总大小是<code>1byte * 4 + 8byte * 4 = 36 byte</code></li>
<li><img src="/images/CMU-15-721/7-4.png" alt="7-4" /></li>
</ul>
</li>
<li><code>Node16</code>
<ul>
<li><code>Node16</code>，其结构与<code>Node4</code>类似，包含两个最大长度为8的数组，一个数组用于存储<code>Key</code>（<code>1-byte</code>），另一个用于存储<code>Pointer</code>（<code>8-byte</code>）。<code>Key</code>和<code>Pointer</code>一一对应。总大小是<code>1byte * 16 + 8byte * 16 = 144 byte</code></li>
<li>搜索时，可以采用二分查找，或者直接利用<code>SIMD</code>指令</li>
<li><img src="/images/CMU-15-721/7-5.png" alt="7-5" /></li>
</ul>
</li>
<li><code>Node48</code>
<ul>
<li><code>Node48</code>结构上和<code>Node4</code>、<code>Node16</code>有所不同，包含两个长度不同的数组，一个数组长度是256，每个元素<code>1-byte</code>，另一个数组长度48，每个元素<code>8-byte</code>，用于存储<code>Pointer</code>。总大小是<code>1byte * 256 + 8byte * 48 = 640 byte</code>
<ul>
<li>该结构隐式存储了48个<code>Key</code>。由于<code>Key</code>的大小是<code>1-byte</code>，其数值刚好是<code>0-255</code>，正好作为第一个数组的下标，第一个数组中存储的值，同时作为第二个数组的下标（由于第二个数组的长度是48，因此<code>1-byte</code>完全可以表示）</li>
</ul>
</li>
<li><img src="/images/CMU-15-721/7-6.png" alt="7-6" /></li>
</ul>
</li>
<li><code>Node256</code>
<ul>
<li><code>Node256</code>只有一个长度为256的数组，用于存储<code>Pointer</code>（<code>8-byte</code>）。总大小是<code>8byte * 256 = 2048 byte</code>
<ul>
<li>该结构同样隐式存储了256个<code>Key</code>，由于<code>Key</code>的大小是<code>1-byte</code>，其数值刚好是<code>0-255</code>，正好作为数组的下标</li>
<li>正因为<code>Node48</code>的<code>Pointer</code>数组只有48个元素，无法用<code>Key Byte</code>直接索引，于是才引入了一个长度为<code>256</code>，大小为<code>1-byte</code>的数组，充当第一级索引</li>
</ul>
</li>
<li><img src="/images/CMU-15-721/7-7.png" alt="7-7" /></li>
</ul>
</li>
</ul>
<h3 id="733-masstree"><a class="markdownIt-Anchor" href="#733-masstree"></a> 7.3.3 Masstree</h3>
<p><code>Masstree</code>的每个节点都是一颗<code>B+ Tree</code></p>
<p><img src="/images/CMU-15-721/7-8.png" alt="7-8" /></p>
<h1 id="8-storage"><a class="markdownIt-Anchor" href="#8-storage"></a> 8 storage</h1>
<h2 id="81-type-representation"><a class="markdownIt-Anchor" href="#81-type-representation"></a> 8.1 Type Representation</h2>
<ul>
<li><code>int/bigint/smallint/tinyint</code>：直接用<code>C++</code>基本类型表示</li>
<li><code>float/real/numeric</code>：IEEE-754 Standard
<ul>
<li>可变精度，存在精度损失</li>
<li>计算效率高</li>
</ul>
</li>
<li><code>decimal</code>：Fixed-point Decimals</li>
<li><code>time/date/timestamp</code>：<code>32/64-bit int</code></li>
<li><code>varchar/varbinary/text/blob</code>
<ul>
<li>指针</li>
<li>包含当前长度和下一个位置的指针的<code>Header</code></li>
</ul>
</li>
</ul>
<h2 id="82-data-layout-alignment"><a class="markdownIt-Anchor" href="#82-data-layout-alignment"></a> 8.2 Data Layout / Alignment</h2>
<p>以字对齐（<code>Word-Aligned</code>）的方式存储，能够显著提高吞吐率</p>
<ul>
<li><code>No Alignment</code>
<ul>
<li><img src="/images/CMU-15-721/8-1.png" alt="8-1" /></li>
</ul>
</li>
<li><code>Alignment With Padding</code>
<ul>
<li><img src="/images/CMU-15-721/8-2.png" alt="8-2" /></li>
</ul>
</li>
<li><code>Alignment With Padding + Sorting</code>
<ul>
<li><img src="/images/CMU-15-721/8-3.png" alt="8-3" /></li>
</ul>
</li>
</ul>
<h2 id="83-storage-models"><a class="markdownIt-Anchor" href="#83-storage-models"></a> 8.3 Storage Models</h2>
<p><strong><code>N-ary Storage Model, NSM</code>：</strong></p>
<ul>
<li>连续存储单个<code>Tuple</code>的所有属性</li>
<li><code>OLTP</code>的理想存储模型，因为<code>OLTP</code>通常读写单个<code>Tuple</code>，且经常会有批量插入操作</li>
<li>使用<code>tuple-at-a-time</code>的迭代模型</li>
<li>优势：
<ul>
<li>插入、删除、更新操作快</li>
<li>对于需要获取<code>Tuple</code>所有属性的查询更友好</li>
<li>可以使用面向索引的存储</li>
</ul>
</li>
<li>劣势：
<ul>
<li>对于扫描全表的操作不友好</li>
<li>对于需要获取<code>Tuple</code>部分属性的查询不友好</li>
</ul>
</li>
</ul>
<p><strong><code>Decomposition Storage Model, DSM</code>：</strong></p>
<ul>
<li>单独存储<code>Tuple</code>的每个属性</li>
<li><code>OLAP</code>的理想存储模型，因为<code>OLTP</code>通常会对某几个属性进行大范围或全表扫描</li>
<li>优势：
<ul>
<li>无需读取不需要的属性</li>
<li>更好的压缩性能</li>
</ul>
</li>
<li>劣势：
<ul>
<li>插入、删除、更新、点查较慢</li>
</ul>
</li>
<li><code>Tuple Identification</code>
<ul>
<li><code>Fixed-length Offsets</code>：<code>Tuple</code>中的每个属性的偏移量都是相同的</li>
<li><code>Embedded Tuple Ids</code>：<code>Tuple</code>中的每个属性额外存储其<code>Tuple Id</code></li>
<li><img src="/images/CMU-15-721/8-4.png" alt="8-4" /></li>
</ul>
</li>
<li><code>Data Organization</code>
<ul>
<li><code>Insertion Order</code></li>
<li><code>Sorted Order</code></li>
<li><code>Partitioned</code></li>
</ul>
</li>
</ul>
<p><strong><code>Hybrid Storage Model</code>：</strong></p>
<ul>
<li><code>Hot Data vs. Cold Data</code>
<ul>
<li>数据插入后，有很大概率会被再次更新</li>
<li>经过一段时间后，数据大概率只会被读取</li>
</ul>
</li>
<li><code>Execution Engine</code>
<ul>
<li><code>Separate Execution Engines</code>：针对<code>NSM</code>以及<code>DSM</code>两种存储模型，使用两个独立的<code>Execution Engine</code>
<ul>
<li>需要合并来自两个引擎的结果</li>
<li>需要事务跨两个引擎，那需要使用<code>2PC</code></li>
<li>实现方式有2种
<ul>
<li><code>Fractured Mirrors</code>：Oracle, IBM
<ul>
<li><img src="/images/CMU-15-721/8-5.png" alt="8-5" /></li>
</ul>
</li>
<li><code>Delta Store</code>：SAP HANA
<ul>
<li><img src="/images/CMU-15-721/8-6.png" alt="8-6" /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>Single, Flexible Architecture</code>：使用一个能够兼容处理<code>NSM</code>以及<code>DSM</code>两种存储模型的<code>Execution Engine</code>
<ul>
<li>不需要存储数据库的两个副本</li>
<li>不需要同步<code>Database Segments</code></li>
<li>实现方式
<ul>
<li><code>Peloton Ataptive Storage</code>
<ul>
<li><img src="/images/CMU-15-721/8-7.png" alt="8-7" /></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="84-system-catalogs"><a class="markdownIt-Anchor" href="#84-system-catalogs"></a> 8.4 System Catalogs</h2>
<p>几乎所有的<code>DBMS</code>以存储普通数据的方式存储<code>Cagalogs</code>。但由于<code>Catalogs</code>的特殊性，需要有专门的引导代码。<code>DDL</code>同样需要保证<code>ACID</code></p>
<p><strong><code>Schema Change</code>：</strong></p>
<ul>
<li><code>Add Columns</code>
<ul>
<li><code>NSM</code>：将元组复制到新区域</li>
<li><code>DSM</code>：只需创建新的列</li>
</ul>
</li>
<li><code>Drop Columns</code>
<ul>
<li><code>NSM</code>：
<ol>
<li>将元组复制到新区域</li>
<li>标记为删除，后面再清理</li>
</ol>
</li>
<li><code>DSM</code>：只需删除列</li>
</ul>
</li>
<li><code>Change Columns</code></li>
</ul>
<p><strong><code>Indexes</code>：</strong></p>
<ul>
<li><code>Create Index</code>
<ul>
<li>扫描全表，并填充索引</li>
<li>记录在扫描期间，由其他事务引起的变更</li>
<li>扫描结束后，锁表，将扫描期间记录的变更更新到索引上</li>
</ul>
</li>
<li><code>Drop Index</code>
<ul>
<li>逻辑删除索引</li>
<li>仅当删除索引的事务提交时，它才会变得不可见。在此之前，所有活跃的事务仍然需要更新它</li>
</ul>
</li>
</ul>
<h2 id="85-小结"><a class="markdownIt-Anchor" href="#85-小结"></a> 8.5 小结</h2>
<p><strong><code>Hybrid Storage Model</code>已被抛弃，原因如下：</strong></p>
<ul>
<li>工程实现的难度太大</li>
<li><code>Delta Version Storage + Column Store</code>与之等价</li>
<li><code>Catalog</code>实现难度大</li>
</ul>
<h1 id="9-compression"><a class="markdownIt-Anchor" href="#9-compression"></a> 9 compression</h1>
<h2 id="91-compression-background"><a class="markdownIt-Anchor" href="#91-compression-background"></a> 9.1 Compression Background</h2>
<ul>
<li><code>I/O</code>是<code>DBMS</code>的瓶颈之一，它需要权衡速度与压缩率</li>
<li>在现实场景中，数据倾斜普遍存在</li>
<li>同一个数据表中的不同列，存在很大的数据相关性</li>
</ul>
<p><strong><code>Compression</code>的目标：</strong></p>
<ul>
<li>产生定长的输出</li>
<li>尽可能地推迟解压缩的时机，这样可以使得处理的数据尽可能的小。也称为延迟物化（<code>Late Meterialization</code>）</li>
<li>无损压缩</li>
</ul>
<p><strong><code>Data Skipping</code>：</strong></p>
<ul>
<li><code>Approximate Queries</code>：仅查询采样数据级，来产生近似的结果</li>
<li><code>Zone Map</code>：提前计算每个数据块的元数据，比如最大值、最小值等。这样在查询的时候，可以检查这些元数据来决定是否跳过当前块</li>
</ul>
<p><strong><code>Compression Granularity</code>：</strong></p>
<ul>
<li><code>Block-Level</code></li>
<li><code>Tuple-Level</code>
<ul>
<li>仅适用于<code>NSM</code></li>
</ul>
</li>
<li><code>Attribute-Level</code></li>
<li><code>Column-Level</code>
<ul>
<li>仅适用于<code>DSM</code></li>
</ul>
</li>
</ul>
<h2 id="92-naive-compression"><a class="markdownIt-Anchor" href="#92-naive-compression"></a> 9.2 Naive Compression</h2>
<p><strong><code>Naive Compression</code>即采用一种通用算法对数据进行压缩，常用的算法包括：</strong></p>
<ul>
<li>LZO（1996）</li>
<li>LZ4（2011）</li>
<li>Snappy（2011）</li>
<li>Brotli（2013）</li>
<li>Oracle OZIP（2014）</li>
<li>Zstd（2015）</li>
</ul>
<p><strong>在这种方案下：</strong></p>
<ul>
<li><code>DBMS</code>必须先对数据进行解压缩，然后才能对其进行读写操作</li>
<li>不考虑数据的高级含义以及语义</li>
<li>相等性比较可以在压缩的状态下进行（前提是，数据以相同的方式压缩）
<ul>
<li><img src="/images/CMU-15-721/9-1.png" alt="9-1" /></li>
</ul>
</li>
</ul>
<h2 id="93-olap-columnar-compression"><a class="markdownIt-Anchor" href="#93-olap-columnar-compression"></a> 9.3 OLAP Columnar Compression</h2>
<p><strong>常用的<code>Columnar Compression</code>算法如下：</strong></p>
<ul>
<li><code>Null Supression</code>
<ul>
<li>对连续的零值、空值或者空白进行压缩，将其替换成出现位置以及数量的描述信息（类似于游程编码）</li>
<li>适用于数据稀疏的场景</li>
</ul>
</li>
<li><code>Run-length Encoding</code>
<ul>
<li>将连续相同的值编码成一个三元组，即值，起始偏移量，长度</li>
<li><img src="/images/CMU-15-721/9-2.png" alt="9-2" /></li>
</ul>
</li>
<li><code>Bitmap Encoding</code>
<ul>
<li>额外存储一个<code>Bitmap</code>用于映射属性的每个值</li>
<li>仅适用于基数较低的场景</li>
<li><img src="/images/CMU-15-721/9-3.png" alt="9-3" /></li>
<li>上述<code>Bitmap</code>存在两种压缩方式
<ul>
<li><code>General Purpose Compression</code>
<ul>
<li>例如<code>LZ4</code>、<code>Snappy</code></li>
<li>必须解码后才能进行数据处理</li>
<li>对内存数据库不友好</li>
</ul>
</li>
<li><code>Oracle Byte-Aligned Bitmap Codes</code>
<ul>
<li>对<code>Bitmap</code>进行分类
<ul>
<li><code>Gap Byte</code>：所有<code>bit</code>都是<code>0</code></li>
<li><code>Tail Byte</code>：部分<code>bit</code>是<code>1</code></li>
</ul>
</li>
<li>对包含<code>Gap Bytes</code>以及<code>Tail Bytes</code>的数据进行压缩
<ul>
<li><code>Gap Byte</code>使用<code>RLE</code>进行压缩</li>
<li><code>Tail Bytes</code>
<ul>
<li>若仅包含<code>1</code>，或者只有一个<code>1</code>的情况，进行压缩</li>
<li>否则不压缩，直接存储</li>
</ul>
</li>
</ul>
</li>
<li><strong>示意图参考课件中的<code>31 ~ 40</code>页</strong></li>
<li><strong>这种方式已被淘汰。虽然它提供了很好的压缩性能，但是效率较低。<code>Word-Aligned Hybrid, WAH</code>作为一种替代方案，提供了更好的性能</strong>
<ul>
<li>这两种方式都不支持随机访问</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>Delta Encoding</code>
<ul>
<li>存储的不是值本身，而是变化</li>
<li>配合<code>RLE</code>可以达到更好的压缩效果</li>
<li><img src="/images/CMU-15-721/9-4.png" alt="9-4" /></li>
</ul>
</li>
<li><code>Incremental Encoding</code>
<ul>
<li>类似于<code>Delta Encoding</code>的思路，<code>Incremental Encoding</code>避免存储相同的前缀</li>
<li>在数据有序时，压缩效率更高</li>
<li><img src="/images/CMU-15-721/9-5.png" alt="9-5" /></li>
</ul>
</li>
<li><code>Mostly Encoding</code>
<ul>
<li>当大部分数据小于该类型的最大值时，可以用更小的类型来存储。剩下无法用更小类型存储的数据还是保留原先的类型</li>
<li><img src="/images/CMU-15-721/9-6.png" alt="9-6" /></li>
</ul>
</li>
<li><code>Dictionary Encoding</code>
<ul>
<li>何时构建字典
<ul>
<li><code>All At Once</code>
<ul>
<li>扫描所有数据，构建字典</li>
<li>对于新插入的数据，使用额外的字典，或者重新计算</li>
</ul>
</li>
<li><code>Incremental</code>
<ul>
<li>将新插入的数据合并到已有的字典中</li>
</ul>
</li>
</ul>
</li>
<li><code>Scope</code>
<ul>
<li><code>Block-Level</code>
<ul>
<li>仅包含一个数据表中的部分数据</li>
<li>压缩率较低，更新效率高</li>
</ul>
</li>
<li><code>Table-Level</code>
<ul>
<li>压缩率较高，更新效率低</li>
</ul>
</li>
<li><code>Multi-Level</code>
<ul>
<li>可能包含多个表的部分数据或者全量数据</li>
<li>有时用于<code>Join</code>操作</li>
</ul>
</li>
</ul>
</li>
<li><code>Multi-Aggribute Encoding</code>
<ul>
<li>字典可以横跨多个属性</li>
<li><img src="/images/CMU-15-721/9-7.png" alt="9-7" /></li>
</ul>
</li>
<li><code>Order-Preserving Encoding</code>
<ul>
<li>编码后的值要保持与原有值相同的顺序</li>
<li><img src="/images/CMU-15-721/9-8.png" alt="9-8" /></li>
<li><img src="/images/CMU-15-721/9-9.png" alt="9-9" /></li>
</ul>
</li>
<li><code>Dictionary Data Structures</code>
<ul>
<li><code>Array</code>
<ul>
<li>两个数组，一个数组包含变长的数据，另一个数组存储数据的偏移量</li>
<li>更新成本高</li>
</ul>
</li>
<li><code>Hash Table</code>
<ul>
<li>快速，紧凑</li>
<li>不支持范围、前缀查找</li>
</ul>
</li>
<li><code>B+ Tree</code>
<ul>
<li>比<code>Hash Table</code>慢，且需要更多内存</li>
<li>支持范围、前缀查找</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="94-oltp-index-compression"><a class="markdownIt-Anchor" href="#94-oltp-index-compression"></a> 9.4 OLTP Index Compression</h2>
<p><code>OLTP</code>无法使用<code>OLAP</code>的压缩技术，因为它需要支持<code>Tuple</code>的快速随机访问。即时进行压缩、解压缩操作会大大降低性能。同时，<code>OLTP</code>中的索引会占用很多内存资源</p>
<h1 id="10-recovery"><a class="markdownIt-Anchor" href="#10-recovery"></a> 10 recovery</h1>
<p><strong><code>Recovery</code>用于在发生故障时，确保数据库的原子性、一致性和持久性。它包含两个部分：</strong></p>
<ul>
<li>在事务正常进行时所执行的一系列操作（写<code>WAL</code>日志），来确保<code>DBMS</code>能从故障中恢复</li>
<li>在<code>DBMS</code>进入异常状态时锁执行的一系列恢复操作，用于保证数据库的原子性、一致性和持久性</li>
</ul>
<p><strong>异常在数据库中是非常常见的，它不光指机器崩溃，还可能是如下场景：</strong></p>
<ul>
<li><code>OS</code>更新</li>
<li>硬件更新</li>
<li><code>DBMS</code>更新</li>
</ul>
<h2 id="101-logging-schemes"><a class="markdownIt-Anchor" href="#101-logging-schemes"></a> 10.1 Logging Schemes</h2>
<p><strong>日志方案：</strong></p>
<ul>
<li><code>Physical Logging</code>
<ul>
<li>直接记录更新的值</li>
</ul>
</li>
<li><code>Logical Logging</code>
<ul>
<li>记录的是高层级的操作，比如<code>UPDATE</code>、<code>DELETE</code>、<code>INSERT</code>等</li>
</ul>
</li>
</ul>
<p><strong>刷新方式：</strong></p>
<ul>
<li><code>All-at-Once Flushing</code>
<ul>
<li>直到事务提交之前，才将日志刷到磁盘</li>
</ul>
</li>
<li><code>Incremental Flushing</code>
<ul>
<li>允许在事务提交之前，将日志刷到磁盘</li>
</ul>
</li>
</ul>
<p><strong><code>Early Lock Release</code>：在事务的<code>Commit Log</code>刷入磁盘后，事务的锁便可以释放了，无需等到将结果传回客户端。因为从<code>DBMS</code>的视角来看，此时事务已经结束了</strong></p>
<p><strong><code>MSSQL Constant Time Recovery</code>：属于<code>Physical Logging</code>，且直接将<code>MVCC</code>的<code>Time-Travel</code>表作为<code>Recovery Log</code>。因此无需再打印<code>WAL</code></strong></p>
<ul>
<li><strong>详细内容参考课件中的<code>12 ~ 21</code>页</strong></li>
</ul>
<p><strong><code>SILO</code>，详细内容参考课件中的<code>22 ~ 40</code>页</strong></p>
<h2 id="102-checkpoint-protocols"><a class="markdownIt-Anchor" href="#102-checkpoint-protocols"></a> 10.2 Checkpoint Protocols</h2>
<p><strong>理想的<code>Checkpoint</code>应该具备以下特性：</strong></p>
<ul>
<li>不能影响正常事务的处理效率</li>
<li>不能引入较大的延迟</li>
<li>内存开销要小</li>
</ul>
<p><strong><code>Consistent vs. Fuzzy Checkpoints</code></strong></p>
<ul>
<li><code>Consistent Checkpoints</code>
<ul>
<li>表示数据库在某个时间点的一致性快照。不包含未提交的更改</li>
<li>恢复时，无其他额外操作</li>
</ul>
</li>
<li><code>Fuzzy Checkpoints</code>
<ul>
<li>会包含<code>Checkpoint</code>启动后才提交的事务的更改</li>
<li>需要确保<code>Checkpoint</code>包含上述已提交事务的更改</li>
</ul>
</li>
</ul>
<p><strong><code>Checkpoint Mechanism</code></strong></p>
<ul>
<li><code>Do It Yourself</code>
<ul>
<li>同一个进程完成，可以利用<code>MVCC</code>来确定快照</li>
</ul>
</li>
<li><code>OS Fork Snapshots</code>
<ul>
<li><code>Fork</code>一个子进程，拷贝父进程的内存，因此子进程的内存中包含快照所需的所有内容</li>
<li>需要额外的操作来除去那些未提交的记录（利用Undo Log）</li>
</ul>
</li>
</ul>
<p><strong><code>Checkpoint Contents</code></strong></p>
<ul>
<li><code>Complete Checkpoint</code>
<ul>
<li>包含所有数据，包括从上个<code>Checkpoint</code>以来未发生改变的<code>Tuple</code></li>
</ul>
</li>
<li><code>Delta Checkpoint</code>
<ul>
<li>仅包含从上个<code>Checkpoint</code>以来发生改变的<code>Tuple</code></li>
<li>在后台可以对多个<code>Checkpoint</code>进行合并</li>
</ul>
</li>
</ul>
<p><strong><code>Frequency</code></strong></p>
<ul>
<li><code>Time-based</code></li>
<li><code>Log File Size Threshold</code></li>
<li><code>On Shutdown</code></li>
</ul>
<p><img src="/images/CMU-15-721/10-1.png" alt="10-1" /></p>
<h2 id="103-restart-protocols"><a class="markdownIt-Anchor" href="#103-restart-protocols"></a> 10.3 Restart Protocols</h2>
<p><strong><code>Shared Memory Restarts</code>：</strong></p>
<ul>
<li><code>Shared Memory Heaps</code></li>
<li><code>Copy On Shutdown</code></li>
</ul>
<h1 id="11-networking"><a class="markdownIt-Anchor" href="#11-networking"></a> 11 networking</h1>
<p><img src="/images/CMU-15-721/11-1.png" alt="11-1" /></p>
<h2 id="111-database-access-apis"><a class="markdownIt-Anchor" href="#111-database-access-apis"></a> 11.1 Database Access APIs</h2>
<p>常见的<code>API</code>有如下几种：</p>
<ul>
<li><code>Direct Access, DBMS-Specific</code></li>
<li><code>Open Database Connectivity, ODBC</code>
<ul>
<li>与<code>OS</code>和具体的<code>DBMS</code>解耦，几乎每种主流的<code>DBMS</code>都会有<code>ODBC</code>的实现</li>
<li><code>ODBC</code>的设计采用了<code>Device Driver</code>的模型，其中<code>Driver</code>封装了将标准<code>Standard-API</code>转换成<code>DBMS-Specific-API</code>的逻辑</li>
<li><img src="/images/CMU-15-721/11-2.png" alt="11-2" /></li>
</ul>
</li>
<li><code>Java Database Connectivity, JDBC</code>
<ul>
<li>可以理解成是<code>ODBC</code>的一个版本，只不过针对的是<code>Java</code>语言而不是<code>C</code>语言</li>
</ul>
</li>
</ul>
<h2 id="112-database-network-protocols"><a class="markdownIt-Anchor" href="#112-database-network-protocols"></a> 11.2 Database Network Protocols</h2>
<p><strong>几乎所有主流的<code>DBMS</code>都基于<code>TCP/IP</code>实现了一套通信协议，标准的<code>C/S</code>交互流程如下：</strong></p>
<ul>
<li><code>Client</code>连接到<code>DBMS</code>，进行鉴权流程</li>
<li><code>Client</code>发送一个<code>Query</code></li>
<li><code>DMBS</code>解析并执行<code>Query</code>，然后将结果序列化后返回给<code>Client</code></li>
</ul>
<p><strong>协议设计要点：</strong></p>
<ul>
<li><code>Row vs. Column Layout</code>
<ul>
<li><code>ODBC</code>和<code>JDBC</code>是典型的<code>Row-Oriented</code></li>
</ul>
</li>
<li><code>Compression</code>
<ul>
<li><code>Naive Compression</code></li>
<li><code>Columnar-Specific Encoding</code></li>
</ul>
</li>
<li><code>Data Serialization</code>
<ul>
<li><code>Binary Encoding</code>
<ul>
<li>客户端需要进行额外的字节序列的转换</li>
<li>序列化后体积小</li>
<li>可以基于现有的框架来实现，比如<code>ProtoBuffers</code>、<code>Thrift</code>、<code>FlatBuffers</code>等</li>
</ul>
</li>
<li><code>Text Encoding</code>
<ul>
<li>将所有类型都转换成<code>String</code></li>
<li>序列化后体积大</li>
<li>客户端反序列化简单</li>
</ul>
</li>
</ul>
</li>
<li><code>String handling</code>
<ul>
<li><code>Null Termination</code>：在末尾加<code>\0</code>，表示<code>String</code>的结束</li>
<li><code>Length-Prefixes</code>：在<code>Header</code>中增加长度信息</li>
<li><code>Fixed Width</code>：所有<code>String</code>长度固定，不足需要补白</li>
</ul>
</li>
</ul>
<h2 id="113-replication-protocols"><a class="markdownIt-Anchor" href="#113-replication-protocols"></a> 11.3 Replication Protocols</h2>
<p><code>DBMS</code>会通过网络同步各个节点之间的数据，用以提升集群的可用性</p>
<p><strong>设计要点：</strong></p>
<ul>
<li><code>Replica Configuration</code>
<ul>
<li><code>Master-Replica</code>
<ul>
<li>所有更新必须经过<code>Master</code>节点</li>
<li><code>Master</code>节点会将更新同步给其他<code>Replica</code>节点</li>
<li><code>Read-Only</code>的事务可以访问<code>Replica</code>节点</li>
<li><code>Master</code>如果宕机了，那么会重新选举出一个<code>Master</code></li>
</ul>
</li>
<li><code>Multi-Master</code>
<ul>
<li>所有节点均支持数据更新</li>
<li>节点之间的数据同步需要使用<code>Atomic Commit Protocol</code></li>
</ul>
</li>
<li><img src="/images/CMU-15-721/11-3.png" alt="11-3" /></li>
</ul>
</li>
<li><code>Propagation Scheme</code>：当事务提交时，<code>DBMS</code>需要决定是否需要等到该事务的变更都同步到其他节点后，才通知客户端事务已完成
<ul>
<li><code>Synchronous</code>：强一致性</li>
<li><code>Asynchronous</code>：最终一致性</li>
<li><img src="/images/CMU-15-721/11-4.png" alt="11-4" /></li>
</ul>
</li>
</ul>
<h2 id="114-kernel-bypass-methods"><a class="markdownIt-Anchor" href="#114-kernel-bypass-methods"></a> 11.4 Kernel Bypass Methods</h2>
<p><strong>网络通信协议的实现并不是降低系统效率的唯一原因。<code>TCP/IP</code>协议栈本身也是原因之一，比如：</strong></p>
<ul>
<li>上下文切换、中断的开销</li>
<li>数据拷贝（内核空间和内核空间）</li>
<li>内核中大量的<code>Latches</code></li>
</ul>
<p><strong><code>Kernel Bypass Methods</code>允许<code>DBMS</code>直接从<code>Network Interface Card, NIC</code>中获取数据</strong></p>
<ul>
<li>没有数据拷贝</li>
<li>没有<code>TCP/IP</code>协议栈</li>
</ul>
<p><strong><code>Kernel Bypass Methods</code>的实现方式有如下两种：</strong></p>
<ul>
<li><code>Data Plane Development Kit</code></li>
<li><code>Remote Direct Memory Access</code>
<ul>
<li>直接读写远程主机的内存，必须知道正确的地址</li>
<li><code>DBMS</code>本身不感知这个过程</li>
</ul>
</li>
</ul>
<h1 id="12-scheduling"><a class="markdownIt-Anchor" href="#12-scheduling"></a> 12 scheduling</h1>
<h1 id="13-execution"><a class="markdownIt-Anchor" href="#13-execution"></a> 13 execution</h1>
<h1 id="14-compilation"><a class="markdownIt-Anchor" href="#14-compilation"></a> 14 compilation</h1>
<h1 id="15-vectorization1"><a class="markdownIt-Anchor" href="#15-vectorization1"></a> 15 vectorization1</h1>
<h1 id="16-vectorization2"><a class="markdownIt-Anchor" href="#16-vectorization2"></a> 16 vectorization2</h1>
<h1 id="17-hashjoins"><a class="markdownIt-Anchor" href="#17-hashjoins"></a> 17 hashjoins</h1>
<h1 id="18-sortmergejoins"><a class="markdownIt-Anchor" href="#18-sortmergejoins"></a> 18 sortmergejoins</h1>
<h1 id="19-optimizer1"><a class="markdownIt-Anchor" href="#19-optimizer1"></a> 19 optimizer1</h1>
<h1 id="20-optimizer2"><a class="markdownIt-Anchor" href="#20-optimizer2"></a> 20 optimizer2</h1>
<h1 id="21-optimizer3"><a class="markdownIt-Anchor" href="#21-optimizer3"></a> 21 optimizer3</h1>
<h1 id="22-costmodels"><a class="markdownIt-Anchor" href="#22-costmodels"></a> 22 costmodels</h1>
<h1 id="23-largerthanmemory"><a class="markdownIt-Anchor" href="#23-largerthanmemory"></a> 23 largerthanmemory</h1>
<h1 id="24-udfs"><a class="markdownIt-Anchor" href="#24-udfs"></a> 24 udfs</h1>
<h1 id="25-hardware"><a class="markdownIt-Anchor" href="#25-hardware"></a> 25 hardware</h1>
<h1 id="26-课件"><a class="markdownIt-Anchor" href="#26-课件"></a> 26 课件</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://15721.courses.cs.cmu.edu/spring2020/slides/">Index of /spring2020/slides</a></li>
</ul>
<ol>
<li><a href="/resources/CMU-15-721/01-history.pdf">01-history</a></li>
<li><a href="/resources/CMU-15-721/02-inmemory.pdf">02-inmemory</a></li>
<li><a href="/resources/CMU-15-721/03-mvcc1.pdf">03-mvcc1</a></li>
<li><a href="/resources/CMU-15-721/04-mvcc2.pdf">04-mvcc2</a></li>
<li><a href="/resources/CMU-15-721/05-mvcc3.pdf">05-mvcc3</a></li>
<li><a href="/resources/CMU-15-721/06-oltpindexes1.pdf">06-oltpindexes1</a></li>
<li><a href="/resources/CMU-15-721/07-oltpindexes2.pdf">07-oltpindexes2</a></li>
<li><a href="/resources/CMU-15-721/08-storage.pdf">08-storage</a></li>
<li><a href="/resources/CMU-15-721/09-compression.pdf">09-compression</a></li>
<li><a href="/resources/CMU-15-721/10-recovery.pdf">10-recovery</a></li>
<li><a href="/resources/CMU-15-721/11-networking.pdf">11-networking</a></li>
<li><a href="/resources/CMU-15-721/12-scheduling.pdf">12-scheduling</a></li>
<li><a href="/resources/CMU-15-721/13-execution.pdf">13-execution</a></li>
<li><a href="/resources/CMU-15-721/14-compilation.pdf">14-compilation</a></li>
<li><a href="/resources/CMU-15-721/15-vectorization1.pdf">15-vectorization1</a></li>
<li><a href="/resources/CMU-15-721/16-vectorization2.pdf">16-vectorization2</a></li>
<li><a href="/resources/CMU-15-721/17-hashjoins.pdf">17-hashjoins</a></li>
<li><a href="/resources/CMU-15-721/18-sortmergejoins.pdf">18-sortmergejoins</a></li>
<li><a href="/resources/CMU-15-721/19-optimizer1.pdf">19-optimizer1</a></li>
<li><a href="/resources/CMU-15-721/20-optimizer2.pdf">20-optimizer2</a></li>
<li><a href="/resources/CMU-15-721/21-optimizer3.pdf">21-optimizer3</a></li>
<li><a href="/resources/CMU-15-721/22-costmodels.pdf">22-costmodels</a></li>
<li><a href="/resources/CMU-15-721/23-largerthanmemory.pdf">23-largerthanmemory</a></li>
<li><a href="/resources/CMU-15-721/24-udfs.pdf">24-udfs</a></li>
<li><a href="/resources/CMU-15-721/25-hardware.pdf">25-hardware</a></li>
</ol>
<h1 id="27-summary"><a class="markdownIt-Anchor" href="#27-summary"></a> 27 Summary</h1>
<div class="markmap-container" style="height:undefined">
                <svg class="markmap-svg">{"t":"root","d":0,"v":"","c":[{"t":"list_item","d":2,"p":{"lines":[0,1]},"v":"Buffer Pool","c":[{"t":"list_item","d":4,"p":{"lines":[1,2]},"v":"Design Goals","c":[{"t":"list_item","d":6,"p":{"lines":[2,3]},"v":"Accuracy"},{"t":"list_item","d":6,"p":{"lines":[3,4]},"v":"Correctness"},{"t":"list_item","d":6,"p":{"lines":[4,5]},"v":"Efficiency"},{"t":"list_item","d":6,"p":{"lines":[5,6]},"v":"Overhead"}]},{"t":"list_item","d":4,"p":{"lines":[6,7]},"v":"Replacement Policy","c":[{"t":"list_item","d":6,"p":{"lines":[7,8]},"v":"Least-Recently Used"},{"t":"list_item","d":6,"p":{"lines":[8,9]},"v":"Clock"},{"t":"list_item","d":6,"p":{"lines":[9,10]},"v":"LRU-K"},{"t":"list_item","d":6,"p":{"lines":[10,11]},"v":"Localization"},{"t":"list_item","d":6,"p":{"lines":[11,12]},"v":"Priority Hints"}]},{"t":"list_item","d":4,"p":{"lines":[12,13]},"v":"Dirty Pages","c":[{"t":"list_item","d":6,"p":{"lines":[13,14]},"v":"Background Writing"}]}]},{"t":"list_item","d":2,"p":{"lines":[14,15]},"v":"MVCC","c":[{"t":"list_item","d":4,"p":{"lines":[15,16]},"v":"Concurrency Control Protocol","c":[{"t":"list_item","d":6,"p":{"lines":[16,17]},"v":"Timestamp Ordering"},{"t":"list_item","d":6,"p":{"lines":[17,18]},"v":"Optimistic Concurrency Control"},{"t":"list_item","d":6,"p":{"lines":[18,19]},"v":"Two-Phase Locking"}]},{"t":"list_item","d":4,"p":{"lines":[19,20]},"v":"Version Storage","c":[{"t":"list_item","d":6,"p":{"lines":[20,21]},"v":"Append-Only Storage"},{"t":"list_item","d":6,"p":{"lines":[21,22]},"v":"Time-Travel Storage"},{"t":"list_item","d":6,"p":{"lines":[22,23]},"v":"Delta Storage"}]},{"t":"list_item","d":4,"p":{"lines":[23,24]},"v":"Garbage Collection","c":[{"t":"list_item","d":6,"p":{"lines":[24,25]},"v":"Tuple-Level","c":[{"t":"list_item","d":8,"p":{"lines":[25,26]},"v":"Background Vacuuming"},{"t":"list_item","d":8,"p":{"lines":[26,27]},"v":"Cooperative Cleaning"}]},{"t":"list_item","d":6,"p":{"lines":[27,28]},"v":"Transaction-Level"}]},{"t":"list_item","d":4,"p":{"lines":[28,29]},"v":"Index Management","c":[{"t":"list_item","d":6,"p":{"lines":[29,30]},"v":"Primary Key Index"},{"t":"list_item","d":6,"p":{"lines":[30,31]},"v":"Secondary Index","c":[{"t":"list_item","d":8,"p":{"lines":[31,32]},"v":"Logical Pointer"},{"t":"list_item","d":8,"p":{"lines":[32,33]},"v":"Physical Pointer"}]}]}]},{"t":"list_item","d":2,"p":{"lines":[33,34]},"v":"Index","c":[{"t":"list_item","d":4,"p":{"lines":[34,35]},"v":"B+ Tree"},{"t":"list_item","d":4,"p":{"lines":[35,36]},"v":"Bw Tree"},{"t":"list_item","d":4,"p":{"lines":[36,37]},"v":"Skip List"},{"t":"list_item","d":4,"p":{"lines":[37,38]},"v":"ART","c":[{"t":"list_item","d":6,"p":{"lines":[38,39]},"v":"Node4"},{"t":"list_item","d":6,"p":{"lines":[39,40]},"v":"Node16"},{"t":"list_item","d":6,"p":{"lines":[40,41]},"v":"Node48"},{"t":"list_item","d":6,"p":{"lines":[41,42]},"v":"Node256"}]},{"t":"list_item","d":4,"p":{"lines":[42,43]},"v":"Masstree"}]},{"t":"list_item","d":2,"p":{"lines":[43,44]},"v":"Storage","c":[{"t":"list_item","d":4,"p":{"lines":[44,45]},"v":"Type Representation"},{"t":"list_item","d":4,"p":{"lines":[45,46]},"v":"Data layout"},{"t":"list_item","d":4,"p":{"lines":[46,47]},"v":"Storage Model","c":[{"t":"list_item","d":6,"p":{"lines":[47,48]},"v":"NSM"},{"t":"list_item","d":6,"p":{"lines":[48,49]},"v":"DSM"},{"t":"list_item","d":6,"p":{"lines":[49,50]},"v":"Hybrid Storage Model"}]},{"t":"list_item","d":4,"p":{"lines":[50,51]},"v":"System Catalog"}]},{"t":"list_item","d":2,"p":{"lines":[51,52]},"v":"Compression","c":[{"t":"list_item","d":4,"p":{"lines":[52,53]},"v":"Naive Compression","c":[{"t":"list_item","d":6,"p":{"lines":[53,54]},"v":"LZO"},{"t":"list_item","d":6,"p":{"lines":[54,55]},"v":"LZ4"},{"t":"list_item","d":6,"p":{"lines":[55,56]},"v":"Snappy"},{"t":"list_item","d":6,"p":{"lines":[56,57]},"v":"Brotli"},{"t":"list_item","d":6,"p":{"lines":[57,58]},"v":"Oracle OZIP"},{"t":"list_item","d":6,"p":{"lines":[58,59]},"v":"Zstd"}]},{"t":"list_item","d":4,"p":{"lines":[59,60]},"v":"Null Supression"},{"t":"list_item","d":4,"p":{"lines":[60,61]},"v":"Run-length Encoding"},{"t":"list_item","d":4,"p":{"lines":[61,62]},"v":"Bitmap Encoding"},{"t":"list_item","d":4,"p":{"lines":[62,63]},"v":"Delta Encoding"},{"t":"list_item","d":4,"p":{"lines":[63,64]},"v":"Incremental Encoding"},{"t":"list_item","d":4,"p":{"lines":[64,65]},"v":"Mostly Encoding"},{"t":"list_item","d":4,"p":{"lines":[65,66]},"v":"Dictionary Encoding"}]},{"t":"list_item","d":2,"p":{"lines":[66,67]},"v":"Recovery","c":[{"t":"list_item","d":4,"p":{"lines":[67,68]},"v":"Logging Schemes","c":[{"t":"list_item","d":6,"p":{"lines":[68,69]},"v":"Physical vs. Logical"},{"t":"list_item","d":6,"p":{"lines":[69,70]},"v":"Flush"}]},{"t":"list_item","d":4,"p":{"lines":[70,71]},"v":"Checkpoint Protocols","c":[{"t":"list_item","d":6,"p":{"lines":[71,72]},"v":"Checkpoint Mechanism"},{"t":"list_item","d":6,"p":{"lines":[72,73]},"v":"Checkpoint Contents"},{"t":"list_item","d":6,"p":{"lines":[73,74]},"v":"Frequency"}]},{"t":"list_item","d":4,"p":{"lines":[74,75]},"v":"Restart Protocols"}]},{"t":"list_item","d":2,"p":{"lines":[75,76]},"v":"Network","c":[{"t":"list_item","d":4,"p":{"lines":[76,77]},"v":"Database Access API","c":[{"t":"list_item","d":6,"p":{"lines":[77,78]},"v":"DBMS-Specific"},{"t":"list_item","d":6,"p":{"lines":[78,79]},"v":"ODBC"},{"t":"list_item","d":6,"p":{"lines":[79,80]},"v":"JDBC"}]},{"t":"list_item","d":4,"p":{"lines":[80,81]},"v":"Database Network Protocols"},{"t":"list_item","d":4,"p":{"lines":[81,82]},"v":"Replication Protocols","c":[{"t":"list_item","d":6,"p":{"lines":[82,83]},"v":"Replica Configuration","c":[{"t":"list_item","d":8,"p":{"lines":[83,84]},"v":"Master-Replica"},{"t":"list_item","d":8,"p":{"lines":[84,85]},"v":"Multi-Master"}]},{"t":"list_item","d":6,"p":{"lines":[85,86]},"v":"Propagation Scheme"}]},{"t":"list_item","d":4,"p":{"lines":[86,87]},"v":"Kernel Bypass Methods"}]}],"p":{}}</svg>
              </div>
<h1 id="28-else"><a class="markdownIt-Anchor" href="#28-else"></a> 28 Else</h1>
<ol>
<li>Apache Arrow format</li>
<li>Delta: always refers to what changed</li>
<li>RCU, Read-Copy-Update</li>
<li>Latch vs. Lock
<ul>
<li>本质上都是锁，锁的对象不同。Lock锁的对象是事务；而<code>Latch</code>锁的对象是一些内存资源（数据结构）</li>
</ul>
</li>
</ol>

  <style>.markmap-container{display:flex;justify-content:center;margin:0 auto;width:90%;height:500px}.markmap-container svg{width:100%;height:100%}@media(max-width:768px){.markmap-container{height:400px}}</style>
  <script src="https://cdn.jsdelivr.net/npm/d3@5"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script>
  <script>
    const mindmaps = document.querySelectorAll('.markmap-svg');
    for(let mindmap of mindmaps) {
        markmap.markmap(mindmap, JSON.parse(mindmap.innerHTML));
    }
  </script> 
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%91%98%E5%BD%95/" rel="tag"># 摘录</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/25/Mysql-Server-Trial/" rel="prev" title="Mysql-Server-Trial">
      <i class="fa fa-chevron-left"></i> Mysql-Server-Trial
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/21/DBMS-Tools-Sqlancer/" rel="next" title="DBMS-Tools-Sqlancer">
      DBMS-Tools-Sqlancer <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-livere">livere</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane livere" id="comment-livere">
              
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzY0My8xMDE5OA=="></div>
  </div>
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-history"><span class="nav-text"> 1 history</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-inmemory"><span class="nav-text"> 2 inmemory</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#21-disk-oriented-dbmss"><span class="nav-text"> 2.1 Disk-Oriented DBMSs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-in-memory-dbmss"><span class="nav-text"> 2.2 In-Memory DBMSs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-concurrency-control-bottlenecks"><span class="nav-text"> 2.3 Concurrency Control Bottlenecks</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-mvcc1"><span class="nav-text"> 3 mvcc1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-mvcc2"><span class="nav-text"> 4 mvcc2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#41-microsoft-hekaton-sql-server"><span class="nav-text"> 4.1 Microsoft Hekaton (SQL Server)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-tum-hyper"><span class="nav-text"> 4.2 TUM HyPer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-sap-hana"><span class="nav-text"> 4.3 SAP HANA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-cmu-cicada"><span class="nav-text"> 4.4 CMU Cicada</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-summary"><span class="nav-text"> 4.5 Summary</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-mvcc3"><span class="nav-text"> 5 mvcc3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#51-mvcc-deletes"><span class="nav-text"> 5.1 MVCC Deletes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-garbage-collection"><span class="nav-text"> 5.2 Garbage Collection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-block-compaction"><span class="nav-text"> 5.3 Block Compaction</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-oltpindexes1"><span class="nav-text"> 6 oltpindexes1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#61-in-memory-t-tree"><span class="nav-text"> 6.1 In-Memory T-Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-latch-free-bw-tree"><span class="nav-text"> 6.2 Latch-Free Bw-Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#621-delta-updates"><span class="nav-text"> 6.2.1 Delta Updates</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#622-garbage-collection"><span class="nav-text"> 6.2.2 Garbage Collection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#623-structure-modifications"><span class="nav-text"> 6.2.3 Structure Modifications</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63-b-tree-optimistic-latching"><span class="nav-text"> 6.3 B+ Tree Optimistic Latching</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-oltpindexes2"><span class="nav-text"> 7 oltpindexes2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#71-latches"><span class="nav-text"> 7.1 Latches</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72-b-tree"><span class="nav-text"> 7.2 B+ Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#73-trie-index"><span class="nav-text"> 7.3 Trie Index</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#731-judy-array"><span class="nav-text"> 7.3.1 Judy Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#732-art"><span class="nav-text"> 7.3.2 ART</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#733-masstree"><span class="nav-text"> 7.3.3 Masstree</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-storage"><span class="nav-text"> 8 storage</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#81-type-representation"><span class="nav-text"> 8.1 Type Representation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#82-data-layout-alignment"><span class="nav-text"> 8.2 Data Layout &#x2F; Alignment</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#83-storage-models"><span class="nav-text"> 8.3 Storage Models</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#84-system-catalogs"><span class="nav-text"> 8.4 System Catalogs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#85-%E5%B0%8F%E7%BB%93"><span class="nav-text"> 8.5 小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-compression"><span class="nav-text"> 9 compression</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#91-compression-background"><span class="nav-text"> 9.1 Compression Background</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#92-naive-compression"><span class="nav-text"> 9.2 Naive Compression</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#93-olap-columnar-compression"><span class="nav-text"> 9.3 OLAP Columnar Compression</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#94-oltp-index-compression"><span class="nav-text"> 9.4 OLTP Index Compression</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-recovery"><span class="nav-text"> 10 recovery</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#101-logging-schemes"><span class="nav-text"> 10.1 Logging Schemes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#102-checkpoint-protocols"><span class="nav-text"> 10.2 Checkpoint Protocols</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#103-restart-protocols"><span class="nav-text"> 10.3 Restart Protocols</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-networking"><span class="nav-text"> 11 networking</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#111-database-access-apis"><span class="nav-text"> 11.1 Database Access APIs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#112-database-network-protocols"><span class="nav-text"> 11.2 Database Network Protocols</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#113-replication-protocols"><span class="nav-text"> 11.3 Replication Protocols</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#114-kernel-bypass-methods"><span class="nav-text"> 11.4 Kernel Bypass Methods</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-scheduling"><span class="nav-text"> 12 scheduling</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-execution"><span class="nav-text"> 13 execution</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-compilation"><span class="nav-text"> 14 compilation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-vectorization1"><span class="nav-text"> 15 vectorization1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-vectorization2"><span class="nav-text"> 16 vectorization2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-hashjoins"><span class="nav-text"> 17 hashjoins</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-sortmergejoins"><span class="nav-text"> 18 sortmergejoins</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-optimizer1"><span class="nav-text"> 19 optimizer1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-optimizer2"><span class="nav-text"> 20 optimizer2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-optimizer3"><span class="nav-text"> 21 optimizer3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-costmodels"><span class="nav-text"> 22 costmodels</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-largerthanmemory"><span class="nav-text"> 23 largerthanmemory</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-udfs"><span class="nav-text"> 24 udfs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-hardware"><span class="nav-text"> 25 hardware</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-%E8%AF%BE%E4%BB%B6"><span class="nav-text"> 26 课件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-summary"><span class="nav-text"> 27 Summary</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-else"><span class="nav-text"> 28 Else</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Liuyehcf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Liuyehcf</p>
  <div class="site-description" itemprop="description">大音希声，大象无形</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">286</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">103</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liuyehcf</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'qhEhLuMeMOy1zgcBhkqUS6P8-gzGzoHsz',
      appKey     : 'uhkruDLNLNdL5rQjRBY2X9Ke',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
